#+STARTUP: overview

[[https://necromuralist.github.io/posts/org-babel-cheat-sheet/][Org Babel Cheatsheet]]
[[https://org-babel.readthedocs.io/en/latest/eval/][Org Babel Reference Card]]
[[https://github.com/dfeich/org-babel-examples][Org Babel Examples]]

* On Hydras                                                       :hydra:doc:
[[https://github.com/abo-abo/hydra#awesome-docstring][Github source]]

This can be a simple string used to build the final hydra hint.
However, if you start it with a newline, the key-highlighting and
Ruby-style string interpolation becomes enabled.

To highlight a key, just wrap it in underscores (=_=). Note that the key
must belong to one of the heads. The key will be highlighted with the
color that is appropriate to the behavior of the key, i.e. if the key
will make the hydra exit, the color will be blue.

To insert an empty character, use =^=. The only use of this is to have
your code aligned as nicely as the result.

To insert a dynamic Elisp variable, use =%`= followed by the variable.
Each time the variable changes due to a head, the docstring will be
updated. format-style width specifiers can be used.

To insert a dynamic Elisp expression, use e.g. =%(length
(dired-get-marked-files))=. If a head will change the amount of marked
files, for example, it will be appropriately updated.

If the result of the Elisp expression is a string and you don't want
to quote it, use this form: =%s(shell-command-to-string "du -hs")=.

* Figure out Edebug and tracebacks
- [[http://endlessparentheses.com/debugging-emacs-lisp-part-1-earn-your-independence.html][Introduction part 1]]
- [[http://endlessparentheses.com/debugging-elisp-part-2-advanced-topics.html][Introduction part 2]]

** debugger-mode-map
0 .. 9                           digit-argument

TAB                              forward-button
RET                              debug-help-follow
ESC                              Prefix Command
SPC                              next-line
-                                negative-argument
R                                debugger-record-expression
b                                debugger-frame
c                                debugger-continue
d                                debugger-step-through
e                                debugger-eval-expression
h                                describe-mode
j                                debugger-jump
l                                debugger-list-functions
q                                top-level
r                                debugger-return-value
u                                debugger-frame-clear
v                                debugger-toggle-locals
<backtab>                        backward-button
<mouse-2>                        push-button
<normal-state>                   Prefix Command
<remap>                          Prefix Command

<normal-state> SPC              next-line
<normal-state> E                debugger-eval-expression
<normal-state> J                debugger-jump
<normal-state> L                debugger-toggle-locals
<normal-state> R                debugger-record-expression
<normal-state> Z                Prefix Command
<normal-state> c                debugger-continue
<normal-state> d                debugger-step-through
<normal-state> g                Prefix Command
<normal-state> p                debugger-toggle-locals
<normal-state> q                top-level
<normal-state> r                debugger-return-value
<normal-state> u                debugger-frame-clear
<normal-state> x                debugger-eval-expression
<normal-state> <S-tab>          backward-button
<normal-state> <return>         debug-help-follow
<normal-state> <tab>            forward-button

C-M-i                           backward-button

<normal-state> Z Q              evil-quit
<normal-state> Z Z              top-level

<normal-state> g b              debugger-frame
<normal-state> g l              debugger-list-functions

* Define useful constants
#+begin_src emacs-lisp :results output silent
  (when (boundp 'config-local-syncthing-folder)
    (unless (bound-and-true-p my-notes-folder)
      (defconst my-notes-folder (-> config-local-syncthing-folder
                                    (f-join "wiki"))))
    (defconst my-text-raw-folder (-> config-local-syncthing-folder
                                    (f-join "raw")))
    (defconst my-todo-org-file (-> config-local-syncthing-folder
                                    (f-join "todo.org")))
    (defconst my-text-routines-file (-> my-text-raw-folder
                                      (f-join "routines.org")))
    (defun find-user-syncthing-folder ()
      (interactive)
      (dired config-local-syncthing-folder)))
#+end_src

* General Faces
#+begin_src emacs-lisp :results output silent
  (custom-set-faces `(vertical-border ((((background light)) (:foreground ,sol-base3))
                                       (((background dark)) (:foreground ,sol-base03)))))
#+end_src

** Modelines
#+begin_src emacs-lisp :results output silent
  (custom-set-faces `(mode-line ((((background light))
                                  (:underline nil
                                   :overline ,sol-base2
                                   :box nil
                                   :background ,sol-base3))
                                 (((background dark))
                                  (:underline nil
                                   :overline ,sol-base02
                                   :box nil
                                   :background ,sol-base03)))))
  (custom-set-faces `(mode-line-inactive ((((background light))
                                           (:underline nil
                                            :overline nil
                                            :inherit mode-line
                                            :foreground ,sol-base2))
                                          (((background dark))
                                           (:underline nil
                                            :overline nil
                                            :inherit mode-line
                                            :foreground ,sol-base02)))))
  (custom-set-faces `(mode-line-highlight ((((background light))
                                            (:box nil :background ,sol-base2))
                                           (((background dark))
                                            (:box nil :background ,sol-base02)))))
#+end_src

** Header line
#+begin_src emacs-lisp :results output silent
  ;; (custom-set-faces '(header-line ((t (:inherit header-line :underline nil)))))
  ;; (set-face-underline 'header-line nil)
  (custom-set-faces '(header-line ((t (:inherit default :underline nil)))))
#+end_src

** Help Key binding
#+begin_src emacs-lisp :results output silent
  (custom-set-faces `(help-key-binding ((t (:box nil :background unspecified :foreground ,sol-yellow)))))
#+end_src

** Link
#+begin_src emacs-lisp :results output silent
  (custom-set-faces `(link ((t (:foreground ,sol-yellow :underline nil :bold t)))))
#+end_src
* Themes
** Base16
#+begin_src emacs-lisp :results output silent
  (use-package base16-theme
    ;; :straight (:host github :repo "belak/base16-emacs"
    ;;            :files (:defaults ("build" "build/*")))
    :straight t)
#+end_src
** Solarized
[[https://ethanschoonover.com/solarized/][Website with more descriptions]]

- Refer to docstring for =my-init-solarized-color-variables=.

#+begin_src emacs-lisp :results output silent
  (use-package solarized-theme
    :straight (:host github :repo "bbatsov/solarized-emacs")
    :if (display-graphic-p)
    :custom
    (solarized-use-variable-pitch nil)
    (solarized-distinct-fringe-background nil)
    (solarized-high-contrast-mode-line nil)
    (solarized-use-less-bold t)
    (solarized-use-more-italic nil)
    (solarized-scale-org-headlines nil)
    (solarized-height-minus-1 1.0)
    (solarized-height-plus-1 1.0)
    (solarized-height-plus-2 1.0)
    (solarized-height-plus-3 1.0)
    (solarized-height-plus-4 1.0))
  ;; (defun load-solarized-theme ()
  ;;   (interactive)
  ;;   (if (display-graphic-p)
  ;;       (load-theme 'solarized-dark t)
  ;;     (load-theme 'solarized-gruvbox-dark t))
  ;;   (with-eval-after-load 'prism
  ;;     (prism-set-colors
  ;;      :num 24
  ;;      :colors
  ;;      ;; (list sol-green sol-cyan sol-blue sol-yellow)
  ;;      (list 'font-lock-keyword-face 'font-lock-type-face 'font-lock-variable-name-face)
  ;;      :desaturations
  ;;      (list 10 20 30)
  ;;      :lightens
  ;;      (list 0 -2.5 -5)))
  ;;   (with-eval-after-load 'hl-todo
  ;;     (customize-set-variable 'hl-todo-keyword-faces
  ;;                             '(("TODO"    . "#b58900")
  ;;                               ("DEBUG"   . "#d33682")
  ;;                               ("NOTE"    . "#586e75")
  ;;                               ("FIXME"   . "#cb4b16")))))

#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package color-theme-sanityinc-solarized
    :after solarized-theme
    :disabled t
    :straight t)
#+end_src

** Eva-02
Personal theme that I'm maintaining (really stealing shamelessly from
Solarized)

#+begin_src emacs-lisp :results output silent
  ;; (defun load-eva02-theme ()
  ;;   (interactive)
  ;;   (load-theme 'eva02 t)
  ;;   (with-eval-after-load 'prism
  ;;     (prism-set-colors
  ;;      :num 24
  ;;      :colors
  ;;      ;; (list 'font-lock-keyword-face 'font-lock-type-face 'font-lock-variable-name-face 'font-lock-function-name-face)
  ;;      (list 'font-lock-keyword-face
  ;;            'font-lock-builtin-face
  ;;            'font-lock-variable-name-face)
  ;;      :desaturations
  ;;      (list 10 20 30)
  ;;      :lightens
  ;;      ;; (list 0 -2.5 -5)))
  ;;      (list 0 5 10)))
  ;;   (with-eval-after-load 'hl-todo
  ;;     (customize-set-variable 'hl-todo-keyword-faces
  ;;                             '(("TODO"    . "#ff0000")
  ;;                               ("DEBUG"   . "#ff0000")
  ;;                               ;; ("NOTE"    . "#ff0000")
  ;;                               ("FIXME"   . "#ff0000")))))
#+end_src


#+begin_src emacs-lisp :results output silent
  (use-package color-theme-sanityinc-solarized
    :disabled t ;; native comp is failing on this package
    :after solarized-theme
    :straight t)
#+end_src

** Nano
#+begin_src emacs-lisp :results output silent
    (use-package nano-theme
      :straight (:host github :repo "rougier/nano-theme")
      :commands (nano-light nano-dark nano-setup)
      :custom
      (nano-light-foreground sol-base1)
      (nano-light-background sol-base3)
      (nano-light-highlight sol-base2)
      (nano-light-subtle sol-base1)
      (nano-light-faded sol-base00)
      (nano-light-salient sol-cyan)
      (nano-light-strong sol-green)
      (nano-light-popout sol-blue)
      (nano-light-critical sol-red)

      (nano-dark-foreground sol-base01)
      (nano-dark-background sol-base03)
      (nano-dark-highlight sol-base02)
      (nano-dark-subtle sol-base01)
      (nano-dark-faded sol-base0)
      (nano-dark-salient nano-light-salient)
      (nano-dark-strong nano-light-strong)
      (nano-dark-popout nano-light-popout)
      (nano-dark-critical nano-light-critical))
#+end_src
** Display
#+begin_src emacs-lisp :results output silent
  ;; (when (display-graphic-p)
    ;; (load-solarized-theme))
    ;; (load-theme 'solarized-dark t))
    ;; (progn
    ;;  (load-theme 'solarized-light t)
    ;;  (customize-set-variable 'frame-background-mode 'light)))
  ;; (progn (nano-dark)
    ;;        (desktop-save-mode -1)))
  ;; (load-solarized-theme)
  ;; (load-eva02-theme)
#+end_src

* Quality of Life
** Frame Transparency
#+begin_src emacs-lisp :results output silent
  ;;;###autoload
  (defun my-set-frame-transparency (value)
    "Set the transparency of the frame window to VALUE.
  0=transparent/100=opaque"
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

** Highlight line
#+begin_src emacs-lisp :results output silent
  ;; (when (display-graphic-p)
  ;;  (global-hl-line-mode))
#+end_src

** Default input method
We're sticking to Japanese for now
#+begin_src emacs-lisp :results output silent
  (setq default-input-method "japanese")
#+end_src

** Recent files
   #+begin_src emacs-lisp :results output silent
     (use-package recentf
       :ensure nil
       :custom
       (recentf-max-saved-items nil)
       :config
       (evil-ex-define-cmd "recent" 'counsel-recentf))
   #+end_src

** Display Fill Column Indicator
#+begin_src emacs-lisp :results output silent
  (add-hook 'prog-mode-hook
            #'(lambda ()
               (display-fill-column-indicator-mode 'toggle)))
#+end_src

** Disable GUI Elements
#+begin_src emacs-lisp :results output silent
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (if (boundp 'scroll-bar-mode)
      (scroll-bar-mode -1))
  (window-divider-mode -1)
#+end_src

** Timestamp
Emulate the best feature of notepad

#+begin_src emacs-lisp :results output silent
  (defun iso-8601-timestamp (with-hours)
    (insert (format-time-string (if with-hours "%F-%H%M" "%F"))))
  (general-define-key
   :states '(normal motion insert)
   "<f5>" #'(lambda () (interactive)
             (iso-8601-timestamp nil))
   "S-<f5>" #'(lambda () (interactive)
               (iso-8601-timestamp t)))
  (general-define-key
   :states '(normal)
   "gb" #'(lambda () (interactive)
           (iso-8601-timestamp nil))
   "gB" #'(lambda () (interactive)
           (iso-8601-timestamp t)))
#+end_src

** Do not truncate lines
#+begin_src emacs-lisp :results output silent
  (setq-default truncate-lines t)
#+end_src

** Open a startup file as initial buffer
#+begin_src emacs-lisp :results output silent
  ;; (customize-set-variable 'initial-buffer-choice
  ;;                         (locate-user-emacs-file "config.org"))
#+end_src

** Configure scratch buffer message
#+begin_src emacs-lisp :results output silent
  (setq initial-scratch-message nil)
#+end_src

** Configure scratch buffer mode
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'initial-major-mode 'org-mode)
#+end_src

** Disable startup screen
#+begin_src emacs-lisp :results output silent
  (setq inhibit-startup-screen t)
#+end_src

** Change "yes or no" to "y or n"
#+begin_src emacs-lisp :results output silent
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Require newlines at the end of all files
#+begin_src emacs-lisp :results output silent
  (setq-default require-final-newline t)
#+end_src

** Disable alert sounds
#+begin_src emacs-lisp :results output silent
  (setq ring-bell-function 'ignore)
#+end_src

** Automatically refresh buffer when underlying file is changed externally
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'global-auto-revert-non-file-buffers t)
  (global-auto-revert-mode)
#+end_src

** Make window subprocess communications faster
#+begin_src emacs-lisp :results output silent
  (if (< emacs-major-version 27)
    (setq w32-pipe-read-delay 0))
#+end_src

** Set default tab width
#+begin_src emacs-lisp :results output silent
  (setq-default tab-width 4)
#+end_src

** Make <TAB> always indent
#+begin_src emacs-lisp :results output silent
  (setq tab-always-indent 'complete)
#+end_src

** Never indent with a TAB character
#+begin_src emacs-lisp :results output silent
  (setq-default indent-tabs-mode nil)
#+end_src

** Strip Whitespace on save
#+begin_src emacs-lisp :results output silent
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** Bind whitespace-mode
#+begin_src emacs-lisp :results output silent
  (general-define-key
   :states 'normal
   :prefix my-default-evil-leader-key
    "." 'whitespace-mode)
#+end_src

** Show trailing whitespace
actually, don't (outside of text modes)
#+begin_src emacs-lisp :results output silent
  (add-hook 'prog-mode-hook
    (customize-set-value 'show-trailing-whitespace t))
#+end_src

** After creating a new frame, immediately focus on that frame.
#+begin_src emacs-lisp :results output silent
  (add-hook 'after-make-frame-functions 'select-frame)
#+end_src

** Sentences should end after a single space, not two
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'sentence-end-double-space nil)
#+end_src

** Underscores should be considered as part of a word
#+begin_src emacs-lisp :results output silent
  (add-hook 'after-change-major-mode-hook #'(lambda () (modify-syntax-entry ?_ "w")))
#+end_src

** Ensure that files being edited are recoverable
#+begin_src emacs-lisp :results output silent
  (setq delete-old-versions t
        backup-by-copying t
        version-control t
        kept-new-versions 20
        kept-old-versions 5
        vc-make-backup-files t)
  (setq savehist-save-minibuffer-history 1
        savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
  (setq history-length t
        history-delete-duplicates t)
  (savehist-mode 1)
#+end_src

** Stretch caret to cover full width of character
http://pragmaticemacs.com/emacs/adaptive-cursor-width/
#+begin_src emacs-lisp :results output silent
  (setq x-stretch-cursor t)
#+end_src

** Display line numbers when editing code
#+begin_src emacs-lisp :results output silent
  (when (>= emacs-major-version 26)
    (add-hook 'prog-mode-hook 'display-line-numbers-mode))
#+end_src

#+begin_src emacs-lisp :results output silent
  (custom-set-faces `(line-number ((((background light)) (:background ,sol-base3 :foreground ,sol-base2))
                                   (((background dark)) (:background ,sol-base03 :foreground ,sol-base02)))))
  (custom-set-faces `(line-number-current-line ((((background light)) (:foreground ,sol-base1))
                                                (((background dark)) (:foreground ,sol-base01))
                                                (t (:inherit line-number)))))
#+end_src

** Show matching parens
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'show-paren-when-point-inside-paren t)
  (customize-set-variable 'show-paren-when-point-in-periphery t)
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+end_src

** Scroll like Vim
#+begin_src emacs-lisp :results output silent
  (setq scroll-step 1
        scroll-margin 1
        scroll-conservatively 9999)
#+end_src

** Activate hs-minor-mode on prog mode
#+begin_src emacs-lisp :results output silent
  (add-hook 'prog-mode-hook 'hs-minor-mode)
#+end_src

** Eval sexp and replace with results
Stolen from https://github.com/bbatsov/crux

#+begin_src emacs-lisp :results output silent
  ;; ;;;###autoload
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (let ((value (eval (elisp--preceding-sexp))))
      (backward-kill-sexp)
      (insert (format "%S" value))))
  (evil-ex-define-cmd "eval" 'eval-and-replace)

  ;;TODO: it's not working somehow
  ;;;###autoload
  (evil-define-command my-eval-and-replace (beg end _type)
    "Replace the preceding sexp with its value."
    (interactive "<v>")
    (let ((value (eval-region beg end (get-buffer (buffer-name)))))
      (insert (format "%S" value))))

  (evil-ex-define-cmd "eval" 'eval-and-replace)
#+end_src

** Completion
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'completion-ignore-case t)
  (customize-set-variable 'read-file-name-completion-ignore-case t)
  (customize-set-variable 'read-buffer-completion-ignore-case t)
#+end_src

** Copy file name to keyboard
#+begin_src emacs-lisp :results output silent
  (defun my-kill-path-to-keyboard ()
    "https://stackoverflow.com/questions/2416655/file-path-to-clipboard-in-emacs"
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename))))
#+end_src

#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "ypath" 'my-kill-path-to-keyboard)
#+end_src

** Tags table defaults
#+begin_src emacs-lisp :results output silent
  (setq-default tags-add-tables nil)
#+end_src

** Match Braces
#+begin_src emacs-lisp :results output silent
  (use-package elec-pair
    :disabled t
    :ensure nil
    :straight nil
    :config
    (electric-pair-mode))
#+end_src

** COMMENT If inside {}, [], or (), newline and indent
#+begin_src emacs-lisp :results output silent
  (defun config-block-insert-newline (list)
    "If the point is immediately bounded by {}, (), or [], indent it
    properly, given an alist of (BEFORE . AFTER) characters.
  Example, if the point is within {} like so {|}:
  When newline is pressed, turn it into {
      |
  }
  instead.
  "
    (interactive)
    (loop for (begin . end) in list
          when (and (string= begin (preceding-char))
                    (string= end (following-char)))
            do
            (newline)
            (indent-according-to-mode)
            (forward-line -1)
            (indent-according-to-mode)
            (return-from config-block-insert-newline)))
#+end_src

** Disable native compilation warnings
#+begin_src emacs-lisp :results output silent
  (when (and (featurep 'nativecomp) (native-comp-available-p))
    (customize-set-variable 'comp-async-report-warnings-errors nil))
#+end_src

** Set commands
#+begin_src emacs-lisp :results output silent
  (evil-define-command config-ex-set-arg (cmd)
    (interactive "<a>")
    (cond
     ((string= cmd "wrap") (visual-line-mode 1))
     ((string= cmd "nowrap") (visual-line-mode -1))
     ;; This isn't actually how colorcolumn worked in vi
     ;; (read :h colorcolumn)
     ((or (string= cmd "colorcolumn")
          (string= cmd "cc")) (display-fill-column-indicator-mode
                               'toggle))))
  (evil-ex-define-cmd "set" 'config-ex-set-arg)
#+end_src

** Electric Indent
#+begin_src emacs-lisp :results output silent
  (electric-indent-mode)
#+end_src

** Buffer menu mode map config
#+begin_src emacs-lisp :results output silent
  (general-define-key
   :keymaps 'Buffer-menu-mode-map
   :states '(normal motion)
   "C-d" 'evil-scroll-down)
#+end_src

** Don't compact font caches
#+begin_src emacs-lisp :results output silent
  (customize-set-value 'inhibit-compacting-font-caches t)
#+end_src
** COMMENT Prefer dark backgrounds
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'frame-background-mode 'dark)
  (set-terminal-parameter nil 'background-mode 'dark)
#+end_src

** Fonts
We are preferring these fonts because they look nicer and play nicer
with Chinese/Japanese.

0123456789abcdefghijklmnopqrstuvwxyz [] () :;,. !@#$^&*
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ {} <> "'`  ~-_/|\?

#+begin_src emacs-lisp :results output silent
  (cond
   ((find-font (font-spec :name "Iosevka"))
    (cond
      ((eq system-type 'darwin) (set-frame-font "Iosevka-14" nil t))
      (t (set-frame-font "Iosevka-12" nil t))))
   ((find-font (font-spec :name "Courier")) (set-frame-font "Courier-10" nil t)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (when (find-font (font-spec :name "Iosevka"))
    (custom-set-faces '(fixed-pitch ((t (:family "Iosevka")))))
    (custom-set-faces '(variable-pitch ((t (:family "Iosevka")))))
    (custom-set-faces '(fixed-pitch-serif ((t (:family "Iosevka"))))))
  (when (find-font (font-spec :name "Iosevka Etoile"))
    (custom-set-faces '(variable-pitch ((t (:family "Iosevka Etoile"))))))
  (when (find-font (font-spec :name "Iosevka Aile"))
    (custom-set-faces '(fixed-pitch-serif ((t (:family "Iosevka Aile"))))))
#+end_src

TODO:
- [ ] Update variable-pitch to use iosevka-aile
- [ ] Update fixed-pitch and fixed-pitch-serif

** Emacs bookmarks
Save bookmarks immediately.
#+begin_src emacs-lisp :results output silent
  (setq bookmark-save-flag 1)
#+end_src

Further helper functions to add bookmarks:
#+begin_src emacs-lisp :results output silent
  ;;;###autoload
  (defun config-define-bookmark (name path &optional overwrite annotation)
    "Programmatically creates and stores bookmarks into the bookmark file.
  We do this here because as of 2019-04-01T16:13:14+0800 we have no idea
  if there is an existing interface to do this. If one is found this
  will be marked obsolete and we'll move to that instead.

  The bookmark list format is found at `bookmark-alist'.

  NAME - Name of the bookmark.
  PATH - filepath of the bookmark.
  OVERWRITE - if true, overwrite an existing bookmark of the same name
  if one currently exists.
  ANNOTATION - Optional annotation of the bookmark.

  If PATH does not point to anywhere valid, this function is a no-op and
  no bookmark will be created."
    (require 'bookmark)
    (when (file-exists-p path)
      (let* ((annot (if annotation annotation ""))
             (alist `((filename . ,path)
                      (front-context-string . "")
                      (rear-context-string . "")
                      (position . 0)
                      (annotation . ,annot))))
         (bookmark-store name alist overwrite))))
#+end_src

#+begin_src emacs-lisp :results output silent
  (my-evil-define-split-vsplit-cmd "bm" 'list-bookmarks)
  (evil-ex-define-cmd "Tbm" #'(lambda ()
      ;; TODO: unify this implementation with my-new-cmd-tab
                               (interactive)
                               (if (>= emacs-major-version 27)
                                   (tab-bar-new-tab)
                                (require 'eyebrowse)
                                (my-new-evil-tab nil))
                               (funcall-interactively 'list-bookmarks)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "mm" #'(lambda ()
                              (interactive)
                              (require 'counsel)
                              (counsel-bookmark)))
  (evil-ex-define-cmd "Tmm" #'(lambda ()
      ;; TODO: have counsel-bookmark run earlier so if we cancel we
      ;; don't get a new tab
                               (interactive)
                               (require 'counsel)
                               (if (>= emacs-major-version 27)
                                   (tab-bar-new-tab)
                                (require 'eyebrowse)
                                (my-new-evil-tab nil))
                               (funcall-interactively 'counsel-bookmark)))
  ;; (defun my-open-bookmark-in-tab ()
  ;;   (interactive)
  ;;   (require 'counsel)
  ;;   (ivy-read "Create or jump to bookmark: "
  ;;             (bookmark-all-names)
  ;;             :history 'bookmark-history
  ;;             :action (lambda (x)
  ;;                       (cond ((and counsel-bookmark-avoid-dired
  ;;                                   (member x (bookmark-all-names))
  ;;                                   (file-directory-p (bookmark-location x)))
  ;;                              (with-ivy-window
  ;;                                (let ((default-directory (bookmark-location x)))
  ;;                                  (counsel-find-file))))
  ;;                             ((member x (bookmark-all-names))
  ;;                              (with-ivy-window
  ;;                                (bookmark-jump x)))
  ;;                             (t (bookmark-set x))))))
  ;; (evil-ex-define-cmd "Tmm")
#+end_src

*** Bookmark Face
#+begin_src emacs-lisp :results output silent
  (custom-set-faces '(bookmark-face ((t (:inherit sol-subtle)))))
#+end_src

** Doctor mode
#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "doc[tor]" 'doctor)
#+end_src

** Tab bar mode                                                          :27:
This only works if emacs version is 27 or above (there's already some
evil integration), refer to Eyebrowse for Emacs version <27 tab handling
#+begin_src emacs-lisp :results output silent
  (use-package tab-bar
    :ensure nil
    :straight nil
    :if (>= emacs-major-version 27)
    :custom-face
    (tab-bar ((t (:inherit minibuffer-prompt :underline nil))))
    (tab-bar-tab-inactive ((((background light))
                            (:foreground ,sol-base1 :italic nil))
                           (((background dark))
                            (:foreground ,sol-base01 :italic nil))))
    (tab-bar-tab ((t (:inherit default))))
    :custom
    (tab-bar-close-last-tab-choice 'delete-frame)
    (tab-bar-new-tab-choice t)
    (tab-bar-close-button-show nil)
    (tab-bar-new-button-show nil)
    (tab-bar-close-tab-select 'left)
    (tab-bar-new-button nil)
    (tab-bar-new-tab-to 'right)
    :config
    (tab-bar-mode)
    (evil-ex-define-cmd "gt" 'tab-bar-switch-to-next-tab)
    (evil-ex-define-cmd "gT" 'tab-bar-switch-to-prev-tab)
    ;; (with-eval-after-load 'org-agenda
    ;;   (general-define-key
    ;;    :keymaps 'org-agenda-mode-map
    ;;    :states '(motion)
    ;;    :prefix my-default-evil-leader-key
    ;;    "g t" 'tab-bar-switch-to-next-tab
    ;;    "g T" 'tab-bar-switch-to-prev-tab))
    (evil-define-command my-tab-bar-tab-edit (file)
      (interactive "<f>")
      (let ((tab-bar-new-tab-choice (if file file "*scratch*")))
        (tab-bar-new-tab)))
    (evil-ex-define-cmd "tabn[ew]" 'my-tab-bar-tab-edit)
    (evil-ex-define-cmd "tabe[dit]" 'tab-bar-new-tab)
    ;;TODO: currently has issue where :q on a tab kills emacs
    (evil-ex-define-cmd "tabc[lose]" 'tab-bar-close-tab)
    ;;TODO: check if ivy has something for this someday
    (evil-ex-define-cmd "tabs" 'tab-bar-select-tab-by-name)
    (evil-ex-define-cmd "tt" 'tab-bar-select-tab-by-name)
    (defun my-tab-bar-delete-tab-or-emacs (oldfun &rest _old_args)
      (interactive)
      (let* ((tabs (find-if (lambda (elem) (eq 'tabs (car elem)))
                            (frame-parameters)))
             (num-tabs (length (cdr tabs))))
        (if (eq num-tabs 1)
            (call-interactively oldfun)
          (tab-bar-close-tab))))
    (advice-add 'delete-frame :around 'my-tab-bar-delete-tab-or-emacs))
#+end_src

** TODO Tab line mode
Tab line is like tab bar but for windows

** Desktop mode
#+begin_src emacs-lisp :results output silent
  ;;(desktop-save-mode)
#+end_src

** Open Email command
#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "inbox"
                      #'(lambda ()
                          (interactive)
                          ;;TODO: Find out a way to always open the same
                          ;;tab so I don't have to constantly relog in.
                          (browse-url "https://beta.protonmail.com")))
#+end_src

** EDiff qol
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'ediff
    (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

** Function to find all parent modes
I wrote this for =fci-mode= restarting then I figured I could just check
for the existence of =fci-mode= instead of finding through all the modes
for the specific hook.
#+begin_src emacs-lisp :results output silent
  (defun my-find-major-mode-parents (mode)
    "Recursively composes a list of all parent modes for a given
  mode."
    (when mode
      (cons mode
            (my-find-major-mode-parents (get-mode-local-parent mode)))))
#+end_src


* Apropos Configuration
#+begin_src emacs-lisp :results output silent
  (use-package apropos
    :ensure nil
    :straight nil
    :custom
    (apropos-do-all t)
    :init
    (evil-define-command my-apropos (pattern)
      (interactive "<a>")
      (apropos pattern))
    (evil-ex-define-cmd "h[elp]" 'my-apropos))
#+end_src

* Which Key
#+begin_src emacs-lisp :results output silent
  (use-package which-key
    :straight (:host github :repo "justbur/emacs-which-key")
    :demand t
    :general
    (:states 'normal
     "C-h M-k" 'which-key-show-keymap
     "C-h M-m" 'which-key-show-full-major-mode)
    :config
    (which-key-mode))
#+end_src

* Hercules
:PROPERTIES:
:DEPENDENCIES: which-key
:END:

Using functions to enter and exit is a fair bit clunky, so I'm
re-evaluating the need for this

#+begin_src emacs-lisp :results output silent
  (use-package hercules
    :disabled t
    :straight (:host gitlab :repo "jjzmajic/hercules.el")
    :commands (hercules-def))
#+end_src

* Packaging
#+begin_src emacs-lisp :results output silent
  (use-package auto-package-update
    :disabled t
    :straight (:host github :repo "rranelli/auto-package-update.el")
    :commands (auto-package-update-now
               auto-package-update-at-time
               auto-package-update-maybe)
    :custom
    (auto-package-update-delete-old-versions t
                                             "We already version them on
                                             git")
    (auto-package-update-prompt-before-update t
                                              "NO SURPRISES")
    (auto-package-update-interval 14
                                  "update once every 2 weeks (the count
                                  is in days)"))
#+end_src

* Ace Link
#+begin_src emacs-lisp :results output silent
  (use-package avy
    :disabled t
    :straight (:host github :repo "abo-abo/avy"))
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package ace-link
    :straight (:host github :repo "abo-abo/ace-link")
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "f" 'ace-link)
    :commands (ace-link
               ace-link-eww))
#+end_src

* Smartparens

TODO: Make it so that if the point is inside {} or something similar,
pressing RET autoformats it, instead of doing nothing as it does right now

#+begin_src emacs-lisp :results output silent
  (use-package smartparens
    :straight (:host github :repo "Fuco1/smartparens")
    :defer 2
    :diminish smartparens-mode
    :commands (sp-local-pair
               smartparens-global-mode)
    :hook
    ;; TODO: make this not just hooked on prog-mode
    (prog-mode-hook . (lambda () (interactive)
                        (require 'smartparens-config) ;; load some default configurations
                        (require 'smartparens)))
    :custom-face
    (sp-pair-overlay-face ((t (:inherit default :underline nil))))
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "." 'smartparens-mode)
    :custom
    (sp-cancel-autoskip-on-backward-movement
     nil
     "We want to maintain the chomp-like behavior of electric-pair")
    (sp-autoskip-closing-pair
     'always
     "Maintain chomp-like behavior of electric-pair")
    :config
    (smartparens-global-mode)
    ;; (smartparens-global-strict-mode)
    ;; (show-smartparens-global-mode)
    ;; define some helper functions
    (defun my-add-newline-and-indent-braces (_opening_delimiter
                                             _actions
                                             _context)
      "adds that cool vim indent thing we always wanted, Refer to WHEN
    segment of `sp-pair' documentation on what each parameter does"
      (newline)
      (indent-according-to-mode)
      (forward-line -1)
      (indent-according-to-mode))
    ;; update the global definitions with some indenting
    ;; I think that the nil is the flag that controls property inheritance
    ;;note: for some reason tab isn't recognised. might be yasnippet intefering.
    ;;learn to use ret for now
    (sp-pair "{" nil :post-handlers '((my-add-newline-and-indent-braces "RET")))
    (sp-pair "[" nil :post-handlers '((my-add-newline-and-indent-braces "RET")))
    (sp-pair "(" nil :post-handlers '((my-add-newline-and-indent-braces "RET"))))
#+end_src

* Evil
** Alignment
#+begin_src emacs-lisp :results output silent
  (use-package evil-lion
    :straight (:host github :repo "edkolev/evil-lion")
    :after (evil)
    :general
    (:keymaps '(normal visual)
     "gl"     'evil-lion-left
     "gL"     'evil-lion-right))
#+end_src

** Increment and Decrement
Disabled because I'm slowly turning into an Emacs citizen.
#+begin_src emacs-lisp :results output silent
  (use-package evil-numbers
    :disabled t
    :straight (:host github :repo "cofi/evil-numbers")
    :general
    (:keymaps 'normal
     "C-a"  'evil-numbers/inc-at-pt
     "C-x"  'evil-numbers/dec-at-pt))
#+end_src

** Goggles
#+begin_src emacs-lisp :results output silent
  (use-package evil-goggles
    :straight (:host github :repo "edkolev/evil-goggles")
    :commands (evil-goggles-mode)
    :init
    (evil-ex-define-cmd "gog[gles]" 'evil-goggles-mode)
    :config
    (evil-goggles-use-diff-faces))
#+end_src

** Evil Expat
Adds the following ex commands:

| :reverse           | reverse visually selected lines                                |
| :remove            | remove current file and its buffer                             |
| :rename NEW-PATH   | rename or move current file and its buffer                     |
| :colorscheme THEME | change emacs color theme                                       |
| :diff-orig         | get a diff of unsaved changes, like vim's common :DiffOrig     |
| :gdiff             | BRANCH git-diff current file, requires magit and vdiff-magit   |
| :gblame            | git-blame current file, requires magit                         |
| :gremove           | git remove current file, requires magit                        |
| :tyank             | copy range into tmux paste buffer, requires running under tmux |
| :tput              | paste from tmux paste nuffer, requires running under tmux      |

#+begin_src emacs-lisp :results output silent
  (use-package evil-expat
    :straight (:host github :repo "edkolev/evil-expat"))
#+end_src

** Matchit
#+begin_src emacs-lisp :results output silent
  (use-package evil-matchit
    :straight (:host github :repo "redguardtoo/evil-matchit")
    :after evil
    :config
    (global-evil-matchit-mode))
#+end_src

** Visualstar
Allows for * and # commands. which originally only worked on WORDs,
to work on a visual selection too

#+begin_src emacs-lisp :results output silent
  (use-package evil-visualstar
    :straight (:host github :repo "bling/evil-visualstar")
    :general
    (:keymaps 'visual
     "*" 'evil-visualstar/begin-search-forward
     "#" 'evil-visualstar/begin-search-backward))
#+end_src

** Fringe marks
Disabled because it kept raising a warning during init about markerp.
Now disabled because it conflicts with git-gutter+-fringe. We should
want to learn marks properly anyway.

#+begin_src emacs-lisp :results output silent
  (use-package evil-fringe-mark
    :straight (:host github :repo "Andrew-William-Smith/evil-fringe-mark")
    :disabled t
    :custom
    (evil-fringe-mark-show-special nil)
    :config
    (global-evil-fringe-mark-mode))
#+end_src

** Visual marks
#+begin_src emacs-lisp :results output silent
  (use-package evil-visual-mark-mode
    :disabled t
    :straight (:host github :repo "roman/evil-visual-mark-mode")
    :commands evil-visual-mark-mode)
#+end_src

** Input method Convenience toggle
https://www.emacswiki.org/emacs/Evil#toc24

#+begin_src emacs-lisp :results output silent
  (defun my-evil-toggle-input-method ()
    (interactive)
    (let ((is-insert-state (string= evil-state "insert")))
      (cond
       ((and (not current-input-method) (not is-insert-state)) (evil-insert-state))
       ((and current-input-method is-insert-state) (evil-normal-state))
       (t nil))
      (toggle-input-method)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (general-define-key
   :keymaps 'global
   "C-\\" 'my-evil-toggle-input-method)
#+end_src

** TODO Interactive Codes
Look at =evil-interactive-alist=, which seems to contain all the
interactive codes provided.

** Replace with Register
#+begin_src emacs-lisp :results output silent
  (use-package evil-replace-with-register
    :straight (:host github :repo "Dewdrops/evil-ReplaceWithRegister")
    :disabled t ;; don't use it
    :after evil
    :config
    (evil-replace-with-register-install))
#+end_src

** Text Objects
*** Latex Textobjects
I appear to have stolen this from somewhere, probably because the original
package isn't being maintained or something

| Key | Description                          |
|-----+--------------------------------------|
| =$= | Inline math ($$)                     |
| =\= | Display math (=\[ \]=)               |
| =m= | TeX macros (\foo{})                  |
| =E= | Tex environments (\begin{}...\end{}) |

#+begin_src emacs-lisp :results output silent
  (use-package evil-latex-textobjects
    :straight nil
    :load-path "local-packages/"
    :commands (turn-on-evil-latex-textobjects-mode)
    :general
    (:keymaps 'evil-latex-textobjects-inner-map
     "e" nil
     "E" 'evil-latex-textobjects-inner-env)
    (:keymaps 'evil-latex-textobjects-outer-map
     "e" nil
     "E" 'evil-latex-textobjects-an-env)
    :hook (LaTeX-mode-hook . turn-on-evil-latex-textobjects-mode))
#+end_src

*** [#A] Surround text objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-surround
    :straight (:host github :repo "emacs-evil/evil-surround")
    :after (evil)
    :config
    (global-evil-surround-mode))
#+end_src

**** TODO evil-embrace
https://github.com/cute-jumper/evil-embrace.el/

*** [#A] Argument text objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-args
    :straight (:host github :repo "wcsmith/evil-args")
    :after (evil)
    :general
    (evil-inner-text-objects-map
     "a" 'evil-inner-arg)
    (evil-outer-text-objects-map
     "a" 'evil-outer-arg)
    :config
    ;; these variables don't exist until evil-arg loads
    (push "<" evil-args-openers)
    (push ">" evil-args-closers))
#+end_src

*** Comment using text objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-commentary
    :straight (:host github :repo "linktohack/evil-commentary")
    :after (evil)
    :config
    (evil-commentary-mode))
#+end_src

*** Comment Text Objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-nerd-commenter
    :straight (:host github :repo "redguardtoo/evil-nerd-commenter")
    :after (evil)
    :general
    (evil-inner-text-objects-map
     "c" 'evilnc-inner-comment)
    (evil-outer-text-objects-map
     "c" 'evilnc-outer-commenter))
#+end_src

(Compatibility with evil-matchit)
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'evil-matchit
    (with-eval-after-load 'evil-nerd-commenter
      (evilmi-load-plugin-rules '(mhtml-mode) '(template simple html))))
#+end_src

*** Syntax Text Objects
Bound to "h"

#+begin_src emacs-lisp :results output silent
  (use-package evil-textobj-syntax
    :disabled t
    :straight (:host github :repo "laishulu/evil-textobj-syntax")
    :after evil)
#+end_src

*** [#B] Indent text objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-indent-plus
    :straight (:host github :repo "TheBB/evil-indent-plus")
    :general
    (evil-inner-text-objects-map
     "i" 'evil-indent-plus-i-indent
     "I" 'evil-indent-plus-a-indent)
    (evil-outer-text-objects-map
     "i" 'evil-indent-plus-i-indent-up
     "I" 'evil-indent-plus-a-indent-up))
#+end_src

*** Line Text Objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-textobj-line
    :straight (:host github :repo "syohex/evil-textobj-line")
    :after evil)
#+end_src

*** Targets
This is an expensive package to load, and I wonder why.

#+begin_src emacs-lisp :results output silent
  (use-package targets
    :disabled t ;; See what we're missing if we don't use this for now
    :straight (:host github :repo "noctuid/targets.el")
    :general
    (evil-inner-text-objects-map
     "b" 'targets-inner-paren
     "B" 'targets-inner-curly)
    (evil-outer-text-objects-map
     "b" 'targets-a-paren
     "B" 'targets-a-curly)
    :config
    (targets-setup t
                   :last-key nil
                   :next-key nil
                   :inside-key nil
                   :around-key nil
                   :remote-key nil))
#+end_src

*** Evil-cleverparens
#+begin_src emacs-lisp :results output silent
  (use-package evil-cleverparens
    :straight (:host github :repo "luxbock/evil-cleverparens")
    :general
    (evil-inner-text-objects-map
     "f" 'evil-cp-inner-form)
    (evil-outer-text-objects-map
     "f" 'evil-cp-a-form)
    (evil-cleverparens-mode-map
     :states '(visual normal)
     ">" nil
     "<" nil
     "{" nil
     "}" nil))
#+end_src

*** Sentences
#+begin_src emacs-lisp :results output silent
  (use-package sentence-navigation
    :straight (:host github :repo "noctuid/emacs-sentence-navigation")
    ;; not actively updated, last commit 3 years ago, breaks with emacs 27
    :disabled t
    :general
    (:states 'motion
     ")" 'sentence-nav-evil-forward
     "(" 'sentence-nav-evil-backward
     "g)" 'sentence-nav-evil-forward-end
     "g(" 'sentence-nav-evil-backward-end)
    (evil-outer-text-objects-map
     "s" 'sentence-nav-evil-a-sentence)
    (evil-inner-text-objects-map
     "s" 'sentence-nav-evil-inner-sentence))
#+end_src

*** [K]olumns
#+begin_src emacs-lisp :results output silent
  (use-package evil-textobj-column
    :straight (:host github :repo "noctuid/evil-textobj-column")
    :general
    (evil-outer-text-objects-map
     "k" 'evil-textobj-column-word
     "K" 'evil-textobj-column-WORD))
#+end_src

*** XML Attributes
#+begin_src emacs-lisp :results output silent
  (use-package exato
    :straight t
    :after evil)
#+end_src

** Unimpaired port
#+begin_src emacs-lisp :results output silent
  (use-package evil-unimpaired
    :disabled t
    :straight (:host github :repo "zmaas/evil-unimpaired")
    :after evil
    :config
    (evil-unimpaired-mode))
#+end_src

#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'evil-collection
    (global-evil-collection-unimpaired-mode))
#+end_src

** TODO Asyncrun
Just append =&= to the end of your command, emacs apparently just does
the right thing.

* Helm
** Describe Modes
#+begin_src emacs-lisp :results output silent
  (use-package helm-describe-modes
    :disabled t
    :straight (:host github
               :repo "emacs-helm/helm-describe-modes")
    :general
    ("C-h m" 'helm-describe-modes))
#+end_src

** Describe Bindings
Use counsel instead
#+begin_src emacs-lisp :results output silent
  (use-package helm-descbinds
    :disabled t
    :straight (:host github
               :repo "emacs-helm/helm-descbinds")
    :general
    ("C-h b" 'helm-descbinds))
#+end_src

#+begin_src emacs-lisp :results output silent
  (general-define-key "C-h b" 'counsel-descbinds)
#+end_src

* Emacsql
#+begin_src emacs-lisp :results output silent
  (use-package emacsql-psql
    :straight t)
#+end_src

* Org Mode
** Org Id
#+begin_src emacs-lisp :results output silent
  (use-package org-id
    :ensure nil
    :straight nil
    :defer t
    :custom
    (org-id-ts-format "%s")
    (org-id-method 'ts))
#+end_src

** Evil Org Bindings
Full keybindings:
- https://github.com/Somelauw/evil-org-mode/blob/master/doc/keythemes.org


Important bindings:

| <M-S-return> | Insert checkbox item |

Interesting Text Objects:

| key     | function                          | examples                         |
|---------+-----------------------------------+----------------------------------|
| ae / ie | evil-org-an/inner-object          | link, markup, table cell         |
| aE / iE | evil-org-an/inner-element         | paragraph, code block, table row |
| ar / ir | evil-org-an/inner-greater-element | item list, table                 |
| aR / iR | evil-org-an/inner-subtree         | subtree starting with a header   |


#+begin_src emacs-lisp :results output silent
  (use-package evil-org
    :straight (:host github :repo "Somelauw/evil-org-mode")
    :hook ((org-mode-hook . evil-org-mode))
    :custom
    (evil-org-retain-visual-state-on-shift
     t "Let us chain < and > calls")
    (evil-org-use-additional-insert
     t "Add things like M-j to insert")
    (evil-org-special-o/O
     '(table-row) "Do not let o/O affect list items, throws me off")
    (org-special-ctrl-a/e
     t "Pretend leading stars on headlines don't exist when using A/I")
    :general
    (evil-org-mode-map
     :states 'normal
     "g f" 'evil-org-open-links)
    :config
    (evil-org-set-key-theme '(textobjects
                              ;; insert ;; replaces c-t and c-d
                              navigation
                              additional
                              shift
                              return
                              operators
                              ;; todo
                              ;; heading
                              calendar)))
#+end_src

** Org Capture Bindings
#+begin_src emacs-lisp :results output silent
  (use-package org-capture
    :ensure nil ;; because org-capture is from org
    :straight nil
    :after (org)
    :defer 20
    :commands (org-capture
               org-capture-templates)
    :general
    (:states 'motion
     ;; In evil it's jump to column number, which isn't that useful tbh
     "C-|" 'my-counsel-org-capture)
    ;; "c j" '((lambda () (interactive) (org-capture nil "j"))
    ;;         :which-key "Capture journal entry")
    ;; "c d" '((lambda () (interactive) (org-capture nil "d"))
    ;;         :which-key "Capture daydream entry"))
    ;; (:prefix my-default-evil-leader-key
    ;;  :keymaps 'org-capture-mode-map
    ;;  :states 'normal
    ;;  "r r" 'org-capture-refile)
    (org-capture-mode-map
     [remap evil-save-and-close]          'org-capture-finalize
     [remap evil-save-modified-and-close] 'org-capture-finalize
     [remap evil-quit]                    'org-capture-kill)
    ;; :init
    ;; (defun my-capture-daydream ()
    ;;   ""
    ;;   (interactive)
    ;;   (org-capture nil "d")
    ;; (evil-ex-define-cmd "todo" 'my-capture-daydream)
    :hook (org-capture-mode-hook . evil-insert-state)
    :init
    (defun my-counsel-org-capture ()
      (require 'org-capture)
      (interactive)
      (if (featurep 'counsel-projectile)
          (counsel-projectile-org-capture)
        (counsel-org-capture)))
    :config
    (with-eval-after-load 'counsel
      ;; Remove ^ prefix in ivy org capture
      (require 'dash)
      (customize-set-variable 'ivy-initial-inputs-alist
                              (-remove (lambda (e) (eq (car e) 'counsel-org-capture))
                                       ivy-initial-inputs-alist)))
    (setq org-capture-templates
          (doct-add-to org-capture-templates
                       '(("Clock Item"
                          :keys "cc"
                          :type item
                          :clock t
                          :prepend t
                          ;; leaving template to nil adds a backlink to the
                          ;; parent item (probaby because it's the currently
                          ;; clocked task). Interesting
                          :template "%?"
                          :clock-resume t)
                         ("Current Clock"
                          :keys "ct"
                          :type entry
                          :clock t
                          :prepend t
                          ;; leaving template to nil adds a backlink to the
                          ;; parent item (probaby because it's the currently
                          ;; clocked task). Interesting
                          :template "* TODO %?"
                          :clock-resume t)
                         ("Note Clock"
                          :keys "cn"
                          :type entry
                          :clock t
                          :prepend t
                          :template "* %?"
                          :clock-resume t))))
    ;; (add-to-list 'org-capture-templates
    ;;               `("cc" "Current Clock" item
    ;;                 (clock)
    ;;                 "Note taken on %U \\\\\n%?"
    ;;                 :prepend t
    ;;                 :clock-resume t))
    (when (boundp 'my-todo-org-file)
      ;; (doct `(("Personal"
      ;;          :file ,my-todo-org-file
      ;;          :prepend t
      ;;          :keys "t"
      ;;          :children ("TODO"
      ;;                     :keys "t"
      ;;                     :todo-state "TODO"))))
      ;; (add-to-list 'org-capture-templates
      ;;              `("tt" "Personal Todo" entry
      ;;                (file ,my-todo-org-file)
      ;;                ,(concat "* TODO %^{DESCRIPTION} %^g \n"
      ;;                         ":PROPERTIES:\n"
      ;;                         ":CREATED:  %U\n" ;; captured as property TIMESTAMP
      ;;                         ":END:\n"
      ;;                         "%?")))
      ;; (add-to-list 'org-capture-templates
      ;;   (doct `(("Personal Note Test"
      ;;            :keys "nt"
      ;;            :file ,my-todo-org-file
      ;;            :type entry
      ;;            :template ("* %^{DESCRIPTION} %^g"
      ;;                       ":PROPERTIES:"
      ;;                       ":CREATED: %U" ;; captured as property TIMESTAMP
      ;;                       ":END:"
      ;;                       "%?")))))
      (add-to-list 'org-capture-templates
                   `("ii" "Immediate Clock" entry
                     (file ,my-todo-org-file)
                     ,(concat "* %^{DESCRIPTION} %^g \n"
                              ":PROPERTIES:\n"
                              ":CREATED:  %U\n" ;; captured as property TIMESTAMP
                              ":END:\n"
                              ":LOGBOOK:\n"
                              ":END:\n"
                              "%?")
                     :prepend t
                     :clock-in t))
      (add-to-list 'org-capture-templates
                   `("ss" "Study Note" entry
                     (file ,my-todo-org-file)
                     ,(concat "* %^{DESCRIPTION} :study:%^g\n"
                              ":PROPERTIES:\n"
                              ":CREATED:  %U\n" ;; captured as property TIMESTAMP
                              ":END:\n"
                              ":LOGBOOK:\n"
                              ":END:\n"
                              "%?")))
      (add-to-list 'org-capture-templates
                   `("nn" "Note, unscheduled TODO entry." entry
                     (file ,my-todo-org-file)
                     ,(concat "* TODO %^{DESCRIPTION} %^g \n"
                              "SCHEDULED: %(org-insert-time-stamp (org-read-date nil t))\n"
                              ":PROPERTIES:\n"
                              ":CREATED:  %U\n" ;; captured as property TIMESTAMP
                              ":END:\n"
                              ":LOGBOOK:\n"
                              ":END:\n"
                              "%?")))
      (add-to-list 'org-capture-templates
                   `("tt" "Task, General scheduled TODO entry." entry
                     (file ,my-todo-org-file)
                     ,(concat "* TODO [%] %^{DESCRIPTION} %^g \n"
                              "SCHEDULED: %(org-insert-time-stamp (org-read-date nil t))\n"
                              ":PROPERTIES:\n"
                              ":CREATED:  %U\n" ;; captured as property TIMESTAMP
                              ":END:\n"
                              ":LOGBOOK:\n"
                              ":END:\n"
                              ;; "%(with-temp-buffer (insert-file-contents (f-join user-emacs-directory \"templates\" \"todo-guide.org\")) (buffer-string))\n"
                              "%?")))))
  ;; when inserting a heading immediately go into insert mode
  ;; (when (boundp 'my-journal-org-file)
  ;;   (add-to-list 'org-capture-templates
  ;;                `("j" "Journal Entry" entry
  ;;                  (file ,my-journal-org-file)
  ;;                  "* %U\n%?")
  ;; (when (boundp 'my-daydream-org-file)
  ;;   (add-to-list 'org-capture-templates
  ;;                `("d" "Daydream Entry" entry
  ;;                  (file ,my-daydream-org-file)
  ;;                  "* %? \n %U"))
#+end_src

*** Doct Org Capture Templates
#+begin_src emacs-lisp :results output silent
  (use-package doct
    :straight (:host github :repo "progfolio/doct")
    :commands (doct doct-add-to))
#+end_src

** Org Agenda
For some reason we can't do this in the scratch buffer
#+begin_src emacs-lisp :results output silent
  (use-package org-agenda
    :ensure nil
    :straight nil
    :commands (org-todo-list
               org-agenda-list
               org-agenda-file-to-front
               org-agenda)
    :general
    (:states 'motion
     "|" 'org-agenda-list)
    (:keymaps 'org-agenda-keymap
     :states '(normal motion)
     "g t" nil
     "g T" nil
     ;; Seems to be an unhandled case by evil-org
     "RET" 'org-agenda-switch-to
     [remap evil-write] 'org-save-all-org-buffers)
    :init
    (evil-ex-define-cmd "ag[enda]" 'org-agenda)
    (evil-ex-define-cmd "things" 'org-agenda)
    :custom
    (org-agenda-span 'month)
    (org-agenda-window-setup 'current-window)
    (org-agenda-skip-unavailable-files t)
    (org-agenda-time-leading-zero t)
    (org-agenda-prefix-format '((agenda . " %i %-12:c%?-12t%s %?b")
                                (todo . " %i %-12:c")
                                (tags . " %i %-12:c")
                                (search . " %i %-12:c")))
    (org-agenda-breadcrumbs-separator "/")
    :custom-face
    (org-agenda-done ((t (:inherit org-agenda-done :strike-through t))))
    :hook
    (org-agenda-after-show-hook . org-narrow-to-subtree)
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    (with-eval-after-load 'tab-bar
      (general-define-key
       :keymap org-agenda-mode-map
       :states '(motion)
       "g t" 'tab-bar-switch-to-next-tab
       "g T" 'tab-bar-switch-to-prev-tab))
    ;; This is exactly like the original `org-agenda-add'
    ;; except that we call `my-counsel-org-capture' instead
    ;; The timestamp feature is currently unused, though that might
    ;; change in the future
    (advice-add 'org-agenda-capture :override
                #'(lambda (&optional with-time)
                    (interactive "P")
                    (let ((org-overriding-default-time)
                          (org-get-cursor-date (equal with-time 1)))
                      (call-interactively 'my-counsel-org-capture))))
    (advice-add 'org-agenda-clock-in :after 'org-agenda-goto)
    (when (and (boundp 'config-local-syncthing-folder)
               (f-exists-p my-notes-folder))
      (require 'dash) ;; -concat
      (customize-set-variable
       'org-agenda-files
       (-concat org-agenda-files
                `(,my-text-raw-folder
                  ,my-todo-org-file
                  ,(f-join config-local-syncthing-folder "mobile.org")))))
    ;; (-concat org-agenda-files
    ;;          (directory-files-recursively
    ;;           (f-join my-notes-folder "raw")
    ;;           "\.org$"))))
    (my-evil-define-split-vsplit-cmd "agenda" #'org-agenda)
    (my-evil-define-split-vsplit-cmd "aa" #'org-agenda)
    (evil-ex-define-cmd "Tag[enda]"
                        #'(lambda () (interactive)
                            ;; TODO: unify this implementation with my-new-cmd-tab
                            (if (>= emacs-major-version 27)
                                (tab-bar-new-tab)
                              (require 'eyebrowse)
                              (my-new-evil-tab nil))
                            (funcall-interactively #'org-agenda-list))))
#+end_src

*** Super agenda
#+begin_src emacs-lisp :results output silent
  (use-package org-super-agenda
    :straight t
    :commands org-super-agenda-mode
    :hook (org-agenda-mode-hook . org-super-agenda-mode)
    :general
    (org-super-agenda-mode-map
     "g t" nil
     "g T" nil)
    :custom
    (org-super-agenda-groups
     '((:name "Ongoing Work. Try to keep this set small."
        :todo "ONGOING")
       (:name "Blocked Work. Try not to stall too long."
        :todo "BLOCKED")
       (:name "Office Work"
        :tag "work")
       (:name "School Work"
        :tag "school")
       (:name "Personal Work"
        :tag "personal"
        :and (:not (:habit t)))
       (:name "Habits"
        :habit t)))
    ;; (:name "Unscheduled Work"
    ;;  :not (:scheduled t))))
    :config
    ;; don't let org-super-agenda override evil bindings
    ;; https://github.com/codygman/doom-emacs-literate-config/commit/bcd6ee115db58d12a05ff4aa9ba60f96d87b81ba
    (setq org-super-agenda-header-map (make-sparse-keymap)))
#+end_src

** Org Src
Don't bind to C-c C-c because it might impact the src block's
language's mappings.

#+begin_src emacs-lisp :results output silent
  (use-package org-src
    :ensure nil
    :straight nil
    :init
    (defun my-evil-org-src-save-exit ()
      (interactive)
      (org-edit-src-save)
      (org-edit-src-exit))
    :general
    (org-src-mode-map
     [remap evil-write] 'org-edit-src-save
     ;; doesn't seem to be working, the saving part at least
     [remap evil-save-and-close] #'my-evil-org-src-save-exit
     ;; doesn't seem to be working, the saving part at least
     [remap evil-save-modified-and-close] #'my-evil-org-src-save-exit
     [remap evil-quit] 'org-edit-src-abort))
#+end_src

** Org Download
#+begin_src emacs-lisp :results output silent
  (use-package org-download
    :disabled t
    :straight (:host github :repo "abo-abo/org-download")
    :hook ((dired-mode-hook . org-download-enable)
           (org-mode-hook . org-download-enable)))
#+end_src

** Worf
[[http://pragmaticemacs.com/emacs/insert-internal-org-mode-links-the-ivy-way/][Source]].
#+begin_src emacs-lisp :results output silent
  (use-package worf
    :straight (:host github :repo "abo-abo/worf")
    :disabled t
    :commands worf--goto-candidates
    :general
    (:keymaps 'org-mode-map
     :states '(normal visual)
     :prefix my-default-evil-leader-key
     "o l" 'my-worf-insert-internal-link
     "l l" 'org-toggle-link-display)
    :init
    (defun my--worf-insert-internal-link-action (x)
      (let ((link (save-excursion
                    (goto-char (cdr x))
                    (call-interactively 'org-store-link))))
        (funcall-interactively 'org-insert-link nil (car link))))
    ;; (call-interactively 'org-insert-link))
    ;; (org-insert-last-stored-link 1)
    ;; ;; otherwise deletes the whole visual selection. Including the
    ;; ;; inserted link.
    ;; (when (use-region-p)
    ;;   (deactivate-mark))
    ;; (delete-backward-char 1))
    (defun my-worf-insert-internal-link ()
      (interactive)
      ;; TODO: Why isn't this working?
      (let ((cands (worf--goto-candidates)))
        (ivy-read "Heading: " cands
                  :action 'my--worf-insert-internal-link-action))))
#+end_src

** Org wiki
Currently disabled while we look at other, more maintained projects
#+begin_src emacs-lisp :results output silent
  (use-package org-wiki
    :straight (:host github :repo "caiorss/org-wiki")
    :disabled t
    :commands (org-wiki-index
               org-wiki-help))
#+end_src

** Org brain
#+Begin_src emacs-lisp :results output silent
  (use-package org-brain
    :straight (:host github :repo "Kungsgeten/org-brain")
    :disabled t
    :if (boundp 'config-local-syncthing-folder)
    :commands (org-brain-visualize
               counsel-brain
               org-brain-switch-brain)
    :custom
    (org-brain-path (f-join config-local-syncthing-folder "wiki"))
    ;; (org-brain-show-resources
    ;;  nil
    ;;  "https://github.com/Kungsgeten/org-brain/pull/203 I don't really
    ;;  use attachments either way so this does not affect me")
    ;; because we don't enter visualize-mode in normal state
    :hook ((org-brain-visualize-text-hook . evil-ex-nohighlight))
    :general
    (org-brain-visualize-mode-map
     "SPC"        nil
     "S-SPC"      nil
     "\C-w"      'evil-window-map
     ":"         'evil-ex
     "/"         'evil-ex-search-forward
     "?"         'evil-ex-search-backward
     "h"         'org-brain-add-child-headline ;; it's recommended to use this instead
     "\C-c \C-w" 'org-brain-refile
     "C-d"       'evil-scroll-down
     "C-u"       'evil-scroll-up)
    :init
    (with-eval-after-load 'evil
      (evil-set-initial-state 'org-brain-visualize-mode 'emacs)
      (evil-define-command my-org-brain-config (args)
        (interactive "<a>")
        (cond
         ;;TODO: implement additional ex command line things
         (t (call-interactively 'org-brain-visualize))))
      (evil-ex-define-cmd "wiki" 'my-org-brain-config))
    :config
    ;; NOTE: We do this because when running on different machine we
    ;; will need to update the IDs of entries.
    (org-brain-update-id-locations))
  ;; (hercules-def :toggle-funs #'org-brain-visualize
  ;;               :hide-funs #'org-brain-visualize-quit
  ;;               :keymap 'org-brain-visualize-mode-map
  ;;               :transient t))
#+end_src

*** Usage
| Key        | Command                              | Description                                                                       |
|------------+--------------------------------------+-----------------------------------------------------------------------------------|
| m          | =org-brain-visualize-mind-map=       | Toggle between normal and mind-map visualization.                                 |
| j or TAB   | =forward-button=                     | Goto next link                                                                    |
| k or S-TAB | =backward-button=                    | Goto previous link                                                                |
| b          | =org-brain-visualize-back=           | Like the back button in a web browser.                                            |
| h or *     | =org-brain-add-child-headline=       | Add a new child /headline/ to entry                                               |
| c          | =org-brain-add-child=                | Add an existing entry, or a new /file/, as a child                                |
| C          | =org-brain-remove-child=             | Remove one the entry's child relations                                            |
| e          | =org-brain-annotate-edge=            | Annotate the connection between the visualized entry and the entry link at point. |
| p          | =org-brain-add-parent=               | Add an existing entry, or a new /file/, as a parent                               |
| P          | =org-brain-remove-parent=            | Remove one of the entry's parent relations                                        |
| f          | =org-brain-add-friendship=           | Add an existing entry, or a new /file/, as a friend                               |
| F          | =org-brain-remove-friendship=        | Remove one of the entry's friend relations                                        |
| n          | =org-brain-pin=                      | Toggle if the entry is pinned or not                                              |
| s          | =org-brain-select-dwim=              | Select an entry for batch processing.                                             |
| S          | =org-brain-select-map=               | Prefix key to do batch processing with selected entries.                          |
| t          | =org-brain-set-title=                | Change the title of the entry.                                                    |
| T          | =org-brain-set-tags=                 | Change the tags of the entry.                                                     |
| d          | =org-brain-delete-entry=             | Choose an entry to delete.                                                        |
| l          | =org-brain-visualize-add-resource=   | Add a new resource link in entry                                                  |
| r          | =org-brain-open-resource=            | Choose and open a resource from the entry.                                        |
| C-y        | =org-brain-visualize-paste-resource= | Add a new resource link from clipboard                                            |
| a          | =org-brain-visualize-attach=         | Run =org-attach= on entry (headline entries only)                                 |
| A          | =org-brain-archive=                  | Archive the entry (headline entries only)                                         |
| o          | =org-brain-goto-current=             | Open current entry for editing                                                    |
| O          | =org-brain-goto=                     | Choose and edit one of your =org-brain= entries                                   |
| v          | =org-brain-visualize=                | Choose and visualize a different entry                                            |
| w          | =org-brain-visualize-random=         | Visualize one of your entries at random.                                          |
| W          | =org-brain-visualize-wander=         | Visualize at random, in a set interval. =W= again to cancel.                      |

** Org bullets
#+begin_src emacs-lisp :results output silent
  (use-package org-bullets
    :straight (:host github :repo "emacsorphanage/org-bullets")
    :disabled t ;; feels slower, might be expensive
    :hook (org-mode-hook . org-bullets-mode))
#+end_src

** Export as epub
Needs a working =zip= exe.

#+begin_src emacs-lisp :results output silent
  (use-package ox-epub
    :straight (:host github :repo "ofosos/ox-epub")
    :commands org-epub-export-to-epub)
#+end_src

** Screenshot from system clipboard
[[http://www.sastibe.de/2018/11/take-screenshots-straight-into-org-files-in-emacs-on-win10/][Source]], modified to allow the user to select a directory.

#+begin_src emacs-lisp :results output silent
  (defun my-org-paste-clipboard-screenshot (&optional dir)
    "Take a screenshot into a time stamped unique-named file in the
       same directory as the org-buffer and insert a link to this file."
    (interactive (list (read-directory-name "" "" "images")))
    (unless (equal system-type 'windows-nt)
      (user-error "Implementation currently only works on windows, this is %s"
                  system-type))
    (let ((filename (concat
                     (make-temp-name
                      (concat (file-name-as-directory dir)
                              (-> (buffer-file-name)
                                file-name-nondirectory
                                file-name-sans-extension)
                              "_"
                              (format-time-string "%Y-%m-%dT%H%M%S")))
                     ".png")))
      (unless (file-directory-p dir)
        (make-directory dir))
      (shell-command (concat "powershell -command \"Add-Type -AssemblyName System.Windows.Forms;if ($([System.Windows.Forms.Clipboard]::ContainsImage())) {$image = [System.Windows.Forms.Clipboard]::GetImage();[System.Drawing.Bitmap]$image.Save('"
                             filename
                             "',[System.Drawing.Imaging.ImageFormat]::Png); Write-Output 'clipboard content saved as file'} else {Write-Output 'clipboard does not contain image data'}\""))
      (insert (concat "[[file:" (file-relative-name filename) "]]"))
      (message "Image saved as %s" filename)
      (org-display-inline-images)
      filename))
#+end_src

#+begin_src emacs-lisp :results output
  (general-define-key
   :keymaps 'org-mode-map
   :states '(normal)
   :prefix my-default-evil-leader-key
   "o p" 'my-org-paste-clipboard-screenshot)
#+end_src

** Org Edna
https://www.nongnu.org/org-edna-el/
#+begin_src emacs-lisp :results output silent
  (use-package org-edna
    :straight (org-edna)
    :disabled t ;; re-enable once I'm better at org
    :after org
    :config
    (org-edna-load))
#+end_src


** Org Om
#+begin_src emacs-lisp :results output silent
  (use-package om
    :disabled t
    :straight (:host github :repo "ndwarshuis/om.el"))
#+end_src

** COMMENT Org Roam
Requires =sqlite=. Install using =choco install sqlite=

- [ ] Add the files inside the roam directory as org agenda files?
  It's going to be heavyweight.

#+begin_src emacs-lisp :results output silent
  (use-package org-roam
    ;; :hook (org-mode-hook . org-roam-mode)
    ;; :straight (:host github :repo "org-roam/org-roam")
    ;; :if (boundp 'my-notes-folder)
    :disabled t
    :straight t
    :commands
    (org-roam-jump-to-index
     org-roam-dailies-yesterday
     org-roam-dailies-today
     org-roam-find-file
     org-roam-dailies-today
     org-roam-dailies-tomorrow)
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "n n"   #'org-roam-find-file
     "n c"   #'org-roam-capture
     "n i"   #'org-roam-insert
     "n t"   #'org-roam-tag-add
     "n a"   #'org-roam-alias-add
     "n b"   #'org-roam-buffer-toggle-display
     "n j d" #'org-roam-dailies-capture-date
     "n j j" #'org-roam-dailies-capture-today
     "n j n" #'org-roam-dailies-capture-tomorrow
     "n j p" #'org-roam-dailies-capture-yesterday)
    :custom
    (org-roam-buffer-width 0.3)
    (org-roam-db-update-method (if (eq system-type 'windows-nt)
                                   'immediate
                                 'idle-timer))
    ;; (org-roam-directory my-notes-folder)
    ;; (org-roam-directory my-notes-folder)
    ;; (org-roam-index-file (f-join org-roam-directory "index.org"))
    (org-roam-dailies-directory "day/")
    ;; :hook
    ;; (after-init-hook . org-roam-mode)
    :init
    (evil-ex-define-cmd "wiki"      #'org-roam-jump-to-index)
    (evil-ex-define-cmd "index"     #'org-roam-jump-to-index)
    (evil-ex-define-cmd "nn"        #'org-roam-find-file)
    (evil-ex-define-cmd "yesterday" #'org-roam-dailies-yesterday)
    (evil-ex-define-cmd "ytd"       #'org-roam-dailies-yesterday)
    (evil-ex-define-cmd "jp"        #'org-roam-dailies-yesterday)
    (evil-ex-define-cmd "to[day]"   #'org-roam-dailies-today)
    (evil-ex-define-cmd "jj"        #'org-roam-dailies-today)
    (evil-ex-define-cmd "tomorrow"  #'org-roam-dailies-tomorrow)
    (evil-ex-define-cmd "tmr"       #'org-roam-dailies-tomorrow)
    (evil-ex-define-cmd "jn"        #'org-roam-dailies-tomorrow)
    :config
    (when (boundp 'config-local-syncthing-folder)
      (customize-set-variable 'org-roam-directory my-notes-folder))
    (with-eval-after-load 'aggressive-fill-paragraph
      (add-hook 'org-roam-capture-after-find-file-hook 'aggressive-fill-paragraph-mode))
    ;; (defun org-roam--extract-tags-regex (filepath)
    ;;   (with-temp-buffer
    ;;     (insert-file-contents filepath)
    ;;     (save-match-data
    ;;       (let* ((string (buffer-string))
    ;;              (pos 0)
    ;;              matches)
    ;;         (while (string-match "#[[:alnum:]\:-]+" string pos)
    ;;           (push (string-remove-prefix "#" (match-string 0 string)) matches)
    ;;           (setq pos (match-end 0)))
    ;;         matches))))
    ;; (customize-set-variable 'org-roam-tag-sources
    ;;                         (add-to-list 'org-roam-tag-sources 'regex))
    ;; Note that org-roam captures are incompatible with org-captures
    ;; Note documentation on `org-roam-capture-templates'
    (let* ((template (list '("rr" "default" plain
                             #'org-roam-capture--get-point "%?"
                             :file-name "%<%s>-${slug}"
                             :head "#+TITLE: ${title}\n"
                             :unnarrowed t)))
           (template-immediate (list '("rn" "immediate" plain
                                       #'org-roam-capture--get-point "%?"
                                       :file-name "%<%s>-${slug}"
                                       :head "#+TITLE: ${title}\n"
                                       :unnarrowed t
                                       :immediate-finish t)))
           (template-dailies (list `("d" "default diary" entry (function org-roam-capture--get-point)
                                     "* %?"
                                     :file-name ,(f-join org-roam-dailies-directory "%<%Y-%m-%d>")
                                     :head "#+title: %<%Y-%m-%d>\n"))))
      (customize-set-value 'org-roam-capture-templates template)
      (customize-set-value 'org-roam-capture-immediate-template template-immediate)
      (customize-set-value 'org-roam-dailies-capture-templates template-dailies))
    (advice-add 'org-roam--title-to-slug :filter-return
                (lambda (str) (replace-regexp-in-string "_" "-" str)))
    (org-roam-mode))
#+end_src

** Org Roam v2
TODO: a function to go to the index file.

#+begin_src emacs-lisp :results output silent
  (use-package org-roam
    :straight (:host github :repo "org-roam/org-roam" :branch "v2")
    :custom
    (org-roam-dailies-directory "day/")
    :demand t ;; needs org-roam-setup, which complicates things.
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "n n"   #'org-roam-node-find
     "n c"   #'org-roam-capture
     "n i"   #'org-roam-node-insert
     "n g"   #'org-id-get-create
     "n t"   #'org-roam-tag-add
     "n T"   #'org-roam-tag-remove
     "n b"   #'org-roam-buffer-toggle
     "n j d" #'org-roam-dailies-capture-date
     "n j j" #'org-roam-dailies-capture-today
     "n j n" #'org-roam-dailies-capture-tomorrow
     "n j p" #'org-roam-dailies-capture-yesterday)
    :init
    (defun my-org-roam-find-index-file ()
      (interactive)
      (find-file (f-join org-roam-directory "index.org")))
    (evil-ex-define-cmd "index"     #'my-org-roam-find-index-file)
    (evil-ex-define-cmd "nn"        #'org-roam-node-find)
    (evil-ex-define-cmd "yesterday" #'org-roam-dailies-find-yesterday)
    (evil-ex-define-cmd "ytd"       #'org-roam-dailies-find-yesterday)
    (evil-ex-define-cmd "jp"        #'org-roam-dailies-find-yesterday)
    (evil-ex-define-cmd "to[day]"   #'org-roam-dailies-find-today)
    (evil-ex-define-cmd "jj"        #'org-roam-dailies-find-today)
    (evil-ex-define-cmd "tomorrow"  #'org-roam-dailies-find-tomorrow)
    (evil-ex-define-cmd "tmr"       #'org-roam-dailies-find-tomorrow)
    (evil-ex-define-cmd "jn"        #'org-roam-dailies-find-tomorrow)
    :config
    ;; olp means outline path
    ;; Got to accept that we probably shouldn't assume that all new
    ;; headers are nodes. Probably better to just give a keybind for
    ;; that
    (let* ((template (list '("d" "default" entry "* %?"
                             :if-new
                             (file+head "%<%s>-${slug}.org"
                                        "#+title: ${title}\n")
                             :unnarrowed t)))
           (template-dailies (list `("d" "default" entry "* %?"
                                     :if-new
                                     (file+head ,(f-join org-roam-dailies-directory
                                                         "%<%Y-%m-%d>.org")
                                                "#+title: %<%Y-%m-%d>\n")))))
      (customize-set-value 'org-roam-capture-templates template)
      (customize-set-value 'org-roam-dailies-capture-templates template-dailies))
    (advice-add 'org-roam-node-slug :filter-return
                (lambda (str) (replace-regexp-in-string "_" "-" str)))
    (org-roam-teardown)
    (org-roam-setup))
#+end_src

*** Nroam
org roam mode hook only activates once, not per roam file as we wanted.

#+begin_src emacs-lisp :results output silent
  (use-package nroam
    :disabled t
    :straight (:host github :repo "nicolaspetton/nroam")
    :after org-roam
    :general
    (:states 'normal
      :prefix my-default-evil-leader-key
      "n r" #'my-toggle-nroam-mode-maybe)
    :commands nroam-mode
    ;; this interferes with org-roam-capture of all kinds
    ;; :hook (org-mode-hook . my-enable-nroam-mode-maybe)
    :init
    (defun my-in-org-roam-dir-p ()
      (interactive)
      (let ((path (buffer-file-name (current-buffer))))
        (and path (f-ancestor-of? org-roam-directory path))))
    (defun my-toggle-nroam-mode-maybe ()
      "Enables nroam only if it is found to be inside an org-roam directory"
      (interactive)
      (require 'nroam)
      (if nroam-mode
          (nroam-mode -1)
        (when (my-in-org-roam-dir-p)
            (nroam-mode)))))
#+end_src

** Org Latex Fragment Toggle
#+begin_src emacs-lisp :results output silent
  (use-package org-fragtog
    :straight (:host github :repo "io12/org-fragtog")
    :hook (org-mode-hook . org-fragtog-mode))
#+end_src

** Org Habit
In emacs 28 there's an issue with it not updated to using 3 arguments
for =define-obsolete-function-alias= (really dumb thing, but there it
is)

#+begin_src emacs-lisp :results output silent
  (use-package org-habit
    :disabled t
    :straight nil
    :ensure nil
    :after org
    :custom
    (org-habit-graph-column 70))
#+end_src

** Org Clock
#+begin_src emacs-lisp :results output silent
  (use-package org-clock
    :straight nil
    :ensure nil
    :custom
    (org-clock-clocked-in-display 'both)
    (org-clock-persist 'history)
    (org-clock-mode-line-total 'current)
    (org-clock-out-remove-zero-time-clocks t)
    (org-clock-history-length 35)
    :general
    (:states '(normal)
     :prefix my-default-evil-leader-key
     "c c" 'my-org-clocking
     "c f" 'my-org-goto-clock)
    :init
    (defun my-org-goto-clock ()
      (interactive)
      (require 'org-clock)
      (org-clock-goto (not (org-clocking-p))))
    (evil-define-command my-org-clocking (&optional bang)
      "Note that adding a ! means you mark the current task as the
    default."
      (interactive "<!>")
      (require 'org-clock)
      (cond
       ((org-clocking-p) (org-clock-out))
       ((and (eq major-mode 'org-mode) (org-at-heading-p))
        (org-clock-in))
       ((string-equal (buffer-name) "*Org Agenda*")
        (org-agenda-clock-in))
       (t (org-clock-in '(4))))
      (when (or bang (not (marker-position org-clock-default-task)))
        (org-clock-mark-default-task)))
    (evil-ex-define-cmd "clock" #'my-org-clocking)
    (evil-ex-define-cmd "clocking" #'my-org-goto-clock)
    :config
    (org-clock-persistence-insinuate)
    (org-clock-load))

  ;; :config
  ;; (defun my-org-clock-get-clock-string ()
  ;;   "Form a clock-string, that will be shown in the mode line.
  ;; If an effort estimate was defined for the current item, use
  ;; 01:30/01:50 format (clocked/estimated).
  ;; If not, show simply the clocked time like 01:50.

  ;; We modify this such that if the customization
  ;; `org-clock-mode-line-total' is `current', the effort estimate gets
  ;; \"eaten\" by the total clocked time (so subsequent clock-in's will
                                          ; see the effort reduce)."
  ;;   (let ((clocked-time (org-clock-get-clocked-time)))
  ;;     (if org-clock-effort
  ;;         (let* ((effort-in-minutes
  ;;                 (if (eq org-clock-mode-line-total 'current)
  ;;                     (-> (org-duration-to-minutes org-clock-effort)
  ;;                         (- clocked-time))
  ;;                   (org-duration-to-minutes org-clock-effort)))
  ;;                (work-done-str
  ;;                 (propertize (org-duration-from-minutes clocked-time)
  ;;                             'face
  ;;                             (if (and org-clock-task-overrun
  ;;                                      (not org-clock-task-overrun-text))
  ;;                                 'org-mode-line-clock-overrun
  ;;                               'org-mode-line-clock)))
  ;;                (effort-str (org-duration-from-minutes
  ;;                             effort-in-minutes)))
  ;;           (format (propertize " [%s/%s] (%s)" 'face 'org-mode-line-clock)
  ;;                   work-done-str effort-str org-clock-heading))
  ;;       (format (propertize " [%s] (%s)" 'face 'org-mode-line-clock)
  ;;               (org-duration-from-minutes clocked-time)
  ;;               org-clock-heading))))
  ;; (advice-add 'org-clock-get-clock-string
  ;;             :override 'my-org-clock-get-clock-string))
#+end_src

** Org Appear
#+begin_src emacs-lisp :results output silent
  (use-package org-appear
    :straight (:host github :repo "awth13/org-appear")
    :commands (org-appear-mode)
    :hook (org-mode-hook . org-appear-mode))
#+end_src

* hl-todo
#+begin_src emacs-lisp :results output silent
  (use-package hl-todo
    :diminish t
    :straight (:host github :repo "tarsius/hl-todo")
    :commands (hl-todo-mode)
    :hook ((prog-mode-hook  . hl-todo-mode)
           (yaml-mode-hook  . hl-todo-mode))
    :custom
    (hl-todo-keyword-faces '(("TODO"    . "#b58900")
                             ("DEBUG"   . "#d33682")
                             ("NOTE"    . "#586e75")
                             ("FIXME"   . "#cb4b16")))
    :general
    ;; (:states 'normal
    ;;  :prefix my-default-evil-leader-key
    ;;  "t t" 'my-helm-swoop-hl-todo)
    (:keymaps 'evil-normal-state-map
     "[ h"  'hl-todo-previous
     "] h"  'hl-todo-next))
  ;; :init
  ;;TODO: Make this search for regexes
  ;; (defun my-helm-swoop-hl-todo () (interactive)
  ;;        (require 'helm-swoop)
  ;;        (helm-swoop :$query hl-todo-regexp :$multiline 4)))
  ;; Stolen from https://github.com/emacs-helm/helm/wiki/Developing. Convenient!
  ;; Not used because we don't incrementally search for todos
  ;; (defun my-helm-hl-todo-items ()
  ;;   "Show `hl-todo'-keyword items in buffer."
  ;;   (interactive)
  ;;   (hl-todo--setup)
  ;;   (helm :sources (helm-build-in-buffer-source "hl-todo items"
  ;;                    :data (current-buffer)
  ;;                    :candidate-transformer (lambda (candidates)
  ;;                                             (cl-loop for c in candidates
  ;;                                                      when (string-match hl-todo--regexp c)
  ;;                                                      collect c))
  ;;                    :get-line #'buffer-substring)
  ;;         :buffer "*helm hl-todo*"))
#+end_src

* Edit-Indirect
#+begin_src emacs-lisp :results output silent
  (use-package edit-indirect
    :straight t)
#+end_src

* Markdown                                                            :major:
#+begin_src emacs-lisp :results output silent
  (use-package markdown-mode
    :straight (:host github :repo "jrblevin/markdown-mode")
    :mode ("\\.md\\'" . markdown-mode)
    :commands (markdown-mode)
    :init
    (with-eval-after-load 'org-table
      (defun orgtbl-to-gfm (table params)
        "Convert the Orgtbl mode TABLE to GitHub Flavored Markdown."
        (let* ((alignment (mapconcat (lambda (x) (if x "|--:" "|---")))
                          org-table-last-alignment ""))
          (params2
           (list)
           :splice t
           :hline (concat alignment "|")
           :lstart "| " :lend " |" :sep " | ")
          (orgtbl-to-generic table (org-combine-plists params2 params)))))
    (with-eval-after-load 'org-src
      (cl-pushnew '("md" . gfm) org-src-lang-modes)))
#+end_src

** Evil-markdown
#+begin_src emacs-lisp :results output silent
  (use-package evil-markdown
    :after (:and evil markdown-mode)
    :straight (:host github :repo "Somelauw/evil-markdown")
    :commands (evil-markdown-mode)
    :hook (markdown-mode-hook . evil-markdown-mode))
#+end_src

* Git
** Magit
If magit complains about not finding the config on windows, it's
because of [[https://github.com/magit/magit/issues/1497][this issue]], the easiest solution is to make a link

: mklink %APPDATA%\.gitconfig %USERPROFILE%\.gitconfig

- [ ] Make a command that commits and pushes
- [ ] Make it so I don't have to do !git all the time.


#+begin_src emacs-lisp :results output silent
  (use-package magit
    :straight t
    :commands (magit-status
               magit-pull
               magit-commit)
    :defer 15
    :custom
    (magit-blame-echo-style 'margin)
    :general
    (general-define-key
      :keymaps 'project-prefix-map
      "v" 'magit-status)
    (magit-mode-map
     :states '(normal)
     "g x" 'magit-browse-thing)
    :init
    (evil-define-command ex-magit-cli (cmd)
      "Calls specific magit functions"
      (interactive "<a>")
      (cond
       ((eq cmd nil) (magit-status))
       (t (magit-shell-command (concat "git " cmd)))))
    (evil-ex-define-cmd "git" 'ex-magit-cli)
    (evil-ex-define-cmd "gg" 'ex-magit-cli)
    (evil-ex-define-cmd "gb" 'magit-branch)
    (evil-ex-define-cmd "gB" 'magit-blame)
    (evil-ex-define-cmd "gc" 'magit-commit)
    (evil-ex-define-cmd "gf" 'magit-fetch)
    (evil-ex-define-cmd "gp" 'magit-push)
    (evil-ex-define-cmd "gF" 'magit-pull)
    (evil-ex-define-cmd "gl" 'magit-log)
    (evil-ex-define-cmd "gL" 'magit-log-buffer-file)
    :hook ((git-commit-setup-hook . aggressive-fill-paragraph-mode)
           (git-commit-setup-hook . markdown-mode)
           (git-commit-setup-hook . evil-markdown-mode)
           (git-commit-setup-hook . (lambda () (display-fill-column-indicator-mode 1)))))
  ;; TODO: figure out a way to have git submodule update all modules
  ;; without using a universal prefix
  ;; :config
  ;; (transient-append-suffix 'magit-submodule "U" '("w" "Wip" magit-wip-log-current)))
#+end_src

*** Evil bindings

2021-01-06 Now it's part of evil-collections

[2019-02-18 Mon 12:49] Magit changed from magit-popup to transient,
and that breaks this addon
https://github.com/syl20bnr/spacemacs/issues/11978

Current fix ([2019-02-18 Mon 13:06]) is to pin magit to an earlier
config. This configuration is stored in =straight/versions/default.el=

#+begin_src emacs-lisp :results output silent
  (use-package evil-magit
    :disabled t ;; merged into evil-collections
    :straight (:host github
               :repo "emacs-evil/evil-magit")
    :after (magit)
    :config
    (evil-magit-init))
#+end_src

*** Magit Todo
Currently disabled because we can't get it to work (it's not showing
up, on windows at least).
#+begin_src emacs-lisp :results output silent
  (use-package magit-todos
    :straight (:host github :repo "alphapapa/magit-todos")
    :custom
    (magit-todos-nice
     (not (eq system-type 'windows-nt))
     "`nice' does not exist on windows")
    :general
    (:keymaps
     '(magit-todos-section-map magit-todos-item-section-map)
     "jT" nil
     "jl" nil
     "j" nil)
    :commands
    (magit-todos-list ivy-magit-todos)
    :init
    (with-eval-after-load 'ivy
      (evil-ex-define-cmd "gtodo" 'magit-todos-list)
      ;; (general-with-eval-after-load 'counsel
      (general-define-key
        :keymaps 'project-prefix-map
        "t" 'ivy-magit-todos))
    :hook
    (magit-status-mode-hook . magit-todos-mode))
#+end_src

*** Magit github
#+begin_src emacs-lisp :results output silent
  (use-package forge
    :straight t
    :after magit)
#+end_src

** Git-link
#+begin_src emacs-lisp :results output silent
  (use-package git-link
    :straight t
    :commands (git-link
               git-link-commit
               git-link-homepage)
    :custom
    (git-link-open-in-browser t)
    :init
    (evil-ex-define-cmd "repo" 'git-link-homepage))
#+end_src

** Browse-at-remote
#+begin_src emacs-lisp :results output silent
  (use-package browse-at-remote
    :straight t
    :commands (browse-at-remote))
#+end_src

** Git Gutter
#+begin_src emacs-lisp :results output silent
  (use-package git-gutter+
    ;; :straight (:host github :repo "nonsequitur/git-gutter-plus")
    :straight t
    :after magit
    :general
    (:states  'normal
     :keymaps 'git-gutter+-mode-map
     "[ h"    'git-gutter+-previous-hunk
     "] h"    'git-gutter+-next-hunk
     "g h s"  'git-gutter+-stage-hunks
     "g h u"  'git-gutter+-revert-hunks
     "g h h"  'git-gutter+-show-hunk-inline-at-point)
    :custom
    (git-gutter+-hide-gutter nil))
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package git-gutter-fringe+
      ;; :straight (:host github :repo "nonsequitur/git-gutter-fringe-plus")
      :straight t
      ;; :if (not (display-graphic-p))
      :after git-gutter+
      :config
      (fringe-helper-define 'git-gutter-fr+-added nil
                            "........"
                            "..XXXX.."
                            "..XXXX.."
                            "..XXXX.."
                            "..XXXX.."
                            "..XXXX.."
                            "..XXXX.."
                            "........")
      (fringe-helper-define 'git-gutter-fr+-deleted nil
                            "........"
                            "..XXXX.."
                            "..XXXX.."
                            "..XXXX.."
                            "..XXXX.."
                            "..XXXX.."
                            "..XXXX.."
                            "........"))
#+end_src

** TODO Git hunk textobjects

Look at ~git-gutter+-diffinfo-at-point~ and see if we can leverage
that for the range we want

** Git timemachine
Note that there are evil-collection bindings for this
#+begin_src emacs-lisp :results output silent
  (use-package git-timemachine
    :straight t
    :commands git-timemachine
    :general
    (git-timemachine-mode-map
     :states 'normal
     "M-k" 'git-timemachine-show-next-revision
     "M-j" 'git-timemachine-show-previous-revision)
    :init
    (evil-ex-define-cmd "gtime" #'git-timemachine))
#+end_src

** Git modes
#+begin_src emacs-lisp :results output silent
  (use-package gitconfig-mode
    :straight t)
#+end_src

* vdiff
#+begin_src emacs-lisp :results output silent
  (use-package vdiff
    :straight (:host github :repo "justbur/emacs-vdiff")
    :commands vdiff-hydra/body
    :init
    (evil-define-command ex-vdiff-cli (cmd)
      (interactive "<a>")
      (cond
       (t (vdiff-current-file))))
    (evil-ex-define-cmd "vdiff" 'ex-vdiff-cli))
#+end_src

** vdiff for magit
#+begin_src emacs-lisp :results output silent
  (use-package vdiff-magit
    :straight (:host github :repo "justbur/emacs-vdiff-magit")
    :after magit
    :disabled t
    :general
    (magit-mode-map
     "e" 'vdiff-magit-dwim
     "E" 'vdiff-magit)
    :init
    (with-eval-after-load 'magit
      (transient-suffix-put 'magit-dispatch "e" :description "vdiff (dwim)")
      (transient-suffix-put 'magit-dispatch "e" :command 'vdiff-magit-dwim)
      (transient-suffix-put 'magit-dispatch "E" :description "vdiff")
      (transient-suffix-put 'magit-dispatch "E" :command 'vdiff-magit)))
#+end_src

* Diff-hl
#+begin_src emacs-lisp :results output silent
  (use-package diff-hl
    :straight (:host github :repo "dgutov/diff-hl")
    :disabled t
    :defer 10
    :config
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
    (global-diff-hl-mode))
#+end_src

* Eyebrowse
- [ ] Use =counsel-bookmarked-directory--candidates= and implement
  =tabm= or something with bookmark completion.
- [ ] =:tabf= implementation


TODO: some way to better, more dynamically name the tabs

#+begin_src emacs-lisp :results output silent
  (use-package eyebrowse
    ;; emacs 27 provides a tab-bar-mode to basically do this
    :if (not (>= emacs-major-version 27))
    :straight (:host github :repo "wasamasa/eyebrowse")
    :commands (eyebrowse-switch-to-window-config
               eyebrowse-create-window-config
               eyebrowse-close-window-config
               eyebrowse-next-window-config
               eyebrowse-prev-window-config)
    :general
    (:states 'motion
     "gt" 'eyebrowse-next-window-config
     "gT" 'eyebrowse-prev-window-config)
    :custom
    (eyebrowse-wrap-around t)
    (eyebrowse-new-workspace t)
    (eyebrowse-keymap-prefix "")
    :init
    (evil-ex-define-cmd "gT" 'eyebrowse-prev-window-config)
    (evil-ex-define-cmd "gt" 'eyebrowse-next-window-config)
    (evil-define-command my-new-evil-tab (arg)
      "Note that :h :tabe in vim indicates that it's file only, not
  buffer.
  If the argument is a file, name the tab with the file. otherwise name
  the tab as the argument. If nothing is passed name the tab to the
  buffer."
      (interactive "<a>")
      (require 'eyebrowse)
      (let ((eyebrowse-new-workspace (if (and arg
                                              (file-exists-p arg))
                                         (lambda () (find-file arg))
                                       eyebrowse-new-workspace)))
        (eyebrowse-create-window-config))
      (my-rename-eyebrowse-tab (cond ((null arg) (buffer-name))
                                     ((file-exists-p arg)
                                      (file-name-nondirectory arg))
                                     (t arg))))
    (evil-ex-define-cmd "tabn[ew]"   'my-new-evil-tab)
    (evil-ex-define-cmd "tabe[dit]"  'my-new-evil-tab)
    (evil-ex-define-cmd "tabc[lose]" 'eyebrowse-close-window-config)
    (evil-ex-define-cmd "tabs"       'eyebrowse-switch-to-window-config)
    :config
    (evil-define-command my-rename-eyebrowse-tab (name)
      (interactive "<a>")
      (require 'eyebrowse)
      (eyebrowse-rename-window-config
       (frame-parameter nil 'eyebrowse-current-slot)
       name))
    (evil-ex-define-cmd "Trename"   'my-rename-eyebrowse-tab)
    (evil-ex-define-cmd "Tabrename" 'my-rename-eyebrowse-tab)
    (defun my-eyebrowse-delete-window-config-or-frame (oldfun &rest _old_args)
      "Checks if there are other \"tabs\" when closing a frame.
  If there is, close the tab, otherwise, delete the frame"
      (require 'eyebrowse)
      (interactive)
      (let* ((configs (frame-parameter nil 'eyebrowse-window-configs))
             (slots (mapcar 'car configs))
             (size (length slots)))
        (if (eq 1 size)
            (call-interactively oldfun)
          (eyebrowse-close-window-config))))
    (advice-add 'delete-frame :around 'my-eyebrowse-delete-window-config-or-frame)
    (eyebrowse-mode)
    ;; (eyebrowse-setup-evil-keys)
    (my-rename-eyebrowse-tab (buffer-name)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'eyebrowse
    (customize-set-variable
     'mode-line-format
     (list "%e" mode-line-front-space mode-line-mule-info
           mode-line-client mode-line-modified mode-line-auto-compile
           mode-line-remote mode-line-frame-identification
           mode-line-buffer-identification " " mode-line-position
           evil-mode-line-tag mode-line-misc-info '(vc-mode vc-mode) " "
           mode-line-modes mode-line-end-spaces)))
#+end_src

* Text
** Aggressive Fill Paragraph
#+begin_src emacs-lisp :results output silent
  (use-package aggressive-fill-paragraph
    :straight (:host github :repo "davidshepherd7/aggressive-fill-paragraph-mode")
    :commands (aggressive-fill-paragraph-mode)
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "g w" 'aggressive-fill-paragraph-mode)
    :hook (;; (org-mode-hook . aggressive-fill-paragraph-mode)
           (markdown-mode-hook . aggressive-fill-paragraph-mode)))
#+end_src

** Aggressive Indent
#+begin_src emacs-lisp :results output silent
  (use-package aggressive-indent
    :straight (:host github :repo "malabarba/aggressive-indent-mode")
    :commands (aggressive-indent-mode)
    :custom
    (aggressive-indent-comments-too t)
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "=" 'aggressive-indent-mode))
#+end_src

** Yasnippet
#+begin_src emacs-lisp :results output silent
  (use-package yasnippet
    :defer 20
    :straight (:host github :repo "joaotavora/yasnippet")
    :commands (yas-minor-mode
               yas-expand-snippet)
    :hook
    ((prog-mode-hook . yas-minor-mode)
     (org-mode-hook . yas-minor-mode))
    :general
    (yas-keymap
     "C-j" 'yas-next-field-or-maybe-expand
     "C-k" 'yas-prev-field)
    (:states '(normal visual)
     :prefix my-default-evil-leader-key
     "s s" 'yas-insert-snippet
     "s n" 'yas-new-snippet
     "s f" 'yas-visit-snippet-file)
    (snippet-mode-map
     [remap evil-save-and-close]          'yas-load-snippet-buffer-and-close
     [remap evil-save-modified-and-close] 'yas-load-snippet-buffer-and-close
     [remap evil-quit]                    'kill-this-buffer)
    :custom
    (yas-snippet-dirs (list (file-name-as-directory
                             (locate-user-emacs-file "snippets"))))
    (yas-indent-line 'auto)
    (yas-also-auto-indent-first-line t)
    :init
    (evil-define-command ex-snippet (cmd)
      (interactive "<a>")
      (require 'yasnippet)
      (cond
       ((string= cmd "reload") (yas-reload-all))
       ((string= cmd "edit") (yas-visit-snippet-file))
       ((string= cmd "new") (yas-new-snippet))
       (t (yas-insert-snippet))))
    (evil-ex-define-cmd "sn[ippets]" 'ex-snippet)
    :config
    (defun yas-with-comment (str)
      (format "%s%s%s" comment-start str comment-end))
    (yas-global-mode))
#+end_src

*** Auto-yasnippet
#+begin_src emacs-lisp :results output silent
  (use-package auto-yasnippet
    :straight (:host github :repo "abo-abo/auto-yasnippet")
    :commands (aya-create
               aya-expand)
    :custom
    (aya-case-fold t "smartcasing"))
#+end_src

* Projectile
try using the built-in =project= functions instead

#+begin_src emacs-lisp :results output silent
  (use-package projectile
    :disabled t
    :straight (:host github :repo "bbatsov/projectile")
    :commands (projectile-mode
               projectile-project-p
               projectile-ag)
    :defer 4
    :custom
    (projectile-tags-command
     "ctags -R -e -f \"%s\" %s \"%s\"")
    :config
    (defun projectile-regenerate-ctags ()
      "ctags does not take in directories as arguments. It does,
  however, look at the current directory"
      (interactive)
      (let* ((project-root (projectile-project-root))
             (tags-exclude (projectile-tags-exclude-patterns))
             (tags-file (expand-file-name projectile-tags-file-name))
             (command (format "ctags -R -e -f \"%s\" %s" tags-file tags-exclude))
             shell-output exit-code)
        (with-temp-buffer
          (let ((temp-dir default-directory))
            (cd project-root)
            (setq exit-code (call-process-shell-command command nil (current-buffer))
                  shell-output (string-trim
                                (buffer-substring (point-min) (point-max))))
            (cd temp-dir)))
        (unless (zerop exit-code)
          (error shell-output))
        (visit-tags-table tags-file)
        (message "Regenerated %s" tags-file)))
    (projectile-mode))
#+end_src

** Ivy/Counsel Projectile
#+begin_src emacs-lisp :results output silent
  (use-package counsel-projectile
    :disabled t
    :straight (:host github :repo "ericdanan/counsel-projectile")
    :disabled t ;; try project-file-search
    :commands (council-projectile-ag)
    :general
    (:states '(normal motion)
     "+" 'counsel-projectile
     "M-+" 'counsel-projectile-rg)
    :init
    (evil-ex-define-cmd "pp" 'counsel-projectile))
#+end_src

#+begin_src emacs-lisp :results output silent
  (general-define-key
   :states '(normal motion)
   "+" 'project-find-file)
#+end_src

** Org-Projectile
#+begin_src emacs-lisp :results output silent
  (use-package org-projectile
    :disabled t ;; we don't use this
    :straight (:host github :repo "IvanMalison/org-projectile")
    :commands (org-projectile-project-todo-entry
               org-projectile-get-project-todo-file)
    :init
    (with-eval-after-load 'org-capture
      (add-to-list 'org-capture-templates (org-projectile-project-todo-entry))) ;; here
    (evil-ex-define-cmd "ptodo" #'(lambda () (interactive)
                                    (require 'projectile)
                                    (require 'org-projectile)
                                    (find-file (org-projectile-get-project-todo-file
                                                (projectile-project-root)))))
    :config
    (org-projectile-per-project)
    (customize-set-variable 'org-projectile-per-project-filepath "TODO")
    (customize-set-variable 'org-agenda-files (append org-agenda-files (org-projectile-todo-files))))
#+end_src

** COMMENT Projectile Convenience Bindings
#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "proot" #'(lambda () (interactive)
                                  (require 'projectile)
                                  (dired (projectile-project-root))))
#+end_src

* Lisp
** Parinfer
#+begin_src emacs-lisp :results output silent
  (use-package parinfer
    ;; :straight (:host github :repo "DogLooksGood/parinfer-mode")
    :straight t
    :if (eq 'windows-nt system-type)
    :commands (parinfer-mode)
    :general
    (parinfer-mode-map
     "\"" nil) ;; let smartparens do its thing
    (:states 'motion
     "g p" 'parinfer-toggle-mode)
    :custom
    (parinfer-auto-switch-indent-mode
     t "We prefer indent mode")
    (parinfer-auto-switch-indent-mode-when-closing
     t)
    :init
    (progn (setq parinfer-extensions
                 '(defaults       ; should be included.
                    pretty-parens  ; different paren styles for different modes.
                    evil           ; if you use evil.
                    ;; smart-tab      ; c-b & c-f jump positions and smart shift with tab & s-tab.
                    smart-yank))))   ; yank behavior depend on mode.
#+end_src

** Parinfer Rust Mode
#+begin_src emacs-lisp :results output silent
  (use-package parinfer-rust-mode
    :straight t
    :if (not (eq 'windows-nt system-type))
    :commands (parinfer-rust-mode)
    :general
    (:states 'motion
     "g p" 'parinfer-rust-toggle-paren-mode)
    :custom
    (parinfer-rust-auto-download t))
#+end_src

** my-maybe-init-parinfer
#+begin_src emacs-lisp :results output silent
  (defun my-maybe-init-parinfer ()
    (if (not (eq 'windows-nt system-type))
        (parinfer-rust-mode)
      (parinfer-mode)))
#+end_src

** Rainbow Delimiter Mode
Consider deprecating this now we're trying out prism

#+begin_src emacs-lisp :results output silent
  (use-package rainbow-delimiters
    :straight (:host github :repo "Fanael/rainbow-delimiters")
    :commands (rainbow-delimiters-mode-enable)
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     ")" 'rainbow-delimiters-mode
     "(" 'rainbow-delimiters-mode)
    :custom (rainbow-delimiters-max-face-count 3)
    :hook (prog-mode-hook . rainbow-delimiters-mode-enable))
#+end_src

** Rainbow Identifiers Mode
It looks fairly jarring to be very honest.

#+begin_src emacs-lisp :results output silent
  (use-package rainbow-identifiers
    :straight (:host github :repo "Fanael/rainbow-identifiers")
    :commands (rainbow-identifiers-mode))
#+end_src

** Rainbow Blocks
Refer to prism

#+begin_src emacs-lisp :results output silent
  (use-package rainbow-blocks
    :straight (:host github :repo "istib/rainbow-blocks")
    :disabled t
    :commands (rainbow-blocks-mode
               rainbow-blocks-mode-enable))
#+end_src

** Prism mode
Much like rainbow blocks mode, but better.
#+begin_src emacs-lisp :results output silent
  (use-package prism
    :straight (:host github :repo "alphapapa/prism.el")
    :commands (prism-mode
               prism-whitespace-mode)
    :preface
    (use-package anaphora
      :straight (:host github :repo "rolandwalker/anaphora")))
#+end_src

* Elisp                                                               :major:
package is known as elisp-mode but it reads as emacs-lisp

#+begin_src emacs-lisp :results output silent
  (use-package elisp-mode
    :straight nil
    :hook ((emacs-lisp-mode-hook . prism-mode)
           (emacs-lisp-mode-hook . rainbow-delimiters-mode)
           (emacs-lisp-mode-hook . my-maybe-init-parinfer)
           (emacs-lisp-mode-hook . update-evil-shift-width)
           (emacs-lisp-mode-hook . evil-cleverparens-mode)))
           ;; (emacs-lisp-mode-hook . (lambda () (setq-local comment-begin ";; "))))) ;; not working for some reason
           ;; (emacs-lisp-mode-hook . (lambda ()
           ;;                      (mapc (lambda (pair) (push pair
           ;;                                            prettify-symbols-alist
           ;;                            '(("nil"      . #x2205)
           ;;                              ("not"      . #xac)
           ;;                              ("<="       . #x2264)
           ;;                              (">="       . #x2265)
           ;;                              ;; ("defun" . #x0192)
           ;;                              ("or"       . #x2228)
           ;;                              ("and"      . #x2227))))
#+end_src

** Update Indentation Function
NOTE: We want to carefully override this
https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned
https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94

#+begin_src emacs-lisp :results output silent
  (defun my-updated-lisp-indent-function (indent-point state)
    "This function is the normal value of the variable `lisp-indent-function'.
  The function `calculate-lisp-indent' calls this to determine
  if the arguments of a Lisp function call should be indented specially.

   INDENT-POINT is the position at which the line being indented begins.
   Point is located at the point to indent under (for default indentation);
   STATE is the `parse-partial-sexp' state for that position.

   If the current line is in a call to a Lisp function that has a non-nil
   property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
   it specifies how to indent.  The property value can be:

   ,* `defun', meaning indent `defun'-style
   (this is also the case if there is no property and the function
   has a name that begins with \"def\", and three or more arguments);

   ,* an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;

   ,* a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.

  This function returns either the indentation to use, or nil if the
  Lisp function does not specify a special indentation."
    (let ((normal-indent (current-column))
          (orig-point (point)))
      (goto-char (1+ (elt state 1)))
      (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
      (cond
       ;; car of form doesn't seem to be a symbol, or is a keyword
       ((and (elt state 2)
             (or (not (looking-at "\\sw\\|\\s_"))
                 (looking-at ":")))
        (if (not (> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp))
            (progn (goto-char calculate-lisp-indent-last-sexp)
                   (beginning-of-line)
                   (parse-partial-sexp (point)
                                       calculate-lisp-indent-last-sexp 0 t)))
        ;; Indent under the list or under the first sexp on the same
        ;; line as calculate-lisp-indent-last-sexp.  Note that first
        ;; thing on that line has to be complete sexp since we are
        ;; inside the innermost containing sexp.
        (backward-prefix-chars)
        (current-column))
       ((and (save-excursion
               (goto-char indent-point)
               (skip-syntax-forward " ")
               (not (looking-at ":")))
             (save-excursion
               (goto-char orig-point)
               (looking-at ":")))
        (save-excursion
          (goto-char (+ 2 (elt state 1)))
          (current-column)))
       (t
        (let ((function (buffer-substring (point)
                                          (progn (forward-sexp 1) (point))))
              method)
          (setq method (or (function-get (intern-soft function)
                                         'lisp-indent-function)
                           (get (intern-soft function) 'lisp-indent-hook)))
          (cond ((or (eq method 'defun)
                     (and (null method)
                          (> (length function) 3)
                          (string-match "\\`def" function)))
                 (lisp-indent-defform state indent-point))
                ((integerp method)
                 (lisp-indent-specform method state
                                       indent-point normal-indent))
                (method
                 (funcall method indent-point state))))))))
  (advice-add 'lisp-indent-function :override 'my-updated-lisp-indent-function)
#+end_src

** Elmacro
#+begin_src emacs-lisp :results output silent
  (use-package elmacro
    :straight (:host github :repo "Silex/elmacro")
    :commands (elmacro-show-last-macro
               elmacro-show-last-commands
               elmacro-clear-recorded-commands)
    :config
    (elmacro-mode))
#+end_src

* Racket
#+begin_src emacs-lisp :results output silent
  (use-package racket-mode
    :straight (:host github :repo "greghendershott/racket-mode")
    :commands (racket-mode)
    :mode "\\.rkt\\'"
    :hook ((racket-mode-hook . my-maybe-init-parinfer)
           ;; (racket-mode-hook . rainbow-delimiters-mode)
           (racket-mode-hook . prism-mode)
           (racket-mode-hook . evil-cleverparens-mode))
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("rkt" . racket) org-src-lang-modes)))
#+end_src

* Deft
There's an issue when re-entering the deft buffer where we're in
normal mode and not insert mode. Not sure why that is happening, since
the initial entry works as per =deft-mode-hook=

There has been concerns about the performance of deft on folders
containing a lot of files, and if the files are themselves large.

#+begin_src emacs-lisp :results output silent
  (use-package deft
    :straight (:host github :repo "jrblevin/deft")
    :disabled t ;; try org-roam a bit
    :if (boundp 'config-local-syncthing-folder)

    :commands (deft
               deft-filter
               deft-setup) ;; call this if no .deft folder is found
    :custom
    (deft-auto-save-interval 0.0
      "Disable autosave because of permissions issues causing massive
      lag")
    ;; enc is just what we call encrypted files. we do this so that
    ;; org-agenda-files won't try to open journal.org
    (deft-extensions '("org" "md")
      "Set the extensions for deft notes")
    (deft-recursive t
      "Recursively search so we can organise by folders")
    (deft-time-format "%Y-%m-%d")
    ;; (deft-ignore-file-regexp "\\(?:^$\\)")
    (deft-ignore-file-regexp "\\(?:\\.#\\)+\\|#")
    (deft-use-filter-string-for-filename t)
    (deft-use-filename-as-title t)
    (deft-current-sort-method 'title)
    (deft-filter-only-filenames t)
    (deft-file-limit 300)
    (deft-file-naming-rules '(;;(noslash . "-") ;; we want to create directory structure on the fly
                              (nospace . "-")
                              (case-fn . downcase)))
    ;;TODO: don't assume `my-notes-folder' will always be defined
    ;;NOTE: 2020-06-22 This will be different for work machines
    (deft-directory my-notes-folder)
    :general
    (deft-mode-map
      [remap evil-quit] 'quit-window)
    (:keymaps 'deft-mode-map
     :states  '(insert normal motion)
     "C-j"    'widget-forward
     "C-k"    'widget-backward
     ;; make it more like helm, which defaults to this
     "M-j"    'widget-forward
     "M-k"    'widget-backward)
    (:keymaps 'deft-mode-map
     :states  'normal
     "o"      'deft-complete
     "O"     #'(lambda () (interactive)
                 (deft-open-file-other-window t))
     "r"      'deft-rename-file
     ;; first emacsy binding in a vim state [2018-03-21 Wed]
     "q"      'quit-window
     "p"      'deft-filter-yank
     "d d"    'deft-delete-file
     "-"      'open-dired-window)
    (:keymaps 'deft-mode-map
     :states  'insert
     "C-w"    'deft-filter-decrement-word
     "C-u"    'deft-filter-clear)
    :hook ((deft-mode-hook . deft-filter-clear)
           (deft-mode-hook . evil-insert-state))
    :init
    ;; (evil-define-command ex-deft-forwarding-arg (&optional filter)
    (evil-define-command ex-deft-forwarding-arg ()
      "If given an argument, pre-populates the deft filter with
      that argument"
      ;; (interactive "<a>")
      (interactive)
      ;; (deft-filter filter t)
      (call-interactively 'deft)
      (deft-filter-clear)
      (evil-insert-state))
    ;; (my-evil-define-split-vsplit-cmd "n[otes]" 'deft)
    ;; (evil-ex-define-cmd "tn" #'(lambda () (interactive)
    ;;                             (funcall-interactively 'my-new-evil-tab nil)
    ;;                             (deft)))
    ;; (evil-ex-define-cmd "nn" 'ex-deft-forwarding-arg)
    (my-evil-define-split-vsplit-cmd "nn" 'ex-deft-forwarding-arg)
    (evil-ex-define-cmd "Tnn"
     #'(lambda () (interactive)
        ;; TODO: unify this implementation with my-new-cmd-tab
        (if (>= emacs-major-version 27)
            (tab-bar-new-tab)
          (require 'eyebrowse)
          (my-new-evil-tab nil))
        (funcall-interactively 'ex-deft-forwarding-arg)))
    :config
    (require 'org-id)
    (org-id-update-id-locations (directory-files-recursively
                                 deft-directory "\.org$") t)
    (with-eval-after-load 'org-agenda
      (add-to-list 'org-agenda-files
                   (directory-files deft-directory t "\.org$"))))
#+end_src

** TODO Zetteldeft
- Propose using ex commands, with a "z" prefix (it does not seem to be
  used, and z seems sufficiently out of the way.
- We would like to be able to work with this schema using nothing but
  ripgrep or some cli search tool. (i.e we want this to be emacs
  agnostic. it might not be all that possible because org-mode is
  strongly tied to emacs, but if the id can cross file format
  boundaries (e.g if it can link to markdown or some other document)
  then I think we have succeeded.

#+begin_src emacs-lisp :results output silent
  (use-package zetteldeft
    :straight (:host github :repo "efls/zetteldeft")
    :disabled t
    :after deft
    :demand t
    :commands (zetteldeft-new-file
               zetteldeft-new-file-and-link
               zetteldeft-fine-file-id-insert
               zetteldeft-follow-link
               zetteldeft-file-rename
               zetteldeft-avy-tag-search
               zetteldeft-avy-link-search)
    :custom
    (zetteldeft-id-format "%s"
                          "Single number. I want the ID to not rely on
                          the structure of dates.")
    (zetteldeft-link-indicator "@")
    (zetteldeft-id-regex "[[:alnum:]]+")
    (zetteldeft-tag-regex "#[[:alnum:]\:-]+")
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "n n" 'zetteldeft-find-file
     "n y" 'zetteldeft-copy-id-current-file
     "n c" 'zetteldeft-new-file
     "n s" 'zetteldeft-new-file-and-link
     "n i" 'zetteldeft-find-file-id-insert
     "n l" 'zetteldeft-follow-link
     "n r" 'zetteldeft-file-rename
     "n t" 'zetteldeft-avy-tag-search
     "n T" 'zetteldeft-tag-buffer
     "n f" 'zetteldeft-avy-link-search)
    :init
    (evil-define-command my-zetteldeft-find-or-create-insert-file ()
      "Tries to incrementally find a zettel.
  If it exists, inserts the ID of the zettel.
  Otherwise, creates a new zettel and inserts that instead."
      (interactive)
      (let ((input (ivy-read
                    ""
                    (directory-files deft-directory t ".org$"))))
        (if (f-exists? input)
            (zetteldeft-find-file-id-insert input)
          (zetteldeft-new-file-and-link input))))
    (evil-ex-define-cmd "nc" 'zetteldeft-new-file)
    (evil-ex-define-cmd "ny" 'zetteldeft-copy-id-current-file)
    (evil-ex-define-cmd "ns" 'zetteldeft-new-file-and-link)
    (evil-ex-define-cmd "ni" 'zetteldeft-find-file-id-insert)
    (evil-ex-define-cmd "nl" 'zetteldeft-follow-link)
    (evil-ex-define-cmd "nr" 'zetteldeft-file-rename)
    (evil-ex-define-cmd "nt" 'zetteldeft-avy-tag-search)
    (evil-ex-define-cmd "nf" 'zetteldeft-avy-link-search)
    :config
    (with-eval-after-load 'rg
      (rg-define-search search-zettel
        :dir deft-directory
        :files "everything"
        :confirm prefix
        :menu ("Zettel" "zz" "Zetteldeft files")))
    ;; Because of the regex we chose, the original implementation (which
    ;; set the point to the end and then looked backwards for the first
    ;; match, would find the wrong match (we want the one closest to the
    ;; start of the temp buffer)). This fix resets the point to the
    ;; start, and then matches forward.
    ;; NOTE: This could be a PR
    (advice-add 'zetteldeft--lift-id :override
                (lambda (str)
                  (with-temp-buffer
                    (insert str)
                    (goto-char 0)
                    (when (re-search-forward zetteldeft-id-regex nil t 1)
                      (match-string 0)))))
    ;; When inserting the string and id, insert the string before the
    ;; id, instead of after as is the default.
    ;; (advice-add 'zetteldeft-new-file-and-link :override
    ;;             (lambda (str)
    ;;               (interactive (list (read-string "Note title: ")))
    ;;               (let* ((zdId (zetteldeft-generate-id))
    ;;                      (zdStr (concat str " "
    ;;                                     zetteldeft-link-indicator
    ;;                                     zdId
    ;;                                     zetteldeft-link-suffix)))
    ;;                 (insert zdStr)
    ;;                 (zetteldeft-new-file str zdId))))
    ;; Remove whitespace after generating the tag because otherwise
    ;; it'll show up as really distracting red blocks.
    (advice-add 'zetteldeft-tag-buffer :after
                'whitespace-cleanup)
    ;; Add font lock for tags too while we're here. This feature might
    ;; get implemented by zetteldeft in the future, so we might have to
    ;; update this.
    (font-lock-add-keywords 'org-mode
                            `((,zetteldeft-tag-regex
                               . font-lock-constant-face)))
                               ;; . font-lock-regexp-grouping-backslash)))
    ;; somehow we need to do this for the font customizations to show
    ;; up, and even then it's not the most reliable
    (org-mode-restart))
#+end_src

* AES Encryption

#+begin_src emacs-lisp :results output silent
  (use-package aes
    :defer nil
    :straight (:host github :repo "Sauermann/emacs-aes")
    :commands (aes-toggle-encryption ;; this makes it auto encrypt/decrypt
               aes-remove-encryption-hook
               aes-is-encrypted
               aes-enable-auto-decryption
               aes-encrypt-buffer-or-string
               aes-decrypt-buffer-or-string)
    ;; :hook (change-major-mode-hook . (lambda ()
    ;;                                   (when (aes-is-encrypted)
    ;;                                     (auto-save-mode -1)
    ;;                                     (aes-toggle-encryption))))
    :init
    (evil-define-command ex-encrypt-buffer ()
      (interactive)
      (if (aes-is-encrypted)
          (aes-decrypt-current-buffer)
        (aes-encrypt-current-buffer)))
    (evil-ex-define-cmd "X" 'ex-encrypt-buffer)
    (add-to-list 'auto-mode-alist '("\\.enc\\'"
                                    #'(lambda ()
                                        (when (aes-is-encrypted)
                                          (aes-toggle-encryption))) t)))
#+end_src

** Encrypt operator
#+begin_src emacs-lisp :results output silent
  (evil-define-operator evil-encrypt-aes (beg end)
    "Attempt to encrypt or decrypt a range using
  `aes-encrypt-buffer-or-string' and `aes-decrypt-buffer-or-string'"
    (require 'aes)
    (let ((buf (current-buffer)))
      (with-temp-buffer
        ;; Copy region into a temporary buffer so we can encrypt/decrypt
        (insert-buffer-substring buf beg end)
        ;; Discard newline so the aes functions can check if it's
        ;; encrypted. We might want to just skip the newlines instead of
        ;; discarding them in the future, so that a-textobjects can also
        ;; work instead of just i-textobjects
        (flush-lines "^$" (point-min) (point-max))
        (if (aes-is-encrypted)
            (aes-decrypt-buffer-or-string (current-buffer))
          (aes-encrypt-buffer-or-string (current-buffer)))
        ;; Copy result back into original buffer
        (let ((temp-buf (current-buffer)))
          (with-current-buffer buf
            ;; Delete original text before copying
            (delete-region beg end)
            (insert-buffer-substring temp-buf))))))
#+end_src

#+begin_src emacs-lisp :results output silent
  (general-define-key
    :keymaps 'normal
    "g X" 'evil-encrypt-aes)
#+end_src

* Clojure                                                             :major:
clojurescript-mode derives from clojure-mode

[[https://clojure.org/api/cheatsheet][Cheatsheet]]

#+begin_src emacs-lisp :results output silent
  (use-package clojure-mode
    :straight (:host github :repo "clojure-emacs/clojure-mode")
    :commands (clojure-mode
               clojurescript-mode)
    :hook ((clojure-mode-hook . my-maybe-init-parinfer)
           ;; (clojure-mode-hook . rainbow-delimiters-mode)
           (clojure-mode-hook . prism-mode)
           (clojure-mode-hook . update-evil-shift-width)
           (clojure-mode-hook . show-paren-mode))
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("edn" . clojure) org-src-lang-modes)
      (cl-pushnew '("clj" . clojure) org-src-lang-modes)
      (cl-pushnew '("cljs" . clojurescript) org-src-lang-modes)))
#+end_src

** CIDER
When using straight, we first encounter =cider-test.el= not found, and
then later on =package sesman not found in recipe repositories=

Sesman is not found normally by cider, so we had to manually clone it

This is actually fairly expensive to load
#+begin_src emacs-lisp :results output silent
  (use-package sesman
    :straight (:host github :repo "vspinu/sesman")
    :defer t)
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package cider
    :commands (cider-jack-in
               cider-connect)
    :straight (:host github :repo "clojure-emacs/cider"
               :files (:defaults "cider-test.el")))
#+end_src

We were unable to launch a shadow-cljs nREPL directly, but we are able
to successfully connect (using =cider-connect-cljs=) into a repl we
ran using ~shadow-cljs watch app~. Do note that the socket REPL and
nREPL server runs on different ports, and neither were the ones
recommended by the cider completion engine.

We should look at customizing cider someday.

* Rust                                                                :major:
#+begin_src emacs-lisp :results output silent
  (use-package rust-mode
    :straight (:host github :repo "rust-lang/rust-mode")
    :mode
    ("\\.rs\\'" . rust-mode)
    :custom
    (rust-format-on-save t)
    :general
    (:states 'insert
     :keymaps 'rust-mode-map
     "RET" 'comment-indent-new-line)
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("rust" . rust) org-src-lang-modes))
    (with-eval-after-load 'lsp-mode
      (add-hook 'rust-mode-hook 'lsp)))
#+end_src

** Cargo
Requires rust-mode and markdown-mode
#+begin_src emacs-lisp :results output silent
  (use-package cargo
    :straight (:host github :repo "kwrooijen/cargo.el")
    :diminish cargo-minor-mode
    :commands cargo-minor-mode
    :hook (rust-mode-hook . cargo-minor-mode))
    ;; :init
    ;; (evil-define-command my-cargo-wrapper (arg)
    ;;   (interactive "<a>")
    ;;   (cond
    ;;    ()))
    ;; (evil-ex-define-cmd "cargo" 'my-cargo-wrapper))
#+end_src

** Cargo-Mode
#+begin_src emacs-lisp :results output silent
  (use-package cargo-mode
    :straight (:host github :repo "ayrat555/cargo-mode")
    :commands
    (cargo-mode-execute-task
     cargo-mode-test
     cargo-mode-last-command
     cargo-mode-build
     cargo-mode-test-current-buffer
     cargo-mode-test-current-test))
#+end_src

* Dired
- Make it more like netrw


[[https://gist.github.com/t-mart/610795fcf7998559ea80][Netrw map]]

#+begin_src emacs-lisp :results output silent
  (use-package dired
    :demand t
    :ensure nil
    :straight nil
    :general
    (dired-mode-map
     :states 'normal
     "<SPC>" nil                     ; was shadowing leader key bindings
     "SPC" nil                       ; was shadowing leader key bindings
     "-" 'dired-jump
     "d" 'dired-create-directory
     "e" 'dired-toggle-read-only ; similar interface to wgrep
     "/" 'counsel-find-file
     "?" 'counsel-find-file
     "+" 'project-find-file) ; don't block org-projectile
    :config
    ;; (evil-define-command open-dired-window ()
    ;;   (interactive)
    ;;   (if buffer-file-name
    ;;       (dired (file-name-directory (buffer-file-name)))
    ;;     (dired default-directory)))
    (evil-ex-define-cmd "Ex[plore]" 'dired-jump)
    (evil-ex-define-cmd "Sex[plore]" #'(lambda () (interactive)
                                        (call-interactively 'evil-window-split)
                                        (dired-jump)))
    (evil-ex-define-cmd "Vex[plore]" #'(lambda () (interactive)
                                        (call-interactively 'evil-window-vsplit)
                                        (dired-jump))))
    ;; (evil-ex-define-cmd "Tex[plore]" #'(lambda () (interactive)
    ;;                                     (require 'eyebrowse)
    ;;                                     (let ((eyebrowse-new-workspace 'dired-jump))
    ;;                                       (eyebrowse-create-window-config)))))
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package dired-hacks
    :ensure nil
    :after dired
    :straight (:host github :repo "Fuco1/dired-hacks")
    :custom-face
    (dired-subtree-depth-1-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    (dired-subtree-depth-2-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    (dired-subtree-depth-3-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    (dired-subtree-depth-4-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    (dired-subtree-depth-5-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    (dired-subtree-depth-6-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    :general
    (dired-mode-map
     :states 'normal
      "TAB" 'dired-subtree-toggle
      "z a" 'dired-subtree-toggle
      "z o" 'dired-subtree-insert
      "z c" 'dired-subtree-remove))
#+end_src

note: use :Ex instead like Vim does
# #+begin_src emacs-lisp :results output silent
#   (general-define-key :keymaps 'normal
#     "-" 'open-dired-window)
# #+end_src

** Dired+
#+begin_src emacs-lisp :results output silent
  ;; (unless (el-get-package-is-installed 'dired+)
  ;;   (el-get-emacswiki-build-local-recipes)
  ;;   (el-get-install 'dired+))
  ;; (use-package dired+
  ;;   :ensure nil
  ;;   :straight nil
  ;;   :after dired
  ;;   :custom-face
  ;;   (diredp-dir-heading ((t (:inherit font-lock-warning-face :bold t))))
  ;;   (diredp-dir-name ((t (:inherit font-lock-string-face :bold t))))
  ;;   (diredp-file-name ((t (:inherit font-lock-function-name-face))))
  ;;   (diredp-file-suffix ((t (:inherit font-lock-type-face))))
  ;;   (diredp-ignored-file-name ((t (:inherit 'font-lock-comment-face))))
  ;;   (diredp-flag-mark ((t (:inherit font-lock-keyword-face)))))
#+end_src

** w32-browser
#+begin_src emacs-lisp :results output silent
  ;; (unless (el-get-package-is-installed 'w32-browser)
  ;;   (el-get-emacswiki-build-local-recipes)
  ;;   (el-get-install 'w32-browser))
  ;; (use-package w32-browser
  ;;   :ensure nil
  ;;   :straight nil
  ;;   :after dired)
#+end_src

* Help
#+begin_src emacs-lisp :results output silent
  ;; (general-define-key
  ;;  :keymaps 'help-mode-map
  ;;  :states 'normal
  ;;  "f" 'ace-link-help
  ;;  "F" 'ace-link-help)
#+end_src

* Help+
- Emacswiki :: https://www.emacswiki.org/emacs/HelpPlus


These packages are from emacswiki, and are currently not being maintained.

They are being stored and loaded locally, since they are not on melpa or any
package manager

#+begin_src emacs-lisp :results output silent
  (use-package help+
    :disabled t
    :defer 7
    :straight nil
    :load-path "local-packages/")
  (use-package help-macro+
    :defer 7
    :disabled t
    :straight nil
    :load-path "local-packages/")
  (use-package help-mode+
    :defer 7
    :disabled t
    :straight nil
    :load-path "local-packages/")
  (use-package help-fns+
    :defer 7
    :disabled t
    :straight nil
    :commands (describe-keymap
               describe-buffer
               describe-command
               describe-option
               describe-key-briefly
               describe-option-of-type
               describe-copying
               find-function-on-key)
    :load-path "local-packages/")
#+end_src

* Dumb Jump
#+begin_src emacs-lisp :results output silent
  (use-package dumb-jump
    :straight (:host github :repo "jacktasia/dumb-jump")
    :commands
    (dumb-jump-xref-activate)
    :custom
    (dumb-jump-selector 'ivy)
    ;; :general
    ;; (:states '(normal)
    ;;  "g D" 'dumb-jump-go
    ;;  "C-]" 'my-evil-dumb-jump)
    ;; ;; "g C-]" 'my-evil-dumb-jump)
    :hook
    (xref-backend-functions . dumb-jump-xref-activate))
    ;; :init
    ;; (evil-define-motion my-evil-dumb-jump (arg)
    ;;   :jump t
    ;;   (interactive "P")
    ;;   (if arg
    ;;       (dumb-jump-go-prompt)
    ;;     (dumb-jump-go))))
#+end_src

* Anki

** Orgmode flavored anki editing
#+begin_src emacs-lisp :results output silent
  (use-package anki-editor
    :straight (:host github :repo "louietan/anki-editor")
    :commands (anki-editor-push-notes
               anki-editor-retry-failure-notes
               anki-editor-insert-note
               anki-editor-cloze-region
               anki-editor-export-subtree-to-html
               anki-editor-convert-region-to-html))
#+end_src

* JSON                                                                :major:
#+begin_src emacs-lisp :results output silent
  (use-package json-mode
    :straight (:host github :repo "joshwnj/json-mode")
    :mode "\\.json\\'"
    :commands (json-mode)
    :hook
    (json-mode-hook . prism-mode)
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("json" . json) org-src-lang-modes)))
#+end_src

** Json Snatcher
#+begin_src emacs-lisp :results output silent
  (use-package json-snatcher
    :straight t
    :commands (jsons-print-path))
#+end_src

* YAML
https://github.com/zkry/yaml.el/tree/9ebddb55238d746dc5a5d46db04c9f360c140b99
#+begin_src emacs-lisp :results output silent
  (use-package yaml
    :straight t
    :commands (yaml-parse-string))
#+end_src

* Wgrep
Being able to mass-edit using search results seem interesting
http://blog.binchen.org/posts/use-wgrep-and-evil-to-replace-text-efficiently.html

Note that for some reason using plain old =ag= works while
=counsel-ag= does not.

In the =ag= buffer call =C-c C-p= to launch wgrep.

#+begin_src emacs-lisp :results output silent
  (use-package wgrep
    :straight (:host github :repo "mhayashi1120/Emacs-wgrep")
    :commands (wgrep-change-to-wgrep-mode
               ivy-wgrep-change-to-wgrep-mode)
    :custom (wgrep-auto-save-buffer t))
#+end_src

* Silver Searcher (Ag)
#+begin_src emacs-lisp :results output silent
  (use-package ag
    :disabled t ;; We use ripgrep now
    :straight (:host github :repo "Wilfred/ag.el")
    :commands ag
    :init
    (evil-define-command config-ag-explicit (arg)
      "Call =ag= when not in a project; call =projectile-ag= otherwise.
       If additional arguments are passed into the command, use those as
       arguments. Otherwise default to the word at point, but allow the user
       to type it out."
      (interactive "<a>")
      (let ((search-term (if arg arg
                           (let ((word (thing-at-point 'word)))
                             (read-string "Ag query: "
                                          word nil word))))
            (root-dir (or (projectile-project-p)
                        default-directory)))
          (ag search-term root-dir)))
    (evil-ex-define-cmd "ag" #'config-ag-explicit))
#+end_src

* Ripgrep (rg)
:PROPERTIES:
:DEPENDENCIES: wgrep
:END:

*rg* buffer bindings

| Key | Description                              |
|-----+------------------------------------------|
| c   | Toggle case insensitive setting          |
| d   | Change directory                         |
| f   | Change file pattern                      |
| g   | Rerun search                             |
| i   | Toggle --no-ignore flag                  |
| l   | List search buffers in a separate buffer |
| r   | Edit search string as regexp             |
| s   | Save search result to unique name        |
| S   | Save search result, prompt for name      |
| t   | Edit search string as literal            |
| w   | Switch to wgrep mode                     |
| C-f | Navigate forward in search history       |
| C-b | Navigate backward in search history      |

*use =everything= to search with no filters. =all= searches with all
filters*.

#+begin_src emacs-lisp :results output silent
  (use-package rg
    :straight (:host github :repo "dajva/rg.el")
    :commands (rg
               rg-project
               rg-dwim
               rg-literal
               rg-define-search
               rg-menu)
    :custom
    (rg-ignore-case 'smart)
    (rg-keymap-prefix "")
    (rg-default-alias-fallback "everything")
    (rg-buffer-name #'(lambda () (format "*rg<%s>*" (buffer-name))))
    :general
    (rg-mode-map
     :states '(motion normal)
     "gg" 'evil-goto-first-line)
    (grep-mode-map
     :states '(motion normal)
      "n" 'evil-ex-search-next
      "N" 'evil-ex-search-previous)
    (:states '(normal motion visual)
     "C-+" 'rg-menu)
    :init
    ;; (evil-define-command config-rg-explicit (arg)
    ;;   (interactive "<a>") ;TODO: Figure out how to programmatically generate a files list, which we need in addition to a query
    ;;   (cond
    ;;    ;; ((and arg (projectile-project-p)) (rg-project arg))
    ;;    ((and (not arg) (projectile-project-p)) (call-interactively 'rg-project))
    ;;    ;; (arg (rg arg))
    ;;    (t (call-interactively 'rg))))
    (evil-ex-define-cmd "rg" 'rg-menu)
    ;; (evil-ex-define-cmd "prg" 'rg-project)
    :config
    (rg-enable-menu)
    (rg-define-search search-everything-in-project
      "Uses the everything filter for project searches"
      :files "everything"
      :dir project
      :menu ("Custom" "e" "Unfiltered Project"))
    (with-eval-after-load 'hl-todo
      (rg-define-search search-hl-todo-keywords
        "Uses the everything filter for project searches"
        :query (-> (mapcar 'car hl-todo-keyword-faces)
                   (string-join "|"))
        :format regexp
        :files "everything" ;; make this "all" maybe?
        :dir project
        :menu ("Custom" "hl" "`hl-todo' Keywords"))
      (evil-ex-define-cmd "hl-todo" 'search-hl-todo-keywords)))
#+end_src
* C++
** Indentation of 4
#+begin_src emacs-lisp :results output silent
  (setq-default c-basic-offset 4)
#+end_src

** Default to K&R style
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'cc-mode
    (customize-set-value 'c-default-style
                        (add-to-list 'c-default-style '(c++-mode . "k&r")))
    (customize-set-value 'c-default-style
                        (add-to-list 'c-default-style '(c-mode . "k&r"))))
#+end_src

** Newline in comments should insert an indented comment
#+begin_src emacs-lisp :results output silent
  (general-define-key :states 'insert
                      :keymaps 'c-mode-base-map
                      "C-<return>" 'comment-indent-new-line)
#+end_src

** Treat .h files as cpp files
#+begin_src emacs-lisp :results output silent
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+end_src

** Treat .hpp files as cpp files
#+begin_src emacs-lisp :results output silent
  (add-to-list 'auto-mode-alist '("\\.hpp\\'" . c++-mode))
#+end_src

** cpp-specific ligatures
We do not support =&&= (and hence also =||=) because of conflicts with
r-value references.
#+begin_src emacs-lisp :results output silent
  (add-hook 'c-mode-common-hook
            #'(lambda ()
                (mapc (lambda (pair) (push pair prettify-symbols-alist))
                      '(("!=" . #x2260)
                        ("!" . #xac)
                        ;; ("==" . #x2a75) ;; Not supported by Iosevka
                        ;; ("->" . #x27f6) ;; Not supported by Iosevka
                        ("->" . #x2192) ;; 1-char width version
                        ("<=" . #x2264)
                        (">=" . #x2265)))))
                        ;; ("&&" . #x2227)
                        ;; ("||" . #x2228)))))
#+end_src

** Clang Format
#+begin_src emacs-lisp :results output silent
  (use-package clang-format
    :straight (:host github :repo "emacsmirror/clang-format")
    :commands (clang-format-region
               clang-format-buffer
               clang-format)
    :general
    (c++-mode-map
     :states '(normal)
      "C-c C-f" 'my-evil-clang-format)
    (java-mode-map
     :states '(normal)
      "C-c C-f" 'my-evil-clang-format)
    ;; :init
    ;; IF there is a .clang-format, then use that to format before
    ;; saving
    ;; (defun my-clang-format-before-save ()
    ;;   (require 'projectile)
    ;;   (require 'clang-format)
    ;;   (require 'f)
    ;;   (when (f-exists?
    ;;          (expand-file-name ".clang-format"
    ;;                            (projectile-project-root)))
    ;;     (add-hook 'before-save-hook 'clang-format-buffer t t)))
    ;; :hook (c++-mode-hook . my-clang-format-before-save)
    :init
    (evil-define-operator my-evil-clang-format (beg end)
      (require 'clang-format)
      (clang-format beg end))
    (defun toggle-clang-format-on-save ()
      "Toggle clang-format-buffer on a per-buffer level."
      (interactive)
      (unless (boundp 'toggle-clang-format-on-save)
        (setq-local toggle-clang-format-on-save nil))
      (if (not toggle-clang-format-on-save)
          (progn (add-hook 'before-save-hook 'clang-format-buffer t t)
                 (setq-local toggle-clang-format-on-save t)
                 (message "toggle-clang-format-on-save t"))
        (remove-hook 'before-save-hook 'clang-format-buffer t)
        (setq-local toggle-clang-format-on-save nil)
        (message "toggle-clang-format-on-save nil")))
    :custom
    (clang-format-style-option "file"
                               "read from .clang-format"))
#+end_src

*** Clang-Format+
#+begin_src emacs-lisp :results output silent
  (use-package clang-format+
    :after clang-format
    :straight t)
#+end_src

* Disable autoformatting modes when drawing things
You can consider =artist-mode= a featurewise superset of =picture-mode=.

#+begin_src emacs-lisp :results output silent
  (add-hook 'artist-mode-hook #'(lambda () (aggressive-fill-paragraph-mode -1)))
#+end_src

* Org source block handling for Artist-mode
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'org-src
    (cl-pushnew '("artist" . artist) org-src-lang-modes))
#+end_src

* Ledger                                                              :major:
#+begin_src emacs-lisp :results output silent
  (use-package ledger-mode
    :mode "\\.ledger\\'"
    :straight (:host github :repo "ledger/ledger-mode"
               :files (:defaults "ledger-test.el"))
    :init
      (with-eval-after-load 'org-src
        (cl-pushnew '("ledger" . ledger) org-src-lang-modes)))
#+end_src

** Evil-ledger
#+begin_src emacs-lisp :results output silent
  (use-package evil-ledger
    :straight (:host github :repo "atheriel/evil-ledger")
    :after (ledger-mode))
#+end_src

* Beancount
It's a minor mode, much like how magit's commit mode is a minor mode
#+begin_src emacs-lisp :results output silent
  (use-package beancount
    :straight (:host github :repo "beancount/beancount-mode")
    :mode ("\\.beancount\\'" . beancount-mode)
    :init
    (defun my-beancount-insert-date ()
      "Does the same thing as `beancount-insert-date', but uses
  `org-read-date' for more ergonomic date generation."
      (interactive)
      (unless (bolp) (newline)) ;; `beancount-insert-date' does this
      (insert (org-read-date) " "))
    :general
    (beancount-mode-map
     "M-RET" #'my-beancount-insert-date)
    :config
    (with-eval-after-load 'org-src
      (cl-pushnew '("beancount" . beancount) org-src-lang-modes)))
    ;; :general
    ;; (beancount-mode-map
    ;;  :states '(normal motion insert)
    ;;  "<f5>" #'(lambda () (interactive)
    ;;            (insert (format-time-string "%Y-%m-%d"))))
    ;; causing fontification errors
    ;; :hook ((org-mode-hook . beancount-mode)))
#+end_src

* Hledger                                                             :major:
#+begin_src emacs-lisp :results output silent
  (use-package hledger-mode
    :straight (:host github :repo "narendraj9/hledger-mode")
    :mode "\\.journal\\'")
#+end_src

* Abbreviations
#+begin_src emacs-lisp :results output silent
  (use-package abbrev
    :ensure nil
    :straight nil
    :delight (abbrev-mode nil "abbrev")
    :custom
    (abbrev-file-name (locate-user-emacs-file "abbrevs.el"))
    (save-abbrevs 'silently)
    :general
    (edit-abbrevs-mode-map
     [remap evil-save] 'abbrev-edit-save-buffer)
    (:states '(normal visual)
     :prefix my-default-evil-leader-key
     "a a" 'inverse-add-global-abbrev)
    :init
    ;; This makes it active globally
    (setq-default abbrev-mode t)
    (evil-define-command my-inverse-add-global-abbrev (beg end _type)
      "Generates an abbrev for the given visual selection."
      (interactive "<v>")
      (require 'abbrev)
      ;; nil if there is no visual region; the number of words in the
      ;; region otherwise
      ;; (add-global-abbrev
      ;;  (if (and beg end)
      ;;      (-> (buffer-substring-no-properties beg end)
      ;;          (split-string)
      ;;          (length))
      ;;    1))))
      ;; (evil-define-command ex-abbreviation (arg)
      ;;   "Attempts to replicate the :abbreviate function in vim.
      ;; :ab - Shows you the abbreviation tables
      ;; :ab A B [C D E] - Expands \"A\" to \"B C D E\". At least 2 arguments
      ;; must be given, otherwise it's a no-op."
      ;;   (interactive "<a>")
      ;;   ;; TODO: figure out what happens if we want the expansion to have
      ;;   ;; variable space length. We currently don't care, because odds are
      ;;   ;; we want our expansion to look like good english anyway.
      ;;   (if (not arg)
      ;;       (edit-abbrevs)
      ;;     (let* ((arguments (split-string arg))
      ;;            (size (safe-length arguments)))
      ;;       (cond
      ;;        ((= size 1) nil) ;; no op, as far as I can tell
      ;;        (t (let ((expansion (mapconcat 'identity (cdr arguments) " ")))
      ;;             (define-global-abbrev (car arguments) expansion)))))))
      ;; (evil-ex-define-cmd "ab[breviate]" 'ex-abbreviation))
      ;; (if (and beg end)
      ;;     (let ((current-prefix-arg 0))
      ;;       (call-interactively 'add-global-abbrev))
      ;;   (call-interactively 'inverse-add-global-abbrev))
      (let* ((name (if (region-active-p)
                      (buffer-substring-no-properties beg end)
                      (thing-at-point 'word)))
             (exp (read-string (format "abbrev for \"%s\": " name))))
        (define-abbrev global-abbrev-table (downcase name) exp))))
#+end_src



* Writeroom
#+begin_src emacs-lisp :results output silent
  (use-package writeroom-mode
    :straight (:host github :repo "joostkremers/writeroom-mode")
    :commands (writeroom-mode)
    :custom
    (writeroom-mode-line t)
    (writeroom-bottom-divider-width 0)
    (writeroom-maximize-window nil)
    (writeroom-fullscreen-effect 'maximized)
    (writeroom-width 80)
    (writeroom-restore-window-config nil)
    ;; :general
    ;; (:states 'normal
    ;;  "g z" 'writeroom-mode)
    :init
    (evil-ex-define-cmd "writeroom" 'writeroom-mode))
    ;; :hook
    ;; ((writeroom-mode-hook . (lambda () (require 'focus)
    ;;                      (if writeroom-mode
    ;;                          (progn (focus-init)
    ;;                                 (when display-line-numbers-mode
    ;;                                   (display-line-numbers-mode -1)))
    ;;                        (focus-terminate)
    ;;                        (unless display-line-numbers-mode
    ;;                          (display-line-numbers-mode)))))))
#+end_src

* Helpful
#+begin_src emacs-lisp :results output silent
  (use-package helpful
    :straight (:host github :repo "Wilfred/helpful")
    :defer 7
    :general
    ("C-h k"   'helpful-key
     "C-h f"   'helpful-callable
     "C-h v"   'helpful-variable
     "C-h RET" 'helpful-at-point)
    :config
    (require 'link-hint)
    (general-define-key
     :keymaps 'helpful-mode-map
     :states 'normal
     "f" 'link-hint-open-link
     "y f" 'link-hint-copy-link))
    ;; (helpful-mode-map
    ;;  :states 'normal
    ;;  "f" 'ace-link-help
    ;;  "F" 'ace-link-help))
#+end_src

* Elisp demos

#+begin_src emacs-lisp :results output silent
  (use-package elisp-demos
    :after (helpful)
    :straight (:host github :repo "xuchunyang/elisp-demos"
               :files (:defaults "elisp-demos.org"))
    :config
    (with-eval-after-load 'helpful
      (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
    (advice-add 'describe-function-1 :after #'elisp-demos-advice-describe-function-1))
#+end_src

* Make shell open in same window
- Related Spacemacs Issue ::
  https://github.com/syl20bnr/spacemacs/issues/6820
- Make shell mode update working directory ::
  [[https://emacs.stackexchange.com/questions/5589/automatically-update-default-directory-when-pwd-changes-in-shell-mode-and-term-m][stackoverflow]]


Let's try just creating the shell on the side instead of overtaking
the thing, because that's what vim does.

#+begin_src emacs-lisp :results output silent
  (use-package shell
    :ensure nil
    :straight nil
    :commands shell
    :custom
    ;; Make cursor always move to end when entering insert mode in
    ;; comint modes
    (comint-scroll-to-bottom-on-input t)
    (comint-prompt-read-only t)
    :init
    (defun my-buffer-specific-shell ()
      (interactive)
      (let ((name (format "*shell<%s>*" (buffer-name))))
        (shell name)))
    (evil-ex-define-cmd "sh[ell]" #'(lambda () (interactive)
                                     (my-buffer-specific-shell)))
    (evil-ex-define-cmd "Sshell" #'(lambda () (interactive)
                                    (evil-window-split)
                                    (my-buffer-specific-shell)))
    (evil-ex-define-cmd "Vshell" #'(lambda () (interactive)
                                    (evil-window-vsplit)
                                    (my-buffer-specific-shell)))
    (add-to-list 'display-buffer-alist '("\\*shell\\*" . (display-buffer-same-window . nil)))
    :hook
    ((shell-mode-hook . (lambda ()
                          (shell-dirtrack-mode 0)
                          (set-variable 'dirtrack-list '("^.*[^ ]+:\\(.*\\)>" 1 nil))
                          (dirtrack-mode 1)))))
#+end_src

* Groovy mode                                                         :major:
#+begin_src emacs-lisp :results output silent
  (use-package groovy-mode
    :straight (:host github :repo "Groovy-Emacs-Modes/groovy-emacs-modes")
    :mode (("\\.groovy\\'" . groovy-mode)
           ("\\Jenkinsfile\\'" . groovy-mode))
    :hook ((groovy-mode-hook . (lambda () (setq-local comment-start "// "))))
    :init
    (with-eval-after-load 'org-src
        (cl-pushnew '("groovy" . groovy) org-src-lang-modes)))
#+end_src

* Hy Mode                                                             :major:
#+begin_src emacs-lisp :results output silent
  (use-package hy-mode
    :straight (:host github :repo "hylang/hy-mode")
    :mode "\\.hy\\'"
    :general
    (hy-mode-map
     :states 'insert
     "RET" 'comment-indent-new-line)
    :hook ((hy-mode-hook . my-maybe-init-parinfer)
           ;; (hy-mode-hook . rainbow-delimiters-mode)
           (hy-mode-hook . prism-mode)
           (hy-mode-hook . update-evil-shift-width)
           (hy-mode-hook . evil-cleverparens-mode)
           (hy-mode-hook . show-paren-mode))
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("hy" . hy) org-src-lang-modes)))
#+end_src

** ob-hy
#+begin_src emacs-lisp :results output silent
  (use-package ob-hy
    :straight (:host github :repo "brantou/ob-hy")
    :after org-src)
#+end_src

* so-long-mode / vlf-mode
#+begin_src emacs-lisp :results output silent
  (if (>= emacs-major-version 27)
      (global-so-long-mode)
    (use-package vlf
      :disabled t ;; merged into vlf, try built-in so-long instead
      :straight (:host github :repo "m00natic/vlfi")
      :custom (vlf-application 'dont-ask)
      :config (require 'vlf-setup)))
#+end_src

* Yankpad
#+begin_src emacs-lisp :results output silent
  (use-package yankpad
    :disabled t
    :straight (:host github :repo "Kungsgeten/yankpad")
    :commands (yankpad-expand
               yankpad-edit
               yankpad-reload)
    :init
    (add-to-list 'hippie-expand-try-functions-list #'yankpad-expand)
    :custom
    (yankpad-file (locate-user-emacs-file "snippets.org")))
#+end_src

* Smart tab
#+begin_src emacs-lisp :results output silent
  (use-package smart-tab
    :disabled t
    :straight (:host github :repo "genehack/smart-tab")
    :custom
    (smart-tab-using-hippie-expand t)
    :config
    (global-smart-tab-mode))
#+end_src

* Batch/CMD
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'org-src
    (cl-pushnew '("cmd" . bat) org-src-lang-modes)
    (cl-pushnew '("batch" . bat) org-src-lang-modes))
#+end_src

* Python
#+begin_src emacs-lisp :results output silent
  (org-babel-do-load-languages 'org-babel-load-languages
                               (add-to-list 'org-babel-load-languages '(python . t)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (setq-default python-indent-offset 4)

  (general-define-key
   :keymaps 'python-mode-map
   :states 'insert
   "RET" 'comment-indent-new-line)
#+end_src

** Virtual Environment
#+begin_src emacs-lisp :results output silent
  (use-package pyvenv
    :straight (:host github :repo "jorgenschaefer/pyvenv")
    :commands (pyvenv-activate
               pyvenv-workon))
#+end_src

* Powershell
#+begin_src emacs-lisp :results output silent
  (use-package powershell.el
    :straight (:host github :repo "jschaf/powershell.el")
    :commands (powershell-mode powershell)
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("powershell" . powershell) org-src-lang-modes)
      (cl-pushnew '("ps" . powershell) org-src-lang-modes))
    :config
    (defun org-babel-execute:powershell (body _params)
      (let ((explicit-shell-file-name powershell-location-of-exe))
        (shell-command-to-string body))))
#+end_src

* Access todo.org from evil command
#+begin_src emacs-lisp :results output silent
  ;; (evil-define-command my-todo (&optional arg)
  ;;   (interactive "<!>")
  ;;   (when (boundp 'my-todo-org-file)
  ;;     (if arg
  ;;         (org-capture nil "todo")
  ;;       (find-file my-todo-org-file))))
#+end_src

#+begin_src emacs-lisp :results output silent
  (when (boundp 'my-todo-org-file)
    (my-evil-define-split-vsplit-cmd "todo" #'(lambda () (find-file my-todo-org-file)))
    ;; (evil-ex-define-cmd "todo" 'my-todo)
    ;; (evil-ex-define-cmd "Stodo" #'(lambda () (interactive)
    ;;                                (call-interactively 'evil-window-split)
    ;;                                (find-file my-todo-org-file)))
    ;; (evil-ex-define-cmd "Vtodo" #'(lambda () (interactive)
    ;;                                (call-interactively 'evil-window-vsplit)
    ;;                                (find-file my-todo-org-file)))
    (evil-ex-define-cmd "Ttodo" #'(lambda () (interactive)
                                   (my-new-cmd-tab my-todo-org-file))))
#+end_src

#+begin_src emacs-lisp :results output silent
  ;; (when (boundp 'my-notes-org-file)
  ;;   (my-evil-define-split-vsplit-cmd "note[s]" #'(lambda () (find-file my-notes-org-file)))
  ;;   ;; (evil-ex-define-cmd "notes" 'my-notes)
  ;;   ;; (evil-ex-define-cmd "Snotes" #'(lambda () (interactive)
  ;;   ;;                                (call-interactively 'evil-window-split)
  ;;   ;;                                (find-file my-notes-org-file)))
  ;;   ;; (evil-ex-define-cmd "Vnotes" #'(lambda () (interactive)
  ;;   ;;                                (call-interactively 'evil-window-vsplit)
  ;;   ;;                                (find-file my-notes-org-file)))
  ;;   (evil-ex-define-cmd "Tnotes" #'(lambda () (interactive)
  ;;                                   (funcall-interactively
  ;;                                    'my-new-evil-tab my-notes-org-file))))
#+end_src


* Yaml-mode
#+begin_src emacs-lisp :results output silent
  (use-package yaml-mode
    ;; :straight (:host github :repo "yoshiki/yaml-mode")
    :straight t
    :mode ("\\.yml\\'"
           "\\.yaml\\'")
    :hook
    (yaml-mode-hook . prism-whitespace-mode)
    :general
    (yaml-mode-map
     "RET" 'newline-and-indent)
    :commands (yaml-mode)
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("yaml" . yaml) org-src-lang-modes)))
#+end_src

* Journal (Org Journal)
#+begin_src emacs-lisp :results output silent
  (use-package org-journal
    :disabled t ;; we use org-roam now
    :straight (:host github :repo "bastibe/org-journal")
    ;; disabling until https://github.com/bastibe/org-journal/issues/317 is resolved
    :disabled t
    :if (boundp 'config-local-syncthing-folder)
    :commands org-journal-new-entry
    :custom
    (org-journal-time-format "%R ")
    (org-journal-date-format "%F, %A")
    (org-journal-file-type 'daily)
    (org-journal-file-format "%Y-%m-%d.org"
                             "Lets follow the ISO standard")
    :init
    (evil-ex-define-cmd "journal" #'(lambda () (interactive)
                                      (org-journal-new-entry t)))
    (evil-ex-define-cmd "jj" 'org-journal-new-entry)
    (customize-set-variable 'org-journal-dir
                            (f-join config-local-syncthing-folder
                                    "day"))
    :hook
    ((org-journal-after-entry-create-hook . evil-insert-state)
     (org-journal-mode-hook . aggressive-fill-paragraph-mode))
    :config
    (with-eval-after-load 'org-capture
      (defun my-org-journal-find-location ()
        (org-journal-new-entry t)
        (goto-char (point-min)))
      (add-to-list 'org-capture-templates
                   '("jj" "Personal Journal Entry" entry
                     (function my-org-journal-find-location)
                     "* %(format-time-string org-journal-time-format)%?"))))
#+end_src

* Cmake
#+begin_src emacs-lisp :results output silent
  (use-package cmake-mode
    :straight t
    :mode ("\\cmakelists.txt\\'" . cmake-mode)
    ;; :ensure t ;; the package is nested in the greater cmake repo, and
    ;;           ;; not practical to use straight on (yet)
    :hook (cmake-mode-hook . hl-todo-mode))
#+end_src

** Cmake-font-lock
#+begin_src emacs-lisp :results output silent
  (use-package cmake-font-lock
    ;; :straight (:host github :repo "Lindydancer/cmake-font-lock")
    :straight t
    :hook (cmake-mode-hook . cmake-font-lock-activate))
#+end_src

* TOML mode for org-src
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'org-src
    (cl-pushnew '("toml" . conf-toml) org-src-lang-modes))
#+end_src

* Jira
#+begin_src emacs-lisp :results output silent
  (use-package org-jira
    :defer t
    ;; :straight (:host github :repo "baohaojun/org-jira"))
    :straight t)
#+end_src

* Jupyter Notebook
https://millejoh.github.io/emacs-ipython-notebook/

#+begin_src emacs-lisp :results output silent
  (use-package ein
    :disabled t
    :straight (:host github :repo "millejoh/emacs-ipython-notebook"))
#+end_src

* Focus mode
#+begin_src emacs-lisp :results output silent
  (use-package focus
    ;; :straight (:host github :repo "larstvei/Focus")
    :straight t
    :commands focus-mode
    :init
    (evil-ex-define-cmd "fo[cus]" 'focus-mode))
#+end_src

* Pretty mode
#+begin_src emacs-lisp :results output silent
  (use-package pretty-mode
    ;; :straight (:host github :repo "pretty-mode/pretty-mode")
    :straight t
    :defer t
    :commands (pretty-mode))
    ;; :config
    ;; (global-pretty-mode)
    ;; (global-prettify-symbols-mode))
#+end_src

* Prettify Symbols Mode
Use this instead of pretty mode because it's built in and shouldn't
spaz out as much

#+begin_src emacs-lisp :results output silent
  (global-prettify-symbols-mode)
#+end_src

* Outshine
Doesn't really work out of the box. Interesting idea though, so we're
keeping it until we figure out how to use it properly

#+begin_src emacs-lisp :results output silent
  (use-package outshine
    ;; :straight (:host github :repo "alphapapa/outshine")
    :straight t
    :commands (outshine-mode))
#+end_src

* Org Kanban
This uses a custom org block, so we don't actually have to do anything
more than spell out that block and evaluate it.

#+begin_example
#+BEGIN: kanban :mirrored nil
#+END:
#+end_example

#+begin_src emacs-lisp :results output silent
  (use-package org-kanban
    ;; :straight (:host github :repo "gizmomogwai/org-kanban")
    :straight t
    :defer 10)
#+end_src

* Bookmark+
This is now really expensive, and we need to trim this as much as we
can.

- [ ] Iterate through the list and lazy load the thing instead of
  making it so expensive

#+begin_src emacs-lisp :results output silent
  (use-package bookmark+
    :disabled t
    :preface
    (let ((bookmarkplus-dir (locate-user-emacs-file "local-packages/bookmark-plus/"))
          (emacswiki-base "https://www.emacswiki.org/emacs/download/")
          (bookmark-files '("bookmark+.el" "bookmark+-mac.el" "bookmark+-bmu.el"
                            "bookmark+-key.el" "bookmark+-lit.el" "bookmark+-1.el")))
      (require 'url)
      (add-to-list 'load-path bookmarkplus-dir)
      (make-directory bookmarkplus-dir t)
      (mapcar (lambda (arg)
                (let ((local-file (concat bookmarkplus-dir arg)))
                  (unless (file-exists-p local-file)
                    (url-copy-file (concat emacswiki-base arg) local-file t))))
              bookmark-files)
      (byte-recompile-directory bookmarkplus-dir 0))
    :commands bmkp-bmenu-list)
#+end_src

* Copy as Format
The only reason I'm keeping this and not discarding it is because it's currently
- A monument to my hubris
- Actually a pretty cool attempt at hacking elisp

#+begin_src emacs-lisp :results output silent
  (use-package copy-as-format
    :disabled t
    :straight (:host github :repo "sshaw/copy-as-format")
    :commands (copy-as-format))
   ;;  :init
   ;;  (evil-define-operator as-format (beg end &optional format-specifier)
   ;;    :repeat nil
   ;;    :move-point nil
   ;;    (interactive "<r>")
   ;;    (let ((temp-buffer (generate-new-buffer "copy-as-format-temp")))
   ;;      (copy-to-buffer temp-buffer beg end)
   ;;      (with-current-buffer temp-buffer
   ;;        (mark-whole-buffer)
   ;;        (copy-as-format))))
   ;; (evil-ex-define-cmd "copy-as-format" 'as-format))
#+end_src

* Studlify operator
#+begin_src emacs-lisp :results output silent
  (evil-define-operator evil-studlify (beg end)
    (studlify-region beg end))
#+end_src

#+begin_src emacs-lisp :results output silent
  (general-define-key :keymaps '(normal visual)
    "g S" 'evil-studlify)
#+end_src

Or evil-spongebob if you want to think of it that way.

* Go Mode                                                             :major:
#+begin_src emacs-lisp :results output silent
  (use-package go-mode
    ;; :straight (:host github :repo "dominikh/go-mode.el")
    :straight t
    :mode ("\\.go\\'" . go-mode))
#+end_src

* Elfeed
#+begin_src emacs-lisp :results output silent
  (defconst user-rss-feed-file
    (locate-user-emacs-file "feeds.org")
    "Points to config.org")

  (defun find-user-rss-feed-file ()
    "Edit `user-rss-feed-file' without opening a new window."
    (interactive)
    (find-file user-rss-feed-file))

  (evil-ex-define-cmd "feed[s]" 'find-user-rss-feed-file)
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package elfeed
    :straight (:host github :repo "skeeto/elfeed")
    :if (f-exists? user-rss-feed-file)
    :commands (elfeed)
    :custom
    (elfeed-search-title-max-width
     80
     "Update the max width of the title")
    (elfeed-search-filter
     "@1-day-ago +unread +interesting "
     "The trailing space is so that adding additional tags to filter
     won't be painful.")
    (elfeed-search-date-format
     (list "%F %R" 16 :left)
     "Make the timestamps more useful")
    :general
    (elfeed-show-mode-map
     :states '(normal motion)
     "g O" (lambda ()
             (interactive)
             (let ((browse-url-browser-function 'eww-browse-url))
               (elfeed-show-visit t)))
     "f" 'link-hint-open-link
     "y" 'link-hint-copy-link
     "SPC"   nil
     "<SPC>" nil)
    (elfeed-search-mode-map
     :states '(normal motion)
     "g x"  'elfeed-search-browse-url ;; "g o" also does this in normal mode
     "g r"  'elfeed-search-fetch-visible
     "SPC"   nil
     "<SPC>" nil)
    ;; :hook (elfeed-show-mode-hook . (lambda () (setq-local truncate-lines nil)))
    :init
    (evil-define-command my-custom-elfeed (cmd)
      (interactive "<a>")
      (cond
       ((string= cmd "feeds") (find-user-rss-feed-file))
       ((string= cmd "feed") (find-user-rss-feed-file))
       ((string= cmd "reload") (reload-rss-feed-file))
       ;; ((string= cmd "log") (switch-to-buffer (elfeed-log-buffer)))
       (t (elfeed))))
    (evil-ex-define-cmd "el[feed]" 'my-custom-elfeed)
    :config
    ;; https://mac.into.sh/elfeed/
    (if (not (boundp 'my-syncthing-default-folder))
        (message "Unable to find `my-syncthing-default-folder',
        defaulting to local elfeed db")
      (customize-set-variable 'elfeed-db-directory
                              (f-join my-syncthing-default-folder "elfeed"))
      (elfeed-db-load)
      ;; TODO: trace if this hook... actually exists
      ;; (add-hook 'elfeed-show-mode-hook #'(lambda () (elfeed-search-update 1)))
      (add-hook 'kill-emacs-hook #'elfeed-db-save-safe)))
#+end_src

** Elfeed org
This is really really slow
#+begin_src emacs-lisp :results output silent
  (use-package elfeed-org
    :straight (:host github :repo "remyhonig/elfeed-org")
    :if (f-exists? user-rss-feed-file)
    :after elfeed
    :commands (elfeed-org
               rmh-elfeed-org-process)
    :custom
    (rmh-elfeed-org-files (list (locate-user-emacs-file "feeds.org")))
    :init
    ;; We do it like this because we need this lazy loaded, but called
    ;; *before* `elfeed' is called
    (with-eval-after-load 'elfeed
      (elfeed-org))
    :init
    (defun reload-rss-feed-file ()
      (interactive)
      (rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id)))
#+end_src

** Elfeed goodies
#+begin_src emacs-lisp :results output silent
  ;; (use-package elfeed-goodies
  ;;   :straight (:host github :repo "algernon/elfeed-goodies")
  ;;   :after elfeed
  ;;   :general
  ;;   (elfeed-show-mode-map
  ;;    :states 'normal
  ;;    "f" 'elfeed-goodies/show-ace-link
  ;;    "F" 'elfeed-goodies/show-ace-link)
  ;;   :custom
  ;;   (elfeed-goodies/entry-pane-position 'bottom))
  ;; ;; :config
  ;; ;; (elfeed-goodies/setup)
  ;; ;; (remove-hook 'elfeed-new-entry-hook #'elfeed-goodies/html-decode-title))
#+end_src

** Elfeed Score
#+begin_src emacs-lisp :results output silent
  (use-package elfeed-score
    :straight t
    :after elfeed
    :config (elfeed-score-enable))
#+end_src

** Elfeed Dashboard
#+begin_src emacs-lisp :results output silent
  (use-package elfeed-dashboard
    :after elfeed
    :straight t)
#+end_src

* Info mode
#+begin_src emacs-lisp :results output silent
  ;; (general-define-key
  ;;  :keymaps 'Info-mode-map
  ;;   "f" 'ace-link-info
  ;;   "F" 'ace-link-info)
  (general-define-key
   :keymaps 'Info-mode-map
   :states 'normal
   "f" 'link-hint-open-link
   "]]" 'Info-next
   "[[" 'Info-prev)
#+end_src

* Eww
#+begin_src emacs-lisp :results output silent
  ;; (use-package eww
  ;;   :commands (eww)
  ;;   :if (display-browser-p)
  ;;   :general
  ;;   (:keymaps 'eww-mode-map
  ;;    :states '(normal)
  ;;    "f" 'ace-link-eww
  ;;    "F" 'ace-link-eww))

  (unless (display-graphic-p)
    (customize-set-variable 'browse-url-browser-function 'eww-browse-url))

  (with-eval-after-load 'eww
    (general-define-key
     :keymaps 'eww-mode-map
     :states 'normal
      "g t" nil))

  (evil-define-command my-eww-ex-command (url)
    (interactive "<a>")
    (require 'eww)
    (if url
      (eww url)
      (eww)))

  (evil-ex-define-cmd "eww" 'my-eww-ex-command)
#+end_src
* Hl Block Mode
Wait a bit for the code to mature.

#+begin_src emacs-lisp :results output silent
  (use-package hl-block-mode
    :disabled t
    :straight (:host github :repo "ideasman42/emacs-hl-block-mode"))
#+end_src

* Alert
with =org-pomodoro= playing sounds now (pleasant ones), using the fringe
now becomes too noisy.

#+begin_src emacs-lisp :results output silent
  (use-package alert
    ;; :straight (:host github :repo "jwiegley/alert" :flavor melpa)
    :straight t
    :commands alert)
  ;; :custom
  ;; (alert-default-style 'fringe))
#+end_src

** Windows Alert Toast
#+begin_src emacs-lisp :results output silent
  (use-package alert-toast
    :straight (:host github :repo "gkowzan/alert-toast")
    :if (eq system-type 'windows-nt)
    :after alert)
#+end_src

* Sound-wav
=sound-wav= is used for =org-pomodoro=.

#+begin_src emacs-lisp :results output silent
  (use-package sound-wav
    ;; :straight (:host github :repo "syohex/emacs-sound-wav")
    :straight t
    :commands sound-wav-play)
#+end_src

* Counsel-etags
#+begin_src emacs-lisp :results output silent
  (use-package counsel-etags
    :disabled t ;; using dumb-jump
    :straight (:host github :repo "redguardtoo/counsel-etags")
    :commands (counsel-etags-find-tag-at-point)
    :general
    (:keymaps 'prog-mode-map
     :states 'normal
     "<f12>" 'counsel-etags-find-tag-at-point)
    :custom
    (tags-revert-without-query t)
    (large-file-warning-threshold nil)
    (counsel-etags-tags-program
     "ctags -e -L"
     "Assuming we use *exuberant ctags*")
    (counsel-etags-tags-program
     (lambda (scan)
       (require 'f)
       ;; (let ((scan (if (boundp 'projectile-project-root)
       ;;                 (projectile-project-root)
       ;;                 scan-dir)))
       (message "updating %s" scan)
       (let ((tags-file (counsel-etags-get-tags-file-path scan))
             (command (string-join
                       (list counsel-etags-tags-program
                             ;; "-o" (concat (directory-file-name scan-dir) "/TAGS")
                             (string-join (mapcar (lambda (file)
                                                    (concat "\"" file "\""))
                                                  (f-entries scan))
                                          " "))
                       " ")))
         (message "with command: %s" command)
         (counsel-etags-async-shell-command command tags-file)))
     "Assuming we use exuberant ctags. For some reason `projectile-project-root' binds to emacs.d.")
    :hook
    (prog-mode-hook . (lambda ()
                        (add-hook 'after-save-hook
                                  'counsel-etags-virtual-update-tags
                                  'append 'local))))
#+end_src

* ctags
#+begin_src emacs-lisp :results output silent
  (use-package ctags-update
    :straight (:host github :repo "jixiuf/ctags-update")
    :disabled t
    :hook
    (prog-mode-hook . turn-on-ctags-auto-update-mode)
    :commands (ctags-global-update-mode
               ctags-update
               turn-on-ctags-auto-update-mode))
#+end_src

* Seml-mode
#+begin_src emacs-lisp :results output silent
  (use-package seml-mode
    :defer 20
    ;; :straight (:host github :repo "conao3/seml-mode.el"))
    :straight t)
#+end_src

* Annotations
Might be better done as an ex mode command or something.

This is a very finnicky package

#+begin_src emacs-lisp :results output silent
  (use-package annotate
    :disabled t
    ;; :straight (:host github :repo "bastibe/annotate.el")
    :straight t
    :commands (annotate-save-annotations)
    :custom-face
    (annotate-highlight ((t (:box (:line-width -1)))))
    :custom
    (annotate-summary-ask-query nil)
    (annotate-annotation-position-policy :by-length)
    (annotate-use-echo-area nil)
    :hook
    (after-save-hook . annotate-save-annotations)
    :general
    (:states '(normal visual)
     :prefix my-default-evil-leader-key
                                          ;; "r" for "remember"
     "r r" 'annotate-annotate
     "r m" 'annotate-mode
     "r s" 'annotate-show-annotation-summary)
    (:states '(normal)
     "[ r" 'annotate-goto-previous-annotation
     "] r" 'annotate-goto-next-annotation))
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package annot
    :disabled t ;; trying out annotate.el instead
    :straight (:host github :repo "ghoshi/annot"
               :files (:defaults "src/annot.el"))
    :general
    (:keymaps '(normal visual)
     :prefix my-default-evil-leader-key
     "//" 'annot-edit/add
     "/d" 'annot-remove)
    (:keymaps 'normal
     :prefix my-default-evil-leader-key
     "/n" 'annot-goto-next
     "/N" 'annot-goto-previous
     "/c" 'annot-to-comment))
#+end_src

* Ivy

** Prescient
#+begin_src emacs-lisp :results output silent
  (use-package prescient
    :straight (:host github :repo "raxod502/prescient.el")
    :after ivy
    :config
    (prescient-persist-mode))
#+end_src

** Rich Display
#+begin_src emacs-lisp :results output silent
  (use-package ivy-rich
    :straight (:host github :repo "Yevgnen/ivy-rich")
    :after (ivy counsel)
    :config
    (ivy-rich-mode))
#+end_src

** Posframe
Not tracking master because it's currently broken for some reason.
#+begin_src emacs-lisp :results output silent
  (use-package ivy-posframe
    ;; :straight (:host github :repo "tumashu/ivy-posframe"
    ;;            :files ("ivy-posframe.el"))
    :disabled t
    :straight t
    :after ivy
    :custom
    (ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
    :config
    (ivy-posframe-mode))
#+end_src

* Company
#+begin_src emacs-lisp :results output silent
  (use-package company-mode
    ;; :straight (:host github :repo "company-mode/company-mode")
    :straight t
    :commands (company-mode-on
               company-mode)
    :custom
    (company-tooltip-align-annotations t)
    :general
    (company-active-map
     ;; "RET" 'company-complete-selection
     "C-w" nil) ;; don't override vim controls
    (company-active-map
     :states 'insert
     "RET" 'company-complete-selection)
    ;; :custom
    ;; (company-idle-delay 2)
    :hook
    (prog-mode-hook . company-mode))
#+end_src

** Company Quickhelp
#+begin_src emacs-lisp :results output silent
  (use-package company-quickhelp
    :straight t
    :after company-mode
    :config
    (company-quickhelp-mode))
#+end_src

** Statistics
#+begin_src emacs-lisp :results output silent
  (use-package company-statistics
    :straight t
    :after company-mode
    :config
    (company-statistics-mode))
#+end_src

** Company-math
Doesn't seem to be working?
#+begin_src emacs-lisp :results output silent
  (use-package company-math
    :straight t
    :after company-mode
    :config
    (add-to-list 'company-backends 'company-math-symbols-latex)
    (add-to-list 'company-backends 'company-math-symbols-unicode)
    (add-to-list 'company-backends 'company-latex-commands))
#+end_src

* Flycheck
#+begin_src emacs-lisp :results output silent
  (use-package flycheck
    :straight (:host github :repo "flycheck/flycheck")
    :custom
    (flycheck-indication-mode 'left-margin)
    :custom-face
    (flycheck-error ((t (:underline (:color ,sol-red :style line)))))
    (flycheck-delimited-error ((t (:inherit flycheck-error))))
    (flycheck-info ((t (:underline (:color ,sol-blue :style line)))))
    (flycheck-warning ((t (:underline (:color ,sol-yellow :style line)))))
    (flycheck-fringe-error ((((background light)) (:background ,sol-base3 :foreground ,sol-red))
                            (((background dark)) (:background ,sol-base03 :foreground ,sol-red))))
    (flycheck-fringe-info ((((background light)) (:background ,sol-base3 :foreground ,sol-blue))
                           (((background dark)) (:background ,sol-base03 :foreground ,sol-blue))))
    (flycheck-fringe-warning ((((background light)) (:background ,sol-base3 :foreground ,sol-yellow))
                              (((background dark)) (:background ,sol-base03 :foreground ,sol-yellow))))
    :hook
    (prog-mode-hook . global-flycheck-mode))
#+end_src

** Flycheck Inline
#+begin_src emacs-lisp :results output silent
  (use-package flycheck-inline
    :straight t
    :hook
    (flycheck-mode-hook . flycheck-inline-mode))
#+end_src

* Language Server Protocol (LSP)

** eglot
#+begin_src emacs-lisp :results output silent
  (use-package eglot
    :straight (:host github :repo "joaotavora/eglot")
    :commands (eglot eglot-ensure)
    :general
    (eglot-mode-map
     :states '(normal visual)
     "K" nil
     "M-K" 'eldoc-doc-buffer))
    ;; :hook
    ;; ((c-mode-hook . eglot-ensure)
    ;;  (c++-mode-hook . eglot-ensure)))
#+end_src

** lsp-mode
#+begin_src emacs-lisp :results output silent
  (use-package lsp-mode
    :straight t
    :commands (lsp lsp-deferred)
    :config
    ;; this is necessary since `lsp-command-map' is not autoloadable
    (general-define-key
     :states 'normal
     :prefix my-default-evil-leader-key
     "l" lsp-command-map))
        ;; (lsp-mode-map
        ;;  :states 'normal
        ;;  :prefix my-default-evil-leader-key
        ;;   "l a a" 'lsp-execute-code-action))
#+end_src

*** lsp-ui
#+begin_src emacs-lisp :results output silent
  (use-package lsp-ui
    :disabled t
    :after lsp-mode
    :straight t
    :general
    (lsp-ui-mode-map
     [remap xref-find-definitions] #'lsp-ui-peek-find-definitions
     ;; [remap xref-find-references] #'lsp-ui-peek-find-references
     "C-," #'lsp-ui-peek-find-references)
    (lsp-ui-peek-mode-map
     "j" 'lsp-ui-peek--select-next
     "k" 'lsp-ui-peek--select-prev)
    :custom-face
    ;; (lsp-ui-peek-footer ((t (:foreground "b58900" :background "b58900")))))
    (lsp-ui-peek-footer ((t (:inherit 'evil-ex-substitute-matches))))
    (lsp-ui-peek-header ((t (:inherit 'lsp-ui-peek-footer))))
    (lsp-ui-peek-highlight ((t (:inherit 'lsp-ui-peek-footer))))
    (lsp-ui-peek-selection ((t (:inherit 'evil-ex-substitute-matches))))
    :custom
    (lsp-ui-sideline-enable nil)
    (lsp-ui-peek-peek-height 23))
#+end_src

*** Debug Adapter Mode (dap-mode)
#+begin_src emacs-lisp :results output silent
  (use-package dap-mode
    :after lsp-mode
    :straight t
    :commands (dap-debug)
    :hook
    (dap-stopped-hook . (lambda (arg)
                          (call-interactively #'dap-hydra))))
#+end_src

*** lsp-ivy
#+begin_src emacs-lisp :results output silent
  (use-package lsp-ivy
    :straight t
    :commands (lsp-ivy-workspace-symbol
               lsp-ivy-global-workspace-symbol)
    :after lsp-mode)
#+end_src
* Code Folding (Origami)
#+begin_src emacs-lisp :results output silent
  (use-package origami
    :straight (:host github :repo "gregsexton/origami.el")
    :after evil
    :defer 2
    :general
    (:states 'normal
     "zm" 'origami-close-all-nodes
     "zr" 'origami-open-all-nodes
     "zc" 'origami-close-node
     "zC" 'origami-close-node-recursively
     "zo" 'origami-open-node
     "zO" 'origami-open-node-recursively
     "za" 'origami-recursively-toggle-node
     "zj" 'origami-forward-fold
     "zk" #'(lambda () (interactive)
              (call-interactively 'origami-previous-fold)
              (call-interactively 'origami-next-fold))
     "[z" 'origami-previous-fold
     "]z" 'origami-next-fold)
    :hook
    (prog-mode-hook . origami-mode)
    :config
    (global-origami-mode))
#+end_src

** Vimish Fold
We might want to write an operator from this (look up :h zf), since it
does not seem to be actually performing syntax-based folding

Another thing to consider is how this overlay method will
integrate/interfere with origami-mode.
#+begin_src emacs-lisp :results output silent
  (use-package vimish-fold
    :straight (:host github :repo "mrkkrp/vimish-fold")
    :disabled t
    :after evil
    :config
    (vimish-fold-global-mode))
#+end_src

* Rot13
Note that while the buffer will look rot13 encrypted, the final saved
file will not itself be encrypted.

#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "rot[13]" 'toggle-rot13-mode)
#+end_src

* PlantUML mode
[[http://plantuml.com/index][Reference]]

#+begin_src emacs-lisp :results output silent
  (use-package plantuml-mode
    :straight (:host github :repo "skuro/plantuml-mode")
    :commands (plantuml-mode)
    :custom
    (plantuml-output-type "txt"
                          "Display using glorious text")
    (plantuml-default-exec-mode 'executable)
    :mode "\\.plantuml\\'"
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("plantuml" . plantuml) org-src-lang-modes)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (customize-set-value 'org-plantuml-exec-mode 'plantuml)
  (org-babel-do-load-languages 'org-babel-load-languages
                               (add-to-list 'org-babel-load-languages '(plantuml . t)))
#+end_src
* Hex conversion
#+begin_src emacs-lisp :results output silent
  (use-package 0xc
    :straight (:host github :repo "AdamNiederer/0xc")
    :commands (0xc-convert
               0xc-convert-point))
#+end_src

* Zeal documentation at point
#+begin_src emacs-lisp :results output silent
  (use-package zeal-at-point
    :disabled t ;; using defengine
    :straight (:host github :repo "jinzhu/zeal-at-point")
    :commands zeal-at-point)
#+end_src

* Edn format
This is closer to the json serialization/deserialization module.

#+begin_src emacs-lisp :results output silent
  (use-package edn
    :straight (:host github :repo "expez/edn.el")
    :commands (edn-read
               edn-print-string))
#+end_src

* Novel reading
#+begin_src emacs-lisp :results output silent
  (use-package nov
    :straight (:host github :repo "wasamasa/nov.el")
    :mode ("\\.epub\\'" . nov-mode))
#+end_src
* Glasses-mode
Converts between camelCase and snake_case visually, without changing
the underlying format
* Hexl-mode

* Fill Column Indicator (fci)
Note that this makes origami-mode look pretty ugly (origami-mode's
trailing dots only happen /after/ the fci column.)
#+begin_src emacs-lisp :results output silent
  (use-package fill-column-indicator
    :disabled t ;; use display-fill-column-indicator
    :straight (:host github :repo "alpaker/fill-column-indicator")
    :commands (fci-mode)
    :custom
    (fci-rule-use-dashes (not (display-graphic-p)))
    (fci-always-use-textual-rule (not (display-graphic-p)))
    :hook
    (prog-mode-hook . fci-mode)
    :config
    (defun my-restart-fci-mode (&rest _args)
      (interactive)
      (global)
      "Turns fci-mode on and off for every buffer that has it on."
      (dolist (buffer (buffer-list))
        (with-current-buffer buffer
          (when fci-mode
            (fci-mode -1)
            (fci-mode 1))))))
    ;; Something's wrong with this
    ;; (advice-add 'load-theme :after 'my-restart-fci-mode))
#+end_src

* Devdocs
#+begin_src emacs-lisp :results output silent
  (use-package devdocs
    :disabled t ;; because we don't really use it
    :straight (:host github :repo "skeeto/devdocs-lookup")
    :commands (devdocs-lookup)
    :custom
    (evil-lookup-func #'(lambda ()
                         (call-interactively 'devdocs-lookup)))
    :config
    (devdocs-setup))
#+end_src

* todotxt
#+begin_src emacs-lisp :results output silent
  (use-package todotxt
    :straight (:host github :repo "rpdillon/todotxt.el")
    :commands todotxt)
#+end_src

* Persistent scratch
#+begin_src emacs-lisp :results output silent
  (use-package persistent-scratch
    :straight (:host github :repo "Fanael/persistent-scratch")
    :disabled t ;;  6 seconds to load lmao
    :config
    (persistent-scratch-setup-default))
#+end_src

* COMMENT Smerge vimdiff bindings
Not using this because we're going to try ediff
#+begin_src emacs-lisp :results output silent
  (general-define-key
   :states '(normal motion)
   :keymaps 'smerge-mode-map
    "dp" 'smerge-keep-lower
    "do" 'smerge-keep-upper
    "[c" 'smerge-next
    "]c" 'smerge-prev)
#+end_src

* Search Engine Mode
#+begin_src emacs-lisp :results output silent
  (use-package engine-mode
    ;; :straight (:host github :repo "hrs/engine-mode" :branch "main")
    :straight t
    :commands defengine
    :init
    (evil-define-command my-ddg-search (args)
      (interactive "<a>")
      (require 'engine-mode)
      (unless (boundp 'engine/search-duckduckgo)
        (defengine duckduckgo
          "https://duckduckgo.com/?q=%s"))
      (let ((query (if (use-region-p)
                       (buffer-substring (region-beginning) (region-end))
                     (read-string
                      "Search: "
                      nil nil (thing-at-point 'word)))))
        (engine/search-duckduckgo query)))
    ;; something's wrong here.
    ;; (evil-ex-define-cmd "??" 'my-ddg-search)
    :general
    (:states '(normal motion visual)
     "K" 'my-ddg-search))
#+end_src

* Lorem Ipsum
#+begin_src emacs-lisp :results output silent
  (use-package lorem-ipsum
    :straight t
    :commands
    (lorem-ipsum-insert-paragraphs
     lorem-ipsum-insert-sentences
     lorem-ipsum-insert-list)
    :init
    ;; stolen from
    ;; https://github.com/alphapapa/unpackaged.el#obfuscate-buffer-text-with-lorem-ipsum-words
    ;; and slightly modified to accomodate textobjects
    ;;;###autoload
    (evil-define-command loremify (beg end)
      "Overlay all text in current buffer with \"lorem ipsum\" text.
      When called again, remove overlays.  Useful for taking
      screenshots without revealing buffer contents."
      (interactive "<r>")
      (require 'lorem-ipsum)
      (let* ((min (if beg beg (point-min)))
             (max (if end end (point-max)))
             (ovs (overlays-in min max)))
        (if (cl-loop for ov in ovs
                     thereis (overlay-get ov :lorem-ipsum-overlay))
            ;; Remove overlays.
            (dolist (ov ovs)
              (when (overlay-get ov :lorem-ipsum-overlay)
                (delete-overlay ov)))
          ;; Add overlays.
          (let ((lorem-ipsum-words (--> lorem-ipsum-text
                                        -flatten (apply #'concat it)
                                        (split-string it (rx (or space punct)) 'omit-nulls)))
                (case-fold-search nil))
            (cl-labels ((overlay-match ()
                                       (let* ((beg (match-beginning 0))
                                              (end (match-end 0))
                                              (replacement-word (lorem-word (match-string 0)))
                                              (ov (make-overlay beg end)))
                                         (when replacement-word
                                           (overlay-put ov :lorem-ipsum-overlay t)
                                           (overlay-put ov 'display replacement-word))))
                        (lorem-word (word)
                                    (let* ((length (length word)))
                                      (cl-loop for liw in lorem-ipsum-words
                                               when (= length (length liw))
                                               collect liw into matches
                                               finally return
                                               (when matches
                                                 (apply-case word (downcase (seq-random-elt matches)))))))
                        (apply-case (source target)
                                    (cl-loop for sc across-ref source
                                             for tc across-ref target
                                             when (not (string-match-p (rx lower) (char-to-string sc)))
                                             do (setf tc (string-to-char (upcase (char-to-string tc)))))
                                    target))
              (save-excursion
                (goto-char min)
                (while (re-search-forward (rx (1+ alpha)) max t)
                  (overlay-match)))))))))
#+end_src

* Pomodoro
** Pomidor
#+begin_src emacs-lisp :results output silent
  (use-package pomidor
    :straight (:host github :repo "TatriX/pomidor")
    :commands pomidor
    :general
    (pomidor-mode-map
     :states '(visual normal motion)
      "RET" 'pomidor-stop
      "SPC" 'pomidor-break)
    :custom-face
    (pomidor-break-face ((t (:inherit 'font-lock-function-name-face))))
    :custom
    (pomidor-sound-tick nil)
    (pomidor-sound-tack nil)
    (pomidor-sound-overwork
     (expand-file-name (locate-user-emacs-file "notification1.wav")))
    (pomidor-sound-break-over
     (expand-file-name (locate-user-emacs-file "notification2.wav")))
    :init
    (evil-ex-define-cmd "pomo[doro]" 'pomidor))
#+end_src

** Org pomodoro
:LOGBOOK:
CLOCK: [2019-05-06 Mon 14:02]--[2019-05-06 Mon 14:27] =>  0:25
:END:

=mode-line-misc-info= is where the pomodoro is placed.

It is behind =mode-line-modes= and if we want the pomodoro to be
infront, we need to alter it there

I think we should put =mode-line-format= just behind =evil-mode-line-tag=,
or (vc-mode)

We can use the following to insert =org-pomodoro-mode-line= at
whereever we like on the modeline.

The string seems to be inserted into the modeline once, and then set
to an empty string when not in use (it so appears anyway).

We can override the insertion checks everytime =org-pomodoro-start= is
called, and it should work anywhere.

# #+begin_src emacs-lisp :eval no-export
#   (-insert-at
#     (-find-index (lambda (sym)
#                    (eq sym 'evil-mode-line-tag))
#                  mode-line-format)
#     'org-pomodoro-mode-line mode-line-format)
# #+end_src

#+begin_src emacs-lisp :results output silent
  (use-package org-pomodoro
    :straight (:host github :repo "lolownia/org-pomodoro"
               :files (:defaults ("resources/" "resources/*")))
    :commands (org-pomodoro)
    :custom
    (org-pomodoro-manual-break t)
    ;; guild wars 2 has some excellent notification sounds
    ;; For some reason they need an absolute path
    (org-pomodoro-overtime-sound
     (expand-file-name (locate-user-emacs-file "notification1.wav")))
    (org-pomodoro-short-break-sound
     (expand-file-name (locate-user-emacs-file "notification2.wav")))
    (org-pomodoro-long-break-sound
     (expand-file-name (locate-user-emacs-file "notification3.wav")))
    (org-pomodoro-finished-sound nil)
    :init
    (evil-define-command my-pomodoro-start (&optional arg)
      "Starts a pomodoro with the current headline, or the last pomodoro
  if ! is provided."
      (interactive "<!>")
      (let ((prev_clock (when arg '(16))))
        (org-pomodoro prev_clock)))
    (evil-ex-define-cmd "do" 'my-pomodoro-start)
    (evil-ex-define-cmd "done"
                        #'(lambda () (interactive)
                            (require 'org-pomodoro)
                            (cond
                             ((equal org-pomodoro-state :overtime)
                              (org-pomodoro))
                             ((org-pomodoro-active-p)
                              (org-pomodoro-kill)))))
    :config
    (customize-set-variable
     'mode-line-format
     (list "%e" mode-line-front-space mode-line-mule-info
           mode-line-client mode-line-modified mode-line-auto-compile
           mode-line-remote mode-line-frame-identification
           mode-line-buffer-identification " " mode-line-position
           evil-mode-line-tag mode-line-misc-info '(vc-mode vc-mode) " "
           mode-line-modes mode-line-end-spaces)))
  ;; :config
  ;;   (advice-add 'org-pomodoro-start
  ;;               :after
  ;;               #'(lambda (&rest _)
  ;;                   "Attempt to make the modeline come first, instead of
  ;; behind the minor modes"
  ;;                   (when (and global-mode-string
  ;;                              (memq 'org-pomodoro-mode-line
  ;;                                    global-mode-string))
  ;;                     (delq 'org-pomodoro-mode-line global-mode-string)
  ;;                     (setq global-mode-string
  ;;                           (append '(org-pomodoro-mode-line)
  ;;                                   global-mode-string)))))
#+end_src


Note that =customize-set-variable= is like =setq-default=.
* Smooth Scrolling
#+begin_src emacs-lisp :results output silent
  (use-package smooth-scrolling
    :straight (:host github :repo "aspiers/smooth-scrolling")
    :commands smooth-scrolling-mode)
#+end_src

* Link hinting
#+begin_src emacs-lisp :results output silent
  (use-package link-hint
    :straight t
    :commands (link-hint-open-link
               link-hint-copy-link))
#+end_src

* Dashboard
#+begin_src emacs-lisp :results output silent
  (use-package dashboard
    :disabled t
    :straight t
    :custom
    (dashboard-items '((agenda)
                       (projects . 20)
                       (bookmarks . 10)
                       (recents . 5)))
    (show-week-agenda-p t)
    ;; (dashboard-startup-banner (locate-user-emacs-file "arbeit-macht-frei.png"))
    (dashboard-startup-banner nil)
    (dashboard-footer "Work sets you free.")
    :config
    (dashboard-setup-startup-hook)
    (my-evil-define-split-vsplit-cmd "dash[board]"
                                     #'(lambda () (interactive)
                                         (switch-to-buffer "*dashboard*")))
    (with-eval-after-load 'eyebrowse
      (evil-ex-define-cmd "Tdash[board]"
                          #'(lambda () (interactive)
                              (require 'eyebrowse)
                              (let ((eyebrowse-new-workspace "*dashboard*"))
                                (eyebrowse-create-window-config))))))
#+end_src

* Highlight Indent Guides
#+begin_src emacs-lisp :results output silent
  (use-package highlight-indent-guides
    :straight t
    :commands (highlight-indent-guides-mode)
    :custom
    (highlight-indent-guides-method 'character)
    (highlight-indent-guides-character ?\|)
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "|" 'highlight-indent-guides-mode))
#+end_src

* EditorConfig
#+begin_src emacs-lisp :results output silent
  (use-package editorconfig
    :hook
    (prog-mode-hook . editorconfig-mode))
#+end_src

* Web mode
#+begin_src emacs-lisp :results output silent
  (use-package web-mode
    :straight t
    :if (< emacs-major-version 27)
    :commands web-mode)
#+end_src

* C# Mode
#+begin_src emacs-lisp :results output silent
  (use-package csharp-mode
    :straight (:host github :repo "josteink/csharp-mode")
    :commands (csharp-mode)
    :mode "\\.cs\\'")
#+end_src

* Fill Function Argument
#+begin_src emacs-lisp :results output silent
  (use-package fill-function-arguments
    :straight (:host github :repo "davidshepherd7/fill-function-arguments")
    :commands (fill-function-arguments-dwim)
    :custom (fill-function-arguments-indent-after-fill t)
    :general
    (:states 'normal
     "g *" 'fill-function-arguments-dwim))
#+end_src

* Spotify (now Smudge)
#+begin_src emacs-lisp :results output silent
  (use-package smudge
    :straight (:host github :repo "danielfm/smudge")
    ;; :straight t
    :if (and (boundp 'my-spotify-oauth2-client-secret)
             (boundp 'my-spotify-oauth2-client-id))
    :custom
    (smudge-oauth2-client-secret my-spotify-oauth2-client-secret)
    (smudge-oauth2-client-id my-spotify-oauth2-client-id))
#+end_src

* Tree Sitter
#+begin_src emacs-lisp :results output silent
  (use-package tree-sitter
    :disabled t ;; font lock is very buggy
    :hook ((c++-mode-hook . tree-sitter-mode)
           (tree-sitter-after-on-hook . tree-sitter-hl-mode))
    :custom-face
    (tree-sitter-hl-face:type.builtin ((t (:inherit 'tree-sitter-hl-face:keyword))))
    :config
    (use-package tree-sitter-langs))
#+end_src

* Scratch
Not persistent scratch, just a custom scratch buffer
#+begin_src emacs-lisp :results output silent
  (use-package scratch
    :straight t
    :commands scratch
    :init
    (evil-define-command my-scratch (&optional bang)
      (interactive "<!>")
      (if bang
          (let ((current-prefix-arg 4))
            (call-interactively 'scratch))
        (call-interactively 'scratch)))
    (evil-ex-define-cmd "sc[ratch]" 'my-scratch))
#+end_src

* Compiler Explorer
#+begin_src emacs-lisp :results output silent
  (use-package compiler-explorer
    :straight (:host github :repo "mkcms/compiler-explorer.el")
    :commands (compiler-explorer))
#+end_src

* Emacs-sourcetrail
#+begin_src emacs-lisp :results output silent
  (use-package emacs-sourcetrail
    :straight (:host github :repo "CoatiSoftware/emacs-sourcetrail")
    :init
    (defun my-sourcetrail-adjust-point ()
      "`sourcetrail-send-location' needs the point to be at the end of
  the symbol being sent. Otherwise it'll somehow link to the file
  instead."
      (interactive)
      (save-excursion
        (end-of-thing 'word)
        (sourcetrail-send-location)))
    :general
    (:states '(normal visual)
     "C-?" 'my-sourcetrail-adjust-point)
    :config
    (sourcetrail-mode))
#+end_src

* Macrostep
#+begin_src emacs-lisp :results output silent
  (use-package macrostep
    :straight t
    :commands (macrostep-expand))
#+end_src

* Buttercup (Emacs Test Framework)
#+begin_src emacs-lisp :results output silent
  (use-package buttercup
    :straight t
    :defer t) ;; uncomment when we actually need this
#+end_src

* Typit
#+begin_src emacs-lisp :results output silent
  (use-package typit
    :straight t
    :commands
    (typit-basic-test
     typit-advanced-test
     typit-test))
#+end_src

* Compilation Mode
#+begin_src emacs-lisp :results output silent
  (use-package compile
    :straight nil
    :ensure nil
    :custom
    (compilation-auto-jump-to-first-error nil)
    :general
    (compilation-mode-map
     :states 'normal
     "]]" 'compilation-next-error
     "[[" 'compilation-previous-error)
    :init
    (defun my-colorize-completion-buffer ()
      (require 'ansi-color)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region compilation-filter-start (point))))
    :hook
    (compilation-filter-hook . my-colorize-completion-buffer))
#+end_src

* Project mode
#+begin_src emacs-lisp :results output silent
  (use-package project
    :ensure nil
    :straight nil
    :init
    (advice-add 'evil-make :before
                #'(lambda (&rest _) (require 'project)))
    :config
    (with-eval-after-load 'ivy
      (general-define-key
       :keymaps 'project-prefix-map
       "c" 'counsel-compile)
      (with-eval-after-load 'savehist
        (add-to-list 'savehist-additional-variables 'counsel-compile-history)))
    (with-eval-after-load 'rg
      (general-define-key
       :keymaps 'project-prefix-map
       "g" 'rg-project)))
      ;; (cl-letf (((symbol-function 'compile) #'counsel-compile))
      ;;   (project-compile)))
#+end_src

* Calendar Mode
#+begin_src emacs-lisp :results output silent
  (use-package calendar
    :ensure nil
    :straight nil
    :custom
    (calendar-week-start-day 1 "monday"))
#+end_src

* Hydras
#+begin_src emacs-lisp :results output silent
  (use-package hydra
    :straight t)
#+end_src

* Calibre
#+begin_src emacs-lisp :results output silent
  (use-package calibredb
    :straight t)
#+end_src

* explain-pause-mode
#+begin_src emacs-lisp :results output silent
  (use-package explain-pause-mode
    :straight (:host github :repo "lastquestion/explain-pause-mode")
    :disabled t
    :config
    (explain-pause-mode))
  #+end_src

* devdocs
#+begin_src emacs-lisp :results output silent
  (use-package devdocs
    :straight (:host github :repo "blahgeek/emacs-devdocs-browser")
    :commands
    (devdocs-browser-open
     devdocs-browser-open-in
     devdocs-browser-list-docs
     devdocs-browser-update-docs
     devdocs-browser-install-doc
     devdocs-browser-uninstall-doc
     devdocs-browser-upgrade-doc
     devdocs-browser-download-offline-data
     devdocs-browser-remove-offline-data)
    :init
    (evil-ex-define-cmd "dd" 'devdocs-browser-open))
#+end_src

* Evaluation Result Overlay for Emacs Lisp
#+begin_src emacs-lisp :results output silent
  (use-package eros
    :straight t
    :config
    (eros-mode))
#+end_src
