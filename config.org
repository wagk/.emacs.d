#+TITLE: Emacs Configuration

* Introduction
  Configuration settings for my Emacs

  The intent is for this file to take over most of the configuration while leaving
  the most critical configurations to a bootstrap file (or files).

  Note that the tangling process first dumps everything into one =.el= file, so
  each src block, while recommended to be self-contained evaluable elisp, doesn't
  actually have to be. It is possible to split into multiple elisp src blocks.

  A few things MUST be assumed:
  - The following code blocks *MUST* be executed in order
  - This code block isn't compiled

  #+BEGIN_SRC emacs-lisp
    (require 'config-bootstrap)
  #+END_SRC

* Developer Libraries
  Packages that are useful for development but might not actually make the emacs
  user experience nice.

** CL
   Common Lisp library

   #+BEGIN_SRC emacs-lisp

     (with-no-warnings
       (require 'cl))

   #+END_SRC

** Dash
   Utility library

   #+BEGIN_SRC emacs-lisp
     (use-package dash)
   #+END_SRC

** S

   #+BEGIN_SRC emacs-lisp
    (use-package s)
   #+END_SRC

** F

   #+BEGIN_SRC emacs-lisp
    (use-package s)
   #+END_SRC

** Async

   #+BEGIN_SRC emacs-lisp
     (use-package async)
   #+END_SRC

** Names
   - Github :: https://github.com/Malabarba/names


   Namespacing libary

   #+BEGIN_SRC emacs-lisp
     (use-package names)
   #+END_SRC

** Other Helper Functions
   #+BEGIN_SRC emacs-lisp

    (defun my-find-parent-major-modes ()
      "docstring for my-find-parent-major-modes"
      (let ((parents (list major-mode)))
        (while (get (car parents) 'derived-mode-parent)
          (push (get (car parents) 'derived-mode-parent) parents))
        parents))

   #+END_SRC

* Key Variables
  Some of these variables come from =local.el= and would be used later on by
  other configurations. It's critical that these constants are defined as early
  as possible.

** Default Org Directory

   #+BEGIN_SRC emacs-lisp

     (defconst my-org-directory
       (file-name-as-directory
        (if (boundp '/dropbox-folder)
            (concat (directory-file-name /dropbox-folder) "/org")
          "~/org"))
       "orgmode directory."
       )

   #+END_SRC

** Default Notes Directory

   #+BEGIN_SRC emacs-lisp

     (defconst my-notes-directory
       (file-name-as-directory
        (if (boundp '/dropbox-folder)
            (concat (directory-file-name /dropbox-folder) "/notes")
          "~/notes"))
       "Notes directory. Mostly used for `deft-directory'.
     This is different from the org-directory because these documents are more for
     snippets and smaller things"
       )

   #+END_SRC

** Default Wiki Directory

   #+BEGIN_SRC emacs-lisp

    (defconst my-wiki-directory
      (file-name-as-directory
       (if (boundp '/dropbox-folder)
           (concat (directory-file-name /dropbox-folder) "/wiki")
         "~/wiki"))
      "Used for org-brain. This is basically the wiki directory"
      )

   #+END_SRC

* TODO Color
  #+BEGIN_SRC emacs-lisp

    (customize-set-variable 'frame-background-mode 'dark)
    (set-terminal-parameter nil 'background-mode 'dark)

    ;; (use-package base16-theme
    ;;   :if (not (display-graphic-p))
    ;;   :config
    ;;   (load-theme 'base16-solarized-dark t))

    ;; (use-package moe-theme
    ;;   :demand t
    ;;   :if (not (display-graphic-p))
    ;;   :config
    ;;   (moe-dark))

    ;; (use-package color-theme-solarized
    ;;   :demand t
    ;;   ;; :if (display-graphic-p)
    ;;   :config
    ;;   (color-theme-solarized)
    ;;   (setq solarized-termcolors 256)
    ;;   (load-theme 'solarized t)
    ;;   )

    (use-package solarized-theme
      :demand t
      ;; :if (display-graphic-p)
      :config
      (setq solarized-use-variable-pitch nil
            solarized-distinct-fringe-background nil
            solarized-high-contrast-mode-line nil
            solarized-use-less-bold t
            solarized-use-more-italic nil
            solarized-scale-org-headlines nil
            solarized-height-minus-1 1.0
            solarized-height-plus-1 1.0
            solarized-height-plus-2 1.0
            solarized-height-plus-3 1.0
            solarized-height-plus-4 1.0
            )
      (load-theme 'solarized-dark t))

    (defconst $solarized-dark-base03   "#002b36")
    (defconst $solarized-dark-base02   "#073642")
    (defconst $solarized-dark-base01   "#586e75")
    (defconst $solarized-dark-base00   "#657b83")
    (defconst $solarized-dark-base0    "#839496")
    (defconst $solarized-dark-base1    "#93a1a1")
    (defconst $solarized-dark-base2    "#eee8d5")
    (defconst $solarized-dark-base3    "#fdf6e3")
    (defconst $solarized-dark-yellow   "#b58900")
    (defconst $solarized-dark-orange   "#cb4b16")
    (defconst $solarized-dark-red      "#dc322f")
    (defconst $solarized-dark-magenta  "#d33682")
    (defconst $solarized-dark-violet   "#6c71c4")
    (defconst $solarized-dark-blue     "#268bd2")
    (defconst $solarized-dark-cyan     "#2aa198")
    (defconst $solarized-dark-green    "#859900")

    ;; set background to default terminal one if in terminal
    ;; We only get away with this because our terminal uses solarized
    ;; https://stackoverflow.com/questions/19054228/emacs-disable-theme-background-color-in-terminal
    (add-to-list 'after-make-frame-functions
                 '(lambda (frame)
                    (unless (display-graphic-p frame)
                      (set-face-background 'default
                                           "unspecified-bg"
                                           frame))))
    (add-hook 'window-setup-hook
              '(lambda ()
                 (unless (display-graphic-p (selected-frame))
                   (set-face-background 'default
                                        "unspecified-bg"
                                        (selected-frame)))))

  #+END_SRC
* TODO Evil
  #+BEGIN_SRC emacs-lisp

    ;; activate folding
    (add-hook 'prog-mode-hook 'hs-minor-mode)
    ;; (evil-mode)

    (use-package evil-collection
      :after (evil)
      :demand t
      :custom
      (evil-want-integration nil)
      :config
      ;;NOTE: note that this REQUIRES the var `evil-want-integration' to be NIL
      (evil-collection-init))

    ;; Note that all the evil flags are documented in `evil.info' in the evil
    ;; directory
    (use-package evil
      :demand t
      :general
      (:keymaps 'insert
       "C-u"    'kill-whole-line
       "C-l"    'evil-complete-next-line
       "C-L"    'evil-complete-previous-line
       "C-p"    'evil-complete-next
       "C-n"    'evil-complete-previous
       "C-k"    nil)
      (:keymaps 'motion
       "C-u"    'evil-scroll-up)
      (:keymaps 'normal
       "Y"      '/evil-copy-to-end-of-line
       "gt"     '/evil-gt
       "gT"     '/evil-gT
       "C-\\"   '/lang-toggle ;; binding for eng <-> jap
       "g o"    'ff-find-other-file
       "g a"    'describe-char)
      (:keymaps 'visual
       ">>"     '/evil-shift-right-visual
       "<<"     '/evil-shift-left-visual)
      (:keymaps 'inner
       "/"      '/inner-forward-slash
       "l"      'my-evil-inner-line)
      (:keymaps 'outer
       "e"      'my-evil-a-buffer
       "l"      'my-evil-a-line
       "/"      '/a-forward-slash)
      (:keymaps 'minibuffer-local-map
       "C-w"    'backward-kill-word)
      :custom
      (evil-want-C-u-scroll t
                            "Emacs uses `C-u' for its `universal-argument' function.
                                It conflicts with scroll up in evil-mode")
      (evil-want-integration nil
                             "`evil-collections' demands that this be disabled to
                                 work")
      :config

      ;; TODO: figure out this
      ;; https://github.com/syl20bnr/spacemacs/issues/5070
        ;;;###autoload
      (defun /evil-paste-after-from-0 ()
        "I legitimately forgot what this does.
        Probably copied it from stackoverflow"
        (interactive)
        (let ((evil-this-register ?0))
          (call-interactively 'evil-paste-after)))

        ;;;###autoload
      (defun /treat-underscore-as-word ()
        "Make underscore be considered part of a word, just like vim.
        Add this to whichever mode you want when you want it to treat underscore as a
        word"
        (modify-syntax-entry ?_ "w"))

        ;;;###autoload
      (defun /evil-gt ()
        "Emulating vim's `gt' using frames."
        (interactive)
        (other-frame 1))

        ;;;###autoload
      (defun /evil-gT ()
        "Emulating vim's `gT' using frames."
        (interactive)
        (other-frame -1))

        ;;;###autoload
      (defun /lang-toggle ()
        "Input language toggle wrapper."
        (interactive)
        (toggle-input-method)
        ;; (evil-append 1)
        )

      ;; Overload shifts so that they don't lose the selection
        ;;;###autoload
      (defun /evil-shift-left-visual ()
        "Keep visual selection after shifting left."
        (interactive)
        (evil-shift-left (region-beginning) (region-end))
        (evil-normal-state)
        (evil-visual-restore))

        ;;;###autoload
      (defun /evil-shift-right-visual ()
        "Same as /evil-shift-left-visual, but for the right instead."
        (interactive)
        (evil-shift-right (region-beginning) (region-end))
        (evil-normal-state)
        (evil-visual-restore))

        ;;;###autoload
      (defun evil-unimpaired//find-relative-filename (offset)
        (when buffer-file-name
          (let* ((directory (f-dirname buffer-file-name))
                 (files (f--files directory (not (s-matches? "^\\.?#" it))))
                 (index (+ (-elem-index buffer-file-name files) offset))
                 (file (and (>= index 0) (nth index files))))
            (when file
              (f-expand file directory)))))

        ;;;###autoload
      (defun evil-unimpaired/previous-file ()
        (interactive)
        (-if-let (filename (evil-unimpaired//find-relative-filename -1))
            (find-file filename)
          (user-error "No previous file")))

        ;;;###autoload
      (defun evil-unimpaired/next-file ()
        (interactive)
        (-if-let (filename (evil-unimpaired//find-relative-filename 1))
            (find-file filename)
          (user-error "No next file")))

        ;;;###autoload
      (defun evil-unimpaired/paste-above ()
        (interactive)
        (evil-insert-newline-above)
        (evil-paste-after 1))

        ;;;###autoload
      (defun evil-unimpaired/paste-below ()
        (interactive)
        (evil-insert-newline-below)
        (evil-paste-after 1))

        ;;;###autoload
      (defun evil-unimpaired/insert-space-above (count)
        (interactive "p")
        (dotimes (_ count) (save-excursion (evil-insert-newline-above))))

        ;;;###autoload
      (defun evil-unimpaired/insert-space-below (count)
        (interactive "p")
        (dotimes (_ count) (save-excursion (evil-insert-newline-below))))

        ;;;###autoload
      (defun evil-unimpaired/next-frame ()
        (interactive)
        (/evil-gt))

        ;;;###autoload
      (defun evil-unimpaired/previous-frame ()
        (interactive)
        (/evil-gT))

      ;; from tpope's unimpaired
      (define-key evil-normal-state-map (kbd "[ SPC")
        'evil-unimpaired/insert-space-above)
      (define-key evil-normal-state-map (kbd "] SPC")
        'evil-unimpaired/insert-space-below)
      ;; (define-key evil-normal-state-map (kbd "[ e") 'move-text-up)
      ;; (define-key evil-normal-state-map (kbd "] e") 'move-text-down)
      (define-key evil-visual-state-map (kbd "[ e") ":move'<--1")
      (define-key evil-visual-state-map (kbd "] e") ":move'>+1")
      ;; (define-key evil-visual-state-map (kbd "[ e") 'move-text-up)
      ;; (define-key evil-visual-state-map (kbd "] e") 'move-text-down)
      (define-key evil-normal-state-map (kbd "[ b") 'previous-buffer)
      (define-key evil-normal-state-map (kbd "] b") 'next-buffer)
      (define-key evil-normal-state-map (kbd "[ f") 'evil-unimpaired/previous-file)
      (define-key evil-normal-state-map (kbd "] f") 'evil-unimpaired/next-file)
      ;; (define-key evil-normal-state-map (kbd "[ t") 'evil-unimpaired/previous-frame)
      ;; (define-key evil-normal-state-map (kbd "] t") 'evil-unimpaired/next-frame)
      (define-key evil-normal-state-map (kbd "[ w") 'previous-multiframe-window)
      (define-key evil-normal-state-map (kbd "] w") 'next-multiframe-window)
      ;; select pasted text
      (define-key evil-normal-state-map (kbd "g p") (kbd "` [ v ` ]"))
      ;; paste above or below with newline
      (define-key evil-normal-state-map (kbd "[ p") 'evil-unimpaired/paste-above)
      (define-key evil-normal-state-map (kbd "] p") 'evil-unimpaired/paste-below)

      ;; Back to our regularly scheduled programming
      (fset 'evil-visual-update-x-selection 'ignore)
      (evil-select-search-module 'evil-search-module 'evil-search)
      (setq evil-want-Y-yank-to-eol t
            sentence-end-double-space nil
            evil-regexp-search t
            evil-normal-state-modes (append evil-motion-state-modes
                                            evil-normal-state-modes)
            evil-motion-state-modes nil
            evil-want-C-u-scroll t
            evil-split-window-below t
            evil-vsplit-window-right t)
      (setq-default evil-auto-indent t)

      ;; (add-hook 'view-mode-hook 'evil-motion-state)

      ;; (evil-define-text-object /a-forward-slash (count &optional beg end type)
      ;;   "Select forward slash (/)"
      ;;   :extend-selection t
      ;;   (evil-select-quote ?/ beg end type count))

      ;; (evil-define-text-object /inner-forward-slash (count &optional beg end type)
      ;;   "Select forward slash (/)"
      ;;   :extend-selection nil
      ;;   (evil-select-quote ?/ beg end type count))

      ;; ;; Let `_` be considered part of a word, like vim does
      ;; (defadvice evil-inner-word (around underscore-as-word activate)
      ;;   (let ((table (copy-syntax-table (syntax-table))))
      ;;     (modify-syntax-entry ?_ "w" table)
      ;;     (with-syntax-table table ad-do-it)))
      (/treat-underscore-as-word) ;TODO: Not sure if this is required if we're hooking into prog-mode

      ;; (defun my-evil-make-frame-with-params (file)
      ;;   "Tries to emulate evil tab creation using `make-frame'"
      ;;   (interactive "<f>")
      ;;   (if file
      ;;       ;; Finds the file and loads it into the frame
      ;;       )
      ;;   )

      ;; (evil-ex-define-cmd "sh[ell]" 'eshell)
      (evil-ex-define-cmd "sh[ell]"    'shell) ;; at least shell shows its keymaps
      (evil-ex-define-cmd "tabn[ew]"   'make-frame)
      (evil-ex-define-cmd "tabe[dit]"  'make-frame)
      (evil-ex-define-cmd "restart"    'restart-emacs)
      (evil-ex-define-cmd "init"       'find-user-init-file)
      (evil-ex-define-cmd "config"     'find-user-config-file)

      ;; (lexical-let ((default-color (cons (face-background 'mode-line)
      ;;                                    (face-foreground 'mode-line))))
      ;;   (add-hook 'post-command-hook
      ;;             (lambda ()
      ;;               (let ((color (cond ((minibufferp) default-color)
      ;;                                  ((evil-insert-state-p) '("#b58900" . "#ffffff"))
      ;;                                  ((evil-emacs-state-p)  '("#444488" . "#ffffff"))
      ;;                                  ((buffer-modified-p)   '("#dc322f" . "#ffffff"))
      ;;                                  (t default-color))))
      ;;                 (set-face-background 'mode-line (car color))
      ;;                 (set-face-foreground 'mode-line (cdr color))))))

      ;; nmap Y y$
      (defun /evil-copy-to-end-of-line ()
        "Yanks everything from point to the end of the line"
        (interactive)
        (evil-yank (point) (point-at-eol)))

      ;; https://stackoverflow.com/questions/18102004/emacs-evil-mode-how-to-create-a-new-text-object-to-select-words-with-any-non-sp/22418983#22418983
      (defmacro /evil-define-and-bind-text-object (key start-regex end-regex)
        (let ((inner-name (make-symbol "inner-name"))
              (outer-name (make-symbol "outer-name")))
          `(progn
             (evil-define-text-object ,inner-name (count &optional beg end type)
               (evil-select-paren ,start-regex ,end-regex beg end type count nil))
             (evil-define-text-object ,outer-name (count &optional beg end type)
               (evil-select-paren ,start-regex ,end-regex beg end type count t))
             (define-key evil-inner-text-objects-map ,key (quote ,inner-name))
             (define-key evil-outer-text-objects-map ,key (quote ,outer-name)))))

      ;; https://www.emacswiki.org/emacs/RegularExpression
      (/evil-define-and-bind-text-object "/" "/" "/")
      (/evil-define-and-bind-text-object "\\" "\\" "\\")
      (/evil-define-and-bind-text-object "|" "|" "|")
      ;; (/evil-define-and-bind-text-object "l" "^\\s-*" "\\s-*$") ;; line textobj
      ;; (/evil-define-and-bind-text-object "e" "\\`\\s-*" "\\s-*$") ;; buffer textobj

      (evil-define-text-object my-evil-a-buffer (count &optional beg end type)
        "Select entire buffer"
        (evil-range (point-min) (point-max)))

      ;; shamelessly stolen from
      ;; https://github.com/syohex/evil-textobj-line/blob/master/evil-textobj-line.el
      (defun my-evil-line-range (count beg end type &optional inclusive)
        (if inclusive
            (evil-range (line-beginning-position) (line-end-position))
          (let ((start (save-excursion
                         (back-to-indentation)
                         (point)))
                (end (save-excursion
                       (goto-char (line-end-position))
                       (skip-syntax-backward " " (line-beginning-position))
                       (point))))
            (evil-range start end))))

      (evil-define-text-object my-evil-a-line (count &optional beg end type)
        "Select entire line"
        (my-evil-line-range count beg end type t))

      (evil-define-text-object my-evil-inner-line (count &optional beg end type)
        "Select an inner line"
        (my-evil-line-range count beg end type))

      (add-hook 'evil-normal-state-entry-hook 'evil-ex-nohighlight)
      (evil-mode)
      )

    ;; defaults to g~
    (use-package evil-string-inflection
      :disabled
      :after (evil))

    ;; defaults to x, so dax, dix, etc
    ;; This package is about xml attribute objects, the t textobj handles tags, not
    ;; attributes, which are inside tags
    (use-package exato
      :after (evil))

    ;; https://github.com/gridaphobe/evil-god-state
    (use-package evil-god-state
      :general
      (:states 'normal
       "g <SPC>" 'evil-execute-in-god-state))

        ;;; TODO: Org-mode has some pairs that are not handled by surround. We would
        ;;; need to fix that.
    (use-package evil-surround
      :after (evil)
      :demand t
      :config
      (global-evil-surround-mode)
      )

        ;;; Evil-embrace is like a souped up addon of surround, this time they have
        ;;; things like function surround and probably more features.
    (use-package evil-embrace
      :after (evil-surround)
      :demand t
      :config
      (evil-embrace-enable-evil-surround-integration)
      (setq evil-embrace-show-help-p nil)
      )

    (use-package evil-args
      :bind (:map evil-inner-text-objects-map
             ("a" . evil-inner-arg)
             :map evil-outer-text-objects-map
             ("a" . evil-outer-arg)
             ;; :map evil-normal-state-map
             ;; ("L" . evil-forward-arg)
             ;; ("H" . evil-backward-arg)
             ;; ("K" . evil-jump-out-args)
             ;; :map evil-motion-state-map
             ;; ("L" . evil-forward-arg)
             ;; ("H" . evil-backward-arg)
             )
      ;; :config
      ;; consider spaces as argument delimiters
      ;; (add-to-list 'evil-args-delimiters " ")
      )

    ;; more like evil-textobj-kolumn
    (use-package evil-textobj-column
      :bind (:map evil-inner-text-objects-map
             ("k" . evil-textobj-column-word)
             ("K" . evil-textobj-column-WORD)))

    (use-package evil-numbers
      :general
      (:keymaps 'normal
       "C-a"  'evil-numbers/inc-at-pt
       "C-x"  'evil-numbers/dec-at-pt)
      ;; :bind (:map evil-normal-state-map
      ;;        ("C-a" . evil-numbers/inc-at-pt)
      ;;        ("C-x" . evil-numbers/dec-at-pt))
      )

    (use-package evil-rsi
      :disabled
      :after (evil)
      :config
      (evil-rsi-mode))

    ;; alignment
    (use-package evil-lion
      :after (evil)
      :demand t
      :config
      (evil-lion-mode))

    (use-package evil-matchit)

    ;; (use-package evil-paredit
    ;;   :config (add-hook 'emacs-lisp-mode-hook 'evil-paredit-mode))

    ;; (use-package evil-cleverparens
    ;;   :ensure t
    ;;   :bind(:map evil-inner-text-objects-map
    ;;              ("c" . evil-cp-inner-comment)
    ;;              :map evil-outer-text-objects-map
    ;;              ("c" . evil-cp-a-comment)
    ;;              )
    ;;   :config
    ;;   ;; (progn (require 'evil-cleverparens-text-objects)
    ;;   ;;        (define-key evil-inner-text-objects-map "c" 'evil-cp-inner-comment)
    ;;   ;;        (define-key evil-outer-text-objects-map "c" 'evil-cp-a-comment))
    ;;   (add-hook 'emacs-lisp-mode-hook #'evil-cleverparens-mode))

    ;; (use-package evil-cleverparens-text-objects
    ;;   :ensure t
    ;;   :init
    ;;   (use-package evil-cleverparens :ensure t)
    ;;   :config
    ;;   nil)

    ;; (use-package evil-cleverparens
    ;;   :bind(:map evil-inner-text-objects-map
    ;;              ("c" . evil-cp-inner-comment)
    ;;              :map evil-outer-text-objects-map
    ;;              ("c" . evil-cp-a-comment))
    ;;   ;; :config
    ;;   ;; (require 'evil-cleverparens-text-objects)
    ;;   )

    ;; Adds textobjects that comments
    (use-package evil-commentary
      :after (evil)
      :demand t
      :config
      (evil-commentary-mode)
      )

    (use-package evil-nerd-commenter
      :after (evil)
      :bind (:map evil-inner-text-objects-map
             ("c" . evilnc-inner-comment)
             :map evil-outer-text-objects-map
             ("c" . evilnc-outer-commenter)))

    ;; (use-package evil-replace-with-register)

    ;; (use-package evil-text-object-python)

        ;;; Indentation text object for evil
    (use-package evil-indent-plus
      :bind(:map evil-inner-text-objects-map
            ("i" . evil-indent-plus-i-indent)
            ("I" . evil-indent-plus-a-indent)
            :map evil-outer-text-objects-map
            ("i" . evil-indent-plus-i-indent-up)
            ("I" . evil-indent-plus-a-indent-up)))

    ;; vim A E S T H E T H I C S
    ;; Puts tildes in the fringe, just like vim.
    (use-package vi-tilde-fringe
      :after (evil)
      :demand t
      :config
      (global-vi-tilde-fringe-mode))

        ;;; Allows for * and # commands. which originally only worked on WORDs, to
        ;;; work on a visual selection too
    (use-package evil-visualstar
      :after (evil)
      :demand t
      :config
      (global-evil-visualstar-mode))

    ;; TODO: Document GNU Readline bindings
    (use-package evil-rsi
      :demand t
      :after (evil)
      :diminish (evil-rsi-mode)
      :config
      (evil-rsi-mode))

    ;; Flashes the selection you made. I honestly don't need this and am just
    ;; turning it on for shits and giggles, until it starts to annoy me
    ;; https://github.com/edkolev/evil-goggles
    (use-package evil-goggles
      :after (evil)
      :diminish (evil-goggles-mode)
      :demand t
      :custom
      (evil-goggles-duration 0.05
                             "Sometimes the default of 0.2 is too slow")
      :config
      (evil-goggles-mode)
      (evil-goggles-use-diff-faces))

        ;;; Disabled because it conflicts with evil-snipe-override-mode
    (use-package evil-quickscope
      :disabled t
      ;; :config
      ;; (global-evil-quickscope-always-mode t)
      ;; (global-evil-quickscope-mode t)
      )

        ;;; Basically does what Clever-F did in vim, letting you repeatedly press
        ;;; f, F, t, and T instead of using ; and ,
    (use-package evil-snipe
      :after (evil)
      :demand t
      :diminish (evil-snipe-override-mode
                 evil-snipe-override-local-mode)
      :config
      (evil-snipe-override-mode))

        ;;; Adds the following ex commands:
    ;; | :reverse           | reverse visually selected lines
    ;; | :remove            | remove current file and its buffer
    ;; | :rename NEW-PATH   | rename or move current file and its buffer
    ;; | :colorscheme THEME | change emacs color theme
    ;; | :diff-orig         | get a diff of unsaved changes, like vim's common :DiffOrig
    ;; | :gdiff             | BRANCH git-diff current file, requires magit and vdiff-magit
    ;; | :gblame            | git-blame current file, requires magit
    ;; | :gremove           | git remove current file, requires magit
    ;; | :tyank             | copy range into tmux paste buffer, requires running under tmux
    ;; | :tput              | paste from tmux paste buffer, requires running under tmux
    (use-package evil-expat)

        ;;; Adds an operator `gx' that, when called again, swaps both selections
    ;; currently DISABLED because it conflicts with the default `g x', which
    ;; goes to the link under the cursor (`browse-url-at-point'), something
    ;; which I feel is probably cooler than evil-exchange
    (use-package evil-exchange
      :disabled t)

    ;; (use-package evil-visual-mark-mode
    ;;   :ensure t
    ;;   :config
    ;;   (evil-visual-mark-mode))

    ;; (use-package evil-tabs
    ;;   :ensure t
    ;;   :config
    ;;   (global-evil-tabs-mode t))

    (use-package vimish-fold)

    (use-package evil-tutor)

  #+END_SRC

** TODO evil-argwrap

   I want to replicate [[https://github.com/FooSoft/vim-argwrap][vim-argwrap]] in evil-mode.

   For reference, since I would expect the implementation to be something similar:
   #+BEGIN_SRC emacs-lisp :exports none

     (defun my-add-newline-and-indent-braces (&rest _)
       "Adds that cool vim indent thing we always wanted"
       (newline)
       (indent-according-to-mode)
       (forward-line -1)
       (indent-according-to-mode))

   #+END_SRC

   - Indent whole region by line
   - Assume that beg and end are both on wrapping characters
   - Only indent the top level commas, meaning we need to skip commas inside parentheses
     - consider using =evil-jump-item= since it looks like it does what we want.
     - inspect evil-args for possible solutions on implementation. Initial
       impressions are not good, mostly because it's totally undocumented.

   #+BEGIN_SRC emacs-lisp :exports none
     (defun my-evil-argwrap-region (beg end)
       ;; find , (eventually we'll support other delimiters)
       (while )
       (evil-rot13 beg end))

     (evil-define-operator my-evil-argwrap (beg end)
       "docstring for evil-argwrap"
       (my-evil-argwrap-region beg end))

     ;; So this works
     (define-key evil-normal-state-map (kbd "\\") 'my-evil-argwrap)
   #+END_SRC

   It appears that calling something defined by =evil-define-operator= puts
   emacs into operator pending mode, which is expected. Then evil passes in a
   range and the operation starts.

*** DONE What are the acceptable values for =evil-operator-range-type=?
    CLOSED: [2018-03-28 Wed 22:24]

    Covered by noctuid [[https://github.com/noctuid/evil-guide#type][here]].

    It's defined in =evil-define-motion=. The allowed characters are:
    - inclusive :: The range is the start point up to and including the ending
                   position.
    - line      :: The range is set to the beginning and end of the line
    - block     :: The range is blockwise like in =C-v=
    - exclusive :: Default. The range is exactly like ~inclusive~ except that it
                   does not include the ending position.

*** Test cases

    { a, b, c } { foo{a, b} , b, c }

* TODO Helm
  #+BEGIN_SRC emacs-lisp

    ;; Install ivy as a contingency
    (use-package ivy
      :bind (:map ivy-minibuffer-map
             ("C-w" . ivy-backward-kill-word)
             ("C-u" . ivy-backward-kill-line)
             ("C-j" . ivy-next-line)
             ("C-k" . ivy-previous-line))
      :config
      (setq ivy-use-virtual-buffers t
            enable-recursive-minibuffers t))

    (use-package swiper)

    (use-package counsel
      :bind (("M-x" . counsel-M-x)))

    (use-package helm
      :after (general)
      :demand t
      :general
      ("C-h C-h" 'helm-apropos
       "C-h h"   'helm-apropos)
      (:states 'normal
       "-"     'helm-find-files) ;; emulate vim-vinegar
      (:states  'normal
       :prefix my-default-evil-leader-key
       "<SPC>"  'helm-M-x
       "TAB"    'helm-resume
       "y y"    'helm-show-kill-ring
       "b b"    'helm-mini
       "m m"    'helm-bookmarks)
      (:keymaps 'helm-map
       "C-w" 'evil-delete-backward-word
       "\\"  'helm-select-action
       "C-j" 'helm-next-line
       "C-k" 'helm-previous-line
       "C-n" 'helm-next-page
       "C-p" 'helm-previous-page
       "C-l" 'helm-next-source
       "C-h" 'helm-previous-source
       "TAB" 'helm-execute-persistent-action)
      :config
      (setq helm-idle-delay 0.0
            helm-input-idle-delay 0.01
            helm-quick-update t)
      (setq helm-recentf-fuzzy-match t
            helm-locate-fuzzy-match nil ;; locate fuzzy is worthless
            helm-M-x-fuzzy-match t
            helm-buffers-fuzzy-matching t
            helm-semantic-fuzzy-match t
            helm-apropos-fuzzy-match t
            helm-imenu-fuzzy-match t
            helm-lisp-fuzzy-completion t
            helm-completion-in-region-fuzzy-match t
            helm-split-window-in-side-p t
            helm-use-frame-when-more-than-two-windows nil)
      (progn (helm-autoresize-mode)
             (setq helm-autoresize-min-height 40 ;; these values are %
                   helm-autoresize-max-height 40))
      (helm-mode)
      )

    ;; TODO: when defining helm desckeys make sure a global binding is also presentw
    ;; C-h seems broken (We've been overwriting it to enable terminal backspace)

    (use-package helm-describe-modes
      :bind (("C-h m" . helm-describe-modes))
      ;; :config
      ;; (evil-leader/set-key "m" 'helm-describe-modes)
      )

    (use-package helm-descbinds
      :bind (("C-h b" . helm-descbinds))
      :config
      (helm-descbinds-mode))

    (use-package helm-swoop
      :general
      (:states 'normal
       :prefix my-default-evil-leader-key
       "f f" 'helm-swoop) :init
    ;;;###autoload
      (defun /helm-swoop-vis () (interactive)
             (helm-swoop :$query "" :$multiline 4))
      :bind (:map helm-swoop-map
             ("C-w" . evil-delete-backward-word))
      ;; :config
      ;; (defun /helm-swoop-vis () (interactive)
      ;;        (helm-swoop :$query "" :$multiline 4))
      ;; no annoying under mouse highlights
      ;;(setq helm-swoop-pre-input-function (lambda () nil))
      )

    (use-package helm-fuzzier
      :after helm
      :demand t
      :config
      (helm-fuzzier-mode))

    (use-package helm-flx
      :after helm
      :demand t
      :config
      (helm-flx-mode)
      (setq helm-flx-for-helm-find-files t
            helm-flx-for-helm-locate t))

    (use-package helm-dash)

    ;; commenting it out because it has conflicting bindings in its own map
    ;; (use-package helm-hunks
    ;;   :commands (helm-hunks
    ;;              helm-hunks-current-buffer
    ;;              helm-hunks-staged
    ;;              helm-hunks-staged-current-buffer)
    ;;   :config
    ;;   (progn (require 'git-gutter+)
    ;;          (add-hook 'helm-hunks-refresh-hook 'git-gutter+-refresh)
    ;;          )
    ;;   (setq helm-hunks-preview-diffs t)
    ;;   (evil-leader/set-key
    ;;     "." 'helm-hunks-current-buffer))

    ;; (helm-mode 1)
  #+END_SRC
* TODO Buffer
  #+BEGIN_SRC emacs-lisp

    (add-hook 'prog-mode-hook 'hs-minor-mode)

    ;; no startup screen
    (setq inhibit-startup-screen t)

    ;; startup maximised
    (custom-set-variables
     '(initial-frame-alist (quote ((fullscreen . maximized)))))
    (custom-set-variables
     '(default-frame-alist (add-to-list 'default-frame-alist
                                        '(fullscreen . maximized))))

    (setq require-final-newline t)

    ;; remove annoying bell sounds
    (setq ring-bell-function 'ignore)

    ;; Save buffer state
    (setq savehist-file (concat user-init-dir "history")
          savehist-save-minibuffer-history 1
          savehist-additional-variables
          '(kill-ring
            search-ring
            regexp-search-ring))
    (savehist-mode 1)
    (setq history-length t
          history-delete-duplicates t)


    ;; Display time
    (display-time-mode 1)

    ;; strip whitespace
    (add-hook 'before-save-hook 'delete-trailing-whitespace)
    (general-define-key
     :states 'normal
     :prefix my-default-evil-leader-key
                        "." 'whitespace-mode)

    ;; automatically refresh buffer when changed outside
    (global-auto-revert-mode t)

    ;; Remove toolbar
    (progn (tool-bar-mode -1)
           (menu-bar-mode -1)
           (scroll-bar-mode -1)
           (window-divider-mode -1))

    (setq tab-always-indent 'complete)

    (setq-default truncate-lines    t  ;; no wrap
                  indent-tabs-mode nil ;; do not use tabs when indenting
                  tab-width         2
                  auto-hscroll-mode t)

    ;; use optimised linum mode if we can
    (when (>= emacs-major-version 26)
      (global-display-line-numbers-mode))

    (defun my-disable-line-numbers ()
      "For modes that doesn't need line numbers in their buffers"
      (display-line-numbers-mode -1)
      )

    ;; autopairing
    ;; We're currently trying out smartparens
    (electric-pair-mode -1)

    ;; Change "yes or no" to "y or n"
    (fset 'yes-or-no-p 'y-or-n-p)

    ;; Frame-related functions
    (add-hook 'after-make-frame-functions 'select-frame)

    ;; speed optimisation
    ;; https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746
    (setq-default auto-window-vscroll nil)

    (defconst my-user-temp-dir
      "tempfiles/"
      "Directory used to store temporary files that shouldn't be versioned")

    ;; adjust autosave and backup directories
    (setq backup-directory-alist `(("." . ,(concat user-init-dir
                                                   my-user-temp-dir
                                                   "backups/")))
          delete-old-versions t
          backup-by-copying t
          version-control t
          kept-new-versions 20
          kept-old-versions 5
          vc-make-backup-files t
          auto-save-list-file-prefix (concat user-init-dir
                                             my-user-temp-dir
                                             "auto-save-list/.saves-")
          ;; auto-save-file-name-transforms `((".*" ,(concat user-init-dir
          ;;                                                 my-user-temp-dir
          ;;                                                 "autosave/")
          ;;                                   t))
          )

    ;; look cool
    (when window-system
      (global-hl-line-mode))

    (defun my-goto-scratch-buffer ()
      "When called goes to the scratch buffer.
    TODO: Make it take an argument that specifies which mode it should enter the
    buffer in."
      (interactive)
      (switch-to-buffer "*scratch*")
      )

    (evil-ex-define-cmd "sc[ratch]" 'my-goto-scratch-buffer)

    (defun my-goto-messages-buffer ()
      "When called goes to the Messages buffer.
    TODO: Make it take an argument that specifies which mode it should enter the
    buffer in."
      (interactive)
      (switch-to-buffer "*Messages*")
      )

    (evil-ex-define-cmd "me[ssages]" 'my-goto-messages-buffer)

    (use-package highlight-indent-guides
      ;; :hook (prog-mode . highlight-indent-guides-mode)
      :config
      (general-define-key
       :states 'normal
       :prefix my-default-evil-leader-key
                          "'" 'highlight-indent-guides-mode)
      (setq highlight-indent-guides-method 'character
            highlight-indent-guides-character ?\|)
      ;; (highlight-indent-guides-mode)
      )

    (use-package whitespace-cleanup-mode
      :demand t
      :config
      (global-whitespace-cleanup-mode 1))

    (use-package hl-todo
      :defer 1
      :diminish t
      :general
      (:states 'normal
       :prefix my-default-evil-leader-key
               "t t" 'hl-todo-occur)
      (:keymaps 'evil-normal-state-map
       "[ t"  'hl-todo-previous
       "] t"  'hl-todo-next)
      :init
      ;; (general-define-key :prefix my-default-evil-leader-key
      ;;                     "t t" 'hl-todo-occur)
      ;; :hook (prog-mode . hl-todo-mode)
      :bind
      :config
      (customize-set-variable 'hl-todo-keyword-faces
                              `(("TODO"  . ,$solarized-dark-yellow)
                                ("DEBUG" . ,$solarized-dark-magenta)
                                ("BUG"   . ,$solarized-dark-red)
                                ("STUB"  . ,$solarized-dark-green)
                                ("NOTE"  . ,$solarized-dark-base1)
                                ("HACK"  . ,$solarized-dark-violet)
                                ("FIXME" . ,$solarized-dark-orange)))
      (global-hl-todo-mode)
      (add-hook 'yaml-mode-hook 'hl-todo-mode))

    ;; https://github.com/alpaker/Fill-Column-Indicator
    (use-package fill-column-indicator
      :hook (prog-mode . turn-on-fci-mode)
      :diminish t
      :custom
      (fill-column 80)
      (always-use-textual-rule t)
      )

    (use-package golden-ratio
      :disabled t
      :config
      (golden-ratio-mode 1)
      (add-hook 'buffer-list-update-hook #'golden-ratio))

    (use-package powerline
      :demand t)

    (use-package powerline-evil
      :after (powerline)
      :demand t
      :custom
      (powerline-evil-tag-style 'verbose
                                "Print out the full name of the state instead of <S>
                                abbreviations.")
      :config
      (powerline-evil-vim-theme))

    ;; https://github.com/larstvei/Focus
    (use-package focus
      :init
      (general-define-key
       :states 'normal
       :prefix my-default-evil-leader-key
                          "f f" 'focus-mode)
      (evil-ex-define-cmd "fo[cus]" 'focus-mode))

    (use-package minimap
      :commands minimap-mode
      :config
      (customize-set-variable 'minimap-window-location 'right))

    (use-package no-littering)

    (use-package mmm-mode
      :disabled t ; looking at polymode instead
      :commands mmm-mode
      :config
      (setq mmm-parse-when-idle 't))

    (use-package unicode-troll-stopper)

    (use-package transpose-frame)

    (use-package buffer-move)

    (use-package crosshairs
      :disabled t)

    (use-package which-key
      :demand t
      :diminish which-key-mode
      :config
      (which-key-mode))

    (use-package undo-tree
      :demand t
      :diminish undo-tree-mode
      :config
      (global-undo-tree-mode))

    ;;;###autoload
    (defun /line-lengths()
      "Return a list of line lengths for all the lines in the buffer."
      (let (length)
        (save-excursion
          (goto-char (point-min))
          (while (not (eobp))
            (push (- (line-end-position)
                     (line-beginning-position))
                  length)
            (forward-line)))
        ;; we return a list since this is the last form evaluated
        (copy-sequence length)))

    ;;;###autoload
    (defun /longest-line-length()
      "Return the longest line from the list of lines given."
      (let ((lines (/line-lengths)))
        ;; return the first element, which should be the largest
        (nth 0 (sort lines '>))))

    ;;;###autoload
    (defun /centre-window-function()
      "Offset the window margins based on the longest line in the buffer.
    This effectively centers it."
      (interactive)
      (let ((margin-size (/ (abs (- (window-width) (/longest-line-length))) 2)))
        (if (not (get '/centre-window-function 'active))
            (progn
              (set-window-margins nil margin-size nil)
              (fringe-mode '(1 . 1))
              (put '/centre-window-function 'active t))
          (progn
            (set-window-margins nil nil nil)
            (fringe-mode nil)
            (put '/centre-window-function 'active nil)))))

    (general-define-key
     :states 'normal
     :prefix my-default-evil-leader-key
                        "W" '/centre-window-function)

    ;; (use-package switch-window
    ;;   :custom
    ;;   (switch-window-shortcut-apppearance 'asciiart))

    ;; Used in help mode and eww
    (use-package ace-link
      :commands (ace-link-help
                 ace-link-info
                 ace-link-eww))

    (use-package ace-window
      :bind
      (:map evil-window-map
            ("SPC" . ace-window))
      :custom
      (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
      )

    ;; er/expand-region
    (use-package expand-region)

    (use-package centered-window-mode
      :disabled t
      :el-get centered-window-mode
      :config
      (centered-window-mode t))

    (use-package autopair
      :disabled t
      :config
      (autopair-global-mode))

    (use-package polymode)

    (use-package smartparens
      :demand t
      :diminish smartparens-mode
      :custom
      (sp-cancel-autoskip-on-backward-movement
       nil "We want to maintain the chomp-like behavior of electric-pair")
      (sp-autoskip-closing-pair
       'always "Maintain chomp-like behavior of electric-pair")
      :config
      (require 'smartparens-config) ;; load some default configurations
      (smartparens-global-mode)
      ;; (smartparens-global-strict-mode) ;; disable this because the chomping issue is solved
      (show-smartparens-global-mode t)
      ;; define some helper functions
      (defun my-add-newline-and-indent-braces (&rest _)
        "Adds that cool vim indent thing we always wanted"
        (newline)
        (indent-according-to-mode)
        (forward-line -1)
        (indent-according-to-mode))
      ;; Update the global definitions with some indenting
      ;; I think that the nil is the flag that controls property inheritance
      ;;NOTE: For some reason TAB isn't recognised. Might be yasnippet intefering.
      ;;Learn to use ret for now
      (sp-pair "{" nil :post-handlers '((my-add-newline-and-indent-braces "RET")))
      (sp-pair "[" nil :post-handlers '((my-add-newline-and-indent-braces "RET")))
      (sp-pair "(" nil :post-handlers '((my-add-newline-and-indent-braces "RET")))
      )

    (use-package evil-smartparens
      :after smartparens
      :demand t
      :diminish (evil-smartparens-mode)
      :config
      (evil-smartparens-mode))

    ;;;###autoload
    (defun my-set-frame-transparency (value)
      "Set the transparency of the frame window to VALUE.
    0=transparent/100=opaque"
      (interactive "nTransparency Value 0 - 100 opaque:")
      (set-frame-parameter (selected-frame) 'alpha value))

  #+END_SRC
** Hungry Deletion (of whitespace)
   - Homepage :: http://endlessparentheses.com/hungry-delete-mode.html

   #+BEGIN_SRC emacs-lisp
     (use-package hungry-delete
       :demand t
       :config
       (global-hungry-delete-mode))
   #+END_SRC

* Dashboard
  #+BEGIN_SRC emacs-lisp

    (use-package dashboard
      :disabled t
      :init
      (dashboard-setup-startup-hook)
      :config
      (setq dashboard-startup-banner nil))

  #+END_SRC
* TODO Aggressive Indent/Fill paragraph
  #+BEGIN_SRC emacs-lisp

    (use-package aggressive-indent
      :diminish t
      :demand t
      :config
      (add-hook 'python-mode-hook 'aggressive-indent-mode)
      ;; (global-aggressive-indent-mode)
      )

    (use-package aggressive-fill-paragraph
      ;; :disabled ;; this package annoys me. Probably needs more config
      :commands (aggressive-fill-paragraph-mode
                 afp-setup-recommended-hooks)
      ;; :config
      ;; (add-hook 'text-mode-hook #'aggressive-fill-paragraph-mode)
      )

  #+END_SRC
* TODO Magit
  #+BEGIN_SRC emacs-lisp

    (use-package magit
      :commands magit-status
      :init
      (general-define-key
       :states 'normal
       :prefix my-default-evil-leader-key
       ", ," 'magit-status)
      :config
      (with-eval-after-load 'aggressive-fill-paragraph
        (add-hook 'git-commit-setup-hook 'aggressive-fill-paragraph-mode))
      (with-eval-after-load 'fill-column-indicator
        (add-hook 'git-commit-setup-hook 'turn-on-fci-mode))
      (add-hook 'magit-popup-mode-hook #'my-disable-line-numbers)
      )

    (use-package evil-magit
      :after magit
      :demand t
      :config
      (evil-magit-init))

    ;; https://github.com/nonsequitur/git-gutter-plus
    (use-package git-gutter+
      :diminish git-gutter+-mode
      :bind (:map evil-normal-state-map
             ("[ h" . git-gutter+-previous-hunk)
             ("] h" . git-gutter+-next-hunk)
             ("g h s" . git-gutter+-stage-hunks)
             ("g h u" . git-gutter+-revert-hunks)
             ("g h h" . git-gutter+-show-hunk-inline-at-point)
             )
      :defer 5
      ;; :hook (prog-mode . git-gutter+-mode)
      :config
      ;; refer to the hacks made in config-colors.el.
      ;; We do this to make the gutter things look nice
      (unless (display-graphic-p)
        (set-face-foreground 'git-gutter+-modified "magenta")
        (set-face-background 'git-gutter+-modified nil)
        (set-face-foreground 'git-gutter+-added "green")
        (set-face-background 'git-gutter+-added nil)
        (set-face-foreground 'git-gutter+-deleted "red")
        (set-face-background 'git-gutter+-deleted nil))
      (setq git-gutter+-hide-gutter t)
      ;; use git-gutter+-diffinfo-at-point to get the range of the hunk,
      ;; extract the range beg-end,
      ;; then set the textobject to that range
      ;; (require 'evil)

      ;; we're forced to put it here because the global mode must be done afterwards
      ;; (??)
      (use-package git-gutter-fringe+
        :if (display-graphic-p)
        :after git-gutter+
        :demand t)
      (global-git-gutter+-mode)
      )

  #+END_SRC

** TODO Git Hunk textobjects
* TODO Org
  #+BEGIN_SRC emacs-lisp

    (use-package org
      :commands
      (org-time-stamp-inactive
       org-refile)

      :general
      (:states 'normal
       :prefix my-default-evil-leader-key
       "o t" 'org-time-stamp-inactive
       "o T" #'my-time-stamp
       "o r" 'org-refile)
      (org-mode-map
        "C-c C-'" 'org-edit-special)
      (org-src-mode-map
        "C-c C-'" 'org-src-edit-exit)
      :custom
      (org-support-shift-select t
                                "Let me use J in org-mode please.")
      (org-startup-indented nil)
      (org-indent-mode-turns-on-hiding-stars nil)
      (org-src-tab-acts-natively t)
      ;; (org-src-window-setup 'current-window)
      (org-src-fontify-natively t)
      (org-default-notes-file "~/TODO.org")
      ;; (org-M-RET-may-split-line '((default . nil)))
      (org-M-RET-may-split-line nil)
      (org-enforce-todo-checkbox-dependencies     t)
      (org-enforce-todo-dependencies              t)
      (org-pretty-entities                        nil)
      ;; (org-insert-heading-respect-content t)
      (org-log-done                               'time)
      (org-log-redeadline                         'time)
      (org-log-reschedule                         'time)
      (org-blank-before-new-entry '((heading         . t)
                                    (plain-list-item . nil)))
      (org-refile-targets '((nil . (:maxlevel . 9))))
      (org-refile-use-outline-path t)
      (org-outline-path-complete-in-steps nil)
      (org-refile-allow-creating-parent-nodes 'confirm)
      (org-highlight-latex-and-related '(latex))
      (org-src-block-faces '(("emacs-lisp" (:foreground "#839496"))))

      :config
    ;;;###autoload
      (defun /org-mode-face-no-resize ()
        "Stop the org-level headers from increasing in height relative to the other
    text."
        (when (eq major-mode 'org-mode)
          (dolist (face '(org-level-1
                          org-level-2
                          org-level-3
                          org-level-4
                          org-level-5))
            (set-face-attribute face nil :weight 'semi-bold :height 1.0))))
      (add-hook 'org-mode-hook '/org-mode-face-no-resize)

      ;; (org-toggle-link-display)

      ;; when inserting a heading immediately go into insert mode
      (add-hook 'org-insert-heading-hook 'evil-insert-state)

      ;; (general-define-key :keymaps 'org-mode-map
      ;;                     :states 'insert
      ;;                     "RET"     'newline-and-indent)

      ;; make smartparen autoskip "" because org-mode treats it as a string
      (require 'smartparens)
      (sp-local-pair 'org-mode "\"" nil :when '(:rem sp-in-string-p))

      (defun my-time-stamp ()
        "Prints the time and date."
        (interactive)
        (org-time-stamp-inactive '(16)))

      (require 'evil-embrace)
      (defun my-add-org-evil-embrace-pairs ()
        "Add additional pairings that evil-surround doesn't cover"
        (let ((org-pairs '((?= "=" . "=") ;; verbatim
                           (?* "*" . "*") ;; bold
                           (?_ "_" . "_") ;; underline
                           (?+ "+" . "+") ;; strikethrough
                           (?~ "~" . "~") ;; code
                           (?/ "/" . "/")))) ;; italic
          (dolist (pair org-pairs)
            (embrace-add-pair (car pair) (cadr pair) (cddr pair)))))
      (add-hook 'org-mode-hook 'my-add-org-evil-embrace-pairs)

      (defun my-org-hook-configs ()
        "Hacks to make org-mode less cancer when run"
        ;; NOTE: We turn this off because it is causing the cursor to do really
        ;; fucking weird things
        ;; (require 'fill-column-indicator)
        ;; (turn-on-fci-mode)
        (with-eval-after-load 'display-line-numbers
          (display-line-numbers-mode -1))
        (require 'aggressive-fill-paragraph)
        (aggressive-fill-paragraph-mode))
      (add-hook 'org-mode-hook #'my-org-hook-configs)
      )

    ;; org capture. https://github.com/syl20bnr/spacemacs/issues/5320
    (use-package org-capture
      :ensure nil ;; because org-capture is from org
      :after (org)
      :general
      (:prefix my-default-evil-leader-key
       :states 'normal
       "c c" 'org-capture) :config
      (define-key org-capture-mode-map [remap evil-save-and-close]
        'org-capture-finalize)
      (define-key org-capture-mode-map [remap evil-save-modified-and-close]
        'org-capture-finalize)
      (define-key org-capture-mode-map [remap evil-quit]
        'org-capture-kill)
      )

    (use-package org-agenda
      :ensure nil ;; because org-agenda is from org
      :after (org)
      :general
      (:prefix my-default-evil-leader-key
       :states 'normal
       "O O" 'org-agenda)
      :config
      ;; initialize org agenda things
      (add-to-list 'org-agenda-files my-org-directory)
      )

    ;;; This is like a concept map, but in org-files
    (use-package org-brain
      :custom
      (org-brain-path my-wiki-directory "Share the same path as deft.")
      (org-brain-file-entries-use-title nil
                                        "Speed optimisation since our filenames and
                                        title should match anyway")
      :general
      (:states 'normal
       :prefix my-default-evil-leader-key
       "N" 'org-brain-visualize)
      :init
      (with-eval-after-load 'evil
        (evil-set-initial-state 'org-brain-visualize-mode 'emacs))
      )

    (use-package org-radiobutton)

    ;; Export orgfiles as anki decks!
    ;; Looks great for jap study and just study in general
    ;; https://github.com/louietan/anki-editor
    ;; Requires that the anki plugin `anki-connect' is installed
    (use-package anki-editor)

    ;; Prepackaged evil bindings for org-mode
    ;; https://github.com/Somelauw/evil-org-mode
    ;; Full keybindings:
    ;; https://github.com/Somelauw/evil-org-mode/blob/master/doc/keythemes.org
    (use-package evil-org
      ;; :disabled t
      :after (org)
      :demand t
      :diminish (evil-org-mode)
      ;; :general
      ;; (:states '(emacs insert)
      ;;  :keymaps 'org-mode-map
      ;;  "RET" 'evil-org-return)
      :custom
      (evil-org-retain-visual-state-on-shift
       t
       "Let us chain < and > calls")
      (evil-org-use-additional-insert
       t
       "Add things like M-j to insert")
      (evil-org-special-o/O
       '(table-row)
       "Do not let o/O affect list items, throws me off")
      :config
      (evil-org-set-key-theme '(textobjects
                                insert
                                navigation
                                additional
                                shift
                                return
                                operators
                                ;; todo
                                ;; heading
                                calendar
                                ))
      (add-hook 'org-mode-hook 'evil-org-mode)
      (require 'evil-org-agenda)
      (evil-org-agenda-set-keys))

    (use-package worf)

    (use-package helm-org-rifle
      :after (org)
      :general
      (:states 'normal
       :prefix my-default-evil-leader-key
       "o o" 'helm-org-rifle)
      :bind
      (:map helm-org-rifle-map
       ("C-w" . evil-delete-backward-word)
       ("\\"  . helm-select-action)
       ("C-j" . helm-next-line)
       ("C-k" . helm-previous-line)
       ("C-n" . helm-next-page)
       ("C-p" . helm-previous-page)
       ("C-l" . helm-next-source)
       ("C-h" . helm-previous-source)
       ("TAB" . helm-execute-persistent-action))
      )

    (use-package ob-async
      :demand t
      :after (org))

    (use-package ob-clojurescript
      :demand t
      :after (org))

    (use-package ob-http
      :demand t
      :after (org))

    (use-package ob-browser
      :demand t
      :after (org))

    (use-package ob-restclient
      :demand t
      :after (org))

    (use-package ob-rust
      :demand t
      :after (org))

    (use-package ob-translate
      :demand t
      :after (org))
  #+END_SRC

** TODO Bind <C-M-return> to smart insert subitem or subheader
* Deft
  - Homepage :: https://jblevins.org/projects/deft/


  #+BEGIN_SRC emacs-lisp

    (use-package deft
      :commands (deft)
      :custom
      (deft-auto-save-interval 0.0
        "Disable autosave because of permissions issues causing massive lag")
      (deft-directory my-wiki-directory
        "Set the directory to dropbox")
      (deft-extensions '("org")
        "Set the extensions for deft notes")
      (deft-recursive t
        "Recursively search so we can organise by folders")
      (deft-use-filter-string-for-filename t)
      (deft-file-naming-rules '((noslash . "-")
                                (nospace . "-")
                                (case-fn . downcase)))
      (deft-org-mode-title-prefix t)
      :general
      (:states 'normal
       :prefix my-default-evil-leader-key
       "n n" 'deft)
      (:keymaps 'deft-mode-map
       :states  '(insert normal motion)
       "C-j"    'widget-forward
       "C-k"    'widget-backward)
      (:keymaps 'deft-mode-map
       :states  'normal
       "q"      'quit-window ;; first emacsy binding in a vim state [2018-03-21 Wed]
       "p"      'deft-filter-yank
       "d d"    'deft-delete-file)
      (:keymaps 'deft-mode-map
       :states  'insert
       "C-w"    'deft-filter-decrement-word
       "C-u"    'deft-filter-clear)
      :config
      ;; (evil-make-overriding-map deft-mode-map nil)
      (evil-set-initial-state 'deft-mode 'insert)
      ;; I wonder why evil keeps overriding RET with evil-ret
      ;; (general-define-key :states '(insert motion normal)
      ;;                     :keymaps 'deft-mode-map
      ;;                     "RET" 'deft-complete)
      (add-hook 'deft-open-file-hook 'org-mode)

      ;; We explicitly disable evil-rsi-mode because some of its keybinds conflicts
      ;; with existing deft mode keybinds
      (with-eval-after-load 'evil-rsi
        (add-hook 'deft-mode-hook '(lambda () (evil-rsi-mode -1))))

      ;; (define-key deft-mode-map [remap evil-quit]
      ;;   'kill-this-buffer)
      ;; (define-key deft-mode-map [remap evil-save-modified-and-close]
      ;;   'kill-this-buffer)
      ;; TODO: See if this method can be applied to eshell hacks
      ;; TODO: This isn't working for some reason
      ;; (define-key deft-mode-map [remap evil-ret]
      ;;   'deft-complete)
      ;; (defun my-overwrite-evil-ret-in-deft ()
      ;;   "attempts to make evil-ret in deft do things like send input"
      ;;   (message "Attempting to overwrite RET for deft")
      ;;   ;; (with-eval-after-load 'evil-config
      ;;   ;;   (define-))
      ;;   (evil-local-set-key 'insert
      ;;                       (kbd "RET") 'deft-complete)
      ;;   (evil-local-set-key 'normal
      ;;                       (kbd "RET") 'deft-complete)
      ;;   (evil-local-set-key 'motion
      ;;                       (kbd "RET") 'deft-complete)
      ;;   )
      ;; (add-hook 'deft-mode-hook 'my-overwrite-evil-ret-in-deft)
      )

  #+END_SRC
* TODO Projectile
  #+BEGIN_SRC emacs-lisp

    (use-package projectile
      :demand t
      :config
      (projectile-mode)
      )

    (use-package helm-projectile
      :after (projectile)
      :init
      (general-define-key :states 'normal
                          :prefix my-default-evil-leader-key
                          "p p" 'helm-projectile)
      )

    (use-package org-projectile
      :after (projectile)
      :init
      (general-define-key :states 'normal
                          :prefix my-default-evil-leader-key
                          "o p" 'org-projectile:project-todo-completing-read)
      :config
      (org-projectile:per-repo)
      (setq org-projectile:per-repo-filename ".todo.org"
            org-agenda-files (append org-agenda-files (org-projectile:todo-files)))
      (add-to-list 'org-capture-templates (org-projectile:project-todo-entry "o"))
      )


    ;; For when we're more comfortable with org
    ;; (use-package org-projectile
    ;;   :ensure t
    ;;   :after org
    ;;   :config
    ;;   (org-projectile:per-repo)
    ;;   (setq org-projectile:per-repo-filename ".todo.org"
    ;;         org-agenda-files (append org-agenda-files
    ;;                                  (org-projectile:todo-files))))

    ;; "]"        'org-projectile:template-or-project

  #+END_SRC
* Flycheck
  #+BEGIN_SRC emacs-lisp

    (use-package flycheck
      :disabled t
      ;; :demand t ;; this is very important
      ;; :hook (prog-mode . flycheck-mode-on-safe)
      ;; (add-hook 'prog-mode-hook 'flycheck-mode-on-safe)
      )

  #+END_SRC
* TODO Completion
  #+BEGIN_SRC emacs-lisp

    (use-package yasnippet
      :demand t
      :commands yas-expand-snippet
      :bind(:map yas-keymap
                 ("C-j" . yas-next-field-or-maybe-expand)
                 ("C-k" . yas-prev-field))
      :init
      (general-define-key
       :states 'normal
       :prefix my-default-evil-leader-key
                          "s s" 'yas-new-snippet
                          "s a" 'yas-insert-snippet
                          "s f" 'yas-visit-snippet-file)
      :config
      (let ((my-snippet-dir (directory-file-name
                             (concat user-init-dir "/snippets"))))
        (setq-default yas-snippet-dirs `(,my-snippet-dir)))
      (yas-global-mode)
      (setq yas-indent-line 'auto
            yas-also-auto-indent-first-line t)
      (define-key snippet-mode-map [remap evil-save-and-close]
        'yas-load-snippet-buffer-and-close)
      (define-key snippet-mode-map [remap evil-save-modified-and-close]
        'yas-load-snippet-buffer-and-close)
      (define-key snippet-mode-map [remap evil-quit]
        'kill-this-buffer)
      )

    ;; auto-insert yasnippets
    ;; www.howardism.org/Technical/Emacs/templates-tutorial.html
    ;; (setq yas-snippet-dirs (append yas-snippet-dirs ))
    ;;;###autoload
    (defun /auto-insert-yasnippet ()
      "Replace text in buffer with snippet.
    Used for 'auto-insert'"
      (require 'yasnippet)
      (yas-minor-mode)
      (yas-expand-snippet (buffer-string) (point-min) (point-max)))

    (setq-default auto-insert-directory
                  (directory-file-name (concat user-init-dir "/auto-insert/")))
    (auto-insert-mode 1)
    (setq-default auto-insert-query nil
                  auto-insert 'other)
    (define-auto-insert "\\.el$"  ["elisp-template" /auto-insert-yasnippet])
    (define-auto-insert "\\.py$"  ["python-template" /auto-insert-yasnippet])
    (define-auto-insert "\\.h$"   ["cpp-h-template" /auto-insert-yasnippet])
    (define-auto-insert "\\.cpp$" ["cpp-template" /auto-insert-yasnippet])
    (define-auto-insert "\\.sh$"  ["sh-template" /auto-insert-yasnippet])
    (define-auto-insert "\\.php$" ["php-template" /auto-insert-yasnippet])

    (defun yas-with-comment (str)
      (format "%s%s%s" comment-start str comment-end))

    ;; this package doesn't seem to be doing anything
    ;; (use-package org-sync-snippets
    ;;   :ensure t
    ;;   :config
    ;;   (progn (require 'org)
    ;;          (add-hook 'yas-after-reload-hook 'org-sync-snippets-snippets-to-org)
    ;;          )
    ;;   )

    ;; https://github.com/smihica/emmet-mode
    ;; ;TODO: Write down the cheatsheet or something
    ;; https://docs.emmet.io/cheat-sheet/
    (use-package emmet-mode
      :diminish emmet-mode
      :bind (:map emmet-mode-keymap
                  ;; ("TAB" . emmet-expand-yas) ;; uses deprecated yas functions
                  ("TAB" . emmet-expand-line)
                  ;; ("C-j" . emmet-next-edit-point)
                  ;; ("C-k" . emmet-prev-edit-point)
                  )
      :init
      (add-hook 'sgml-mode-hook 'emmet-mode) ;; auto-start on any markup modes
      (add-hook 'css-mode-hook  'emmet-mode) ;; enable emmet's css abbreviation.
      (add-hook 'js2-mode-hook 'emmet-mode) ;; REACT and jsx
      :config
      (setq emmet-move-cursor-between-quotes t) ;; default nil
      )

    (use-package company
      :disabled t
      :bind(
            ;; :map evil-insert-state-map
            ;;      ("C-p" . company-complete)
            ;;      ("C-n" . company-complete)
            :map company-active-map
            ("C-j" . company-select-next)
            ("C-k" . company-select-previous)
            ("C-w" . evil-delete-backward-word))
      :hook (prog-mode . company-mode)
      :config
      (global-company-mode)
      ;; yasnippet integration
      ;; https://emacs.stackexchange.com/questions/10431/get-company-to-show-suggestions-for-yasnippet-names
      (progn (require 'yasnippet)
             (defvar company-mode/enable-yas t
               "Enable yasnippet for all backends.")
             (defun company-mode/backend-with-yas (backend)
               (if (or (not company-mode/enable-yas)
                       (and (listp backend)
                            (member 'company-yasnippet backend)))
                   backend
                 (append (if (consp backend)
                             backend
                           (list backend))
                         '(:with company-yasnippet))))
             (setq company-backends
                   (mapcar #'company-mode/backend-with-yas
                           company-backends))
             )
      ;; fci-mode makes the completion popup spaz.
      ;; this is an attempted workaround
      ;; https://github.com/company-mode/company-mode/issues/180
      (progn (defvar-local company-fci-mode-on-p nil)
             (defun company-turn-off-fci (&rest ignore)
               (when (boundp 'fci-mode)
                 (setq company-fci-mode-on-p fci-mode)
                 (when fci-mode (fci-mode -1))))

             (defun company-maybe-turn-on-fci (&rest ignore)
               (when company-fci-mode-on-p (fci-mode 1)))

             (add-hook 'company-completion-started-hook 'company-turn-off-fci)
             (add-hook 'company-completion-finished-hook 'company-maybe-turn-on-fci)
             (add-hook 'company-completion-cancelled-hook 'company-maybe-turn-on-fci)
             )
      (setq company-dabbrev-downcase nil
            company-dabbrev-ignore-case nil
            company-idle-delay 0.5
            company-require-match nil
            company-selection-wrap-around t)
      )

    ;; (use-package helm-company
    ;;   :config
    ;;   (evil-declare-key 'insert company-mode-map (kbd "C-SPC") 'helm-company)
    ;;   (evil-declare-key 'insert company-active-map (kbd "C-SPC") 'helm-company))

    (use-package company-quickhelp
      :after company
      :config
      (company-quickhelp-mode 0)
      (setq company-quickhelp-delay 1))

    ;; (use-package company-jedi
    ;;   :config
    ;;   (require 'company)
    ;;   (add-hook 'python-mode-hook 'company-jedi)
    ;;   )

    ;; (use-package auto-insert
    ;;   :ensure t
    ;;   )

    (add-hook 'prog-mode-hook #'(lambda () (abbrev-mode -1)))

  #+END_SRC
* Tags
  #+BEGIN_SRC emacs-lisp
    (use-package counsel-etags)
  #+END_SRC
* Dired
  #+BEGIN_SRC emacs-lisp

    (general-define-key
     :states 'normal
     :keymaps 'dired-mode-map
      "<SPC>" nil ; was shadowing leader key bindings
      "C-l" 'dired-up-directory)

  #+END_SRC
* TODO Programming Languages

** TODO General Programming
   #+BEGIN_SRC emacs-lisp
     (use-package ctags-update
       :init
       (autoload 'turn-on-ctags-auto-update-mode "ctags-update"
         "turn on 'ctags-auto-update-mode'." t))

     (use-package dumb-jump
       :demand t
       :diminish dumb-jump-mode)

     ;; We don't use this global binding and run it per programming mode because
     ;; nearly everyone inherits from prog-mode for whatever goddammed reason and
     ;; it's shadowing some pretty important binds

     ;; (evil-declare-key 'insert 'prog-mode-map
     ;;   (kbd "RET") 'comment-indent-new-line)

     (add-hook 'prog-mode-hook #'/treat-underscore-as-word)
   #+END_SRC
** TODO General Web Development
   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :mode (("\\.phtml\\'" . web-mode)
              ("\\.tpl\\.php\\'" . web-mode)
              ("\\.[agj]sp\\'" . web-mode)
              ("\\.as[cp]x\\'" . web-mode)
              ("\\.erb\\'" . web-mode)
              ("\\.mustache\\'" . web-mode)
              ("\\.djhtml\\'" . web-mode))
       )

     (use-package js2-mode
       :pin gnu
       :mode ("\\.js\\'" . js2-mode)
       )

     ;; not sure if this inherits from prog-mode
     (use-package groovy-mode
       :mode ("\\Jenkinsfile\\'" . groovy-mode)
       :general
       (:states 'insert
        :keymaps 'groovy-mode-map
        "RET" 'comment-indent-new-line)
       :config
       (progn (require 'fill-column-indicator)
              (add-hook 'groovy-mode-hook 'turn-on-fci-mode))
       (progn (require 'hl-todo)
              (add-hook 'groovy-mode-hook 'hl-todo-mode))
       (add-hook 'groovy-mode-hook #'/treat-underscore-as-word)
       )

     (use-package php-mode
       :mode ("\\.php\\'" . php-mode)
       :general
       (:states 'insert
        :keymaps 'php-mode-map
        "RET" 'comment-indent-new-line))

     (use-package dockerfile-mode
       :mode ("\\Dockerfile\\'" . dockerfile-mode)
       :config
       (add-hook 'dockerfile-mode-hook 'hl-todo-mode))

     (use-package json-mode)

     (use-package markdown-mode
       :config
       (require 'org)
       (add-hook 'markdown-mode-hook 'orgtbl-mode)
       (add-hook 'markdown-mode-hook 'turn-on-fci-mode))

     (use-package yaml-mode
       :config
       (add-hook 'yaml-mode-hook 'turn-on-fci-mode))

     (use-package helm-emmet)

   #+END_SRC
** TODO Rust
   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode
       :mode ("\\.rs\\'" . rust-mode)
       :config
       (general-define-key :states 'insert
                           :keymaps 'rust-mode-map
                           "RET" 'comment-indent-new-line))
   #+END_SRC
** TODO Python

   #+BEGIN_SRC emacs-lisp
     (use-package company-jedi
       :init
       (add-hook 'python-mode-hook #'(lambda ()
                                       (add-to-list 'company-backends 'company-jedi))))

     (use-package flycheck-mypy
       :after flycheck
       :init
       (add-hook 'python-mode-hook #'(lambda ()
                                       (require 'flycheck)
                                       (add-to-list 'flycheck-disabled-checkers 'python-flake8)
                                       (add-to-list 'flycheck-disabled-checkers 'python-pylint)
                                       (add-to-list 'flycheck-disabled-checkers 'python-pycompile)
                                       (add-to-list 'flycheck-python-mypy-args "--ignore-missing-imports")
                                       (flycheck-mode))))

     ;; remove really dumb indentation rule when inside docstring
     ;; NOTE: it appears that :inside-docstring isn't documented
     ;; https://emacs.stackexchange.com/questions/26435/how-can-i-disable-indentation-rules-within-docstrings-in-python-mode
     (when (and (>= emacs-major-version 25)
                (>= emacs-minor-version 1))
       (defun my-python-mode-noindent-docstring (&optional _previous)
         (when (eq (car (python-indent-context)) :inside-docstring)
           'noindent))
       (advice-add 'python-indent-line :before-until #'my-python-mode-noindent-docstring))

     (with-eval-after-load 'python
       (general-define-key :states 'insert
                           :keymaps 'python-mode-map
                           "RET" 'comment-indent-new-line))
   #+END_SRC
** TODO C++
    #+BEGIN_SRC emacs-lisp
      ;; We are disabling this for the moment because the irony server is crashing all
      ;; the time and the input lag is annoying
      (use-package irony
        :disabled t
        :init
        (add-hook 'c++-mode-hook 'irony-mode)
        (add-hook 'c-mode-hook 'irony-mode)
        (add-hook 'objc-mode-hook 'irony-mode)
        (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
        :config
        ;; Windows performance tweaks
        ;;
        (when (boundp 'w32-pipe-read-delay)
          (setq w32-pipe-read-delay 0))
        ;; Set the buffer size to 64K on Windows (from the original 4K)
        (when (boundp 'w32-pipe-buffer-size)
          (setq irony-server-w32-pipe-buffer-size (* 64 1024)))
        )

      (use-package company-irony
        :disabled t
        :after (:all company irony)
        :defer nil
        :config
        (add-to-list 'company-backends 'company-irony)
        )

      ;; treat .h files as cpp files
      (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))

      ;; gnu indent style is mildly retarded
      (setq-default c-default-style "k&r"
                    c-basic-offset 4)

      (defun my-cpp-mode-configs ()
        "Configurations for c++-mode, since it doesn't have"
        (setq tab-width 4)
        (with-eval-after-load 'flycheck
          (defun my-disable-flycheck-clang-checker ()
            ;;We disable the clang checker for pretty much the same reason we disabled
            ;;irony
            (add-to-list 'flycheck-disabled-checkers 'c/c++-clang))
          (add-hook 'flycheck-mode-hook 'my-disable-flycheck-clang-checker)
          (flycheck-mode -1))
        (with-eval-after-load 'company
          (make-local-variable 'company-backends)
          (let ((curr-backends company-backends)
                (new-backends (list)))
            (dolist (backend curr-backends)
              (unless (equal (car backend) 'company-clang)
                (add-to-list 'new-backends backend)))
            (setq company-backends new-backends))
          (company-mode -1)
          (global-company-mode -1))
        )

      (add-hook 'c++-mode-hook 'my-cpp-mode-configs)

      (general-define-key :states 'insert
                          :keymaps 'c-mode-base-map
                          "RET" 'comment-indent-new-line)


      ;; we don't electric pair <> because it interferes with << operators

      ;; ;; add < > electric pairing
      ;; (defvar $c++-electric-pairs '((?< . ?>))
      ;;   "Additional electric pairs for c++")

      ;; (defun $c++-mode-add-pairs ()
      ;;   (setq-local electric-pair-pairs (append electric-pair-pairs
      ;;                                           $c++-electric-pairs))
      ;;   (setq-local electric-pair-text-pairs electric-pair-pairs))

      ;; (add-hook 'c++-mode-hook #'$c++-mode-add-pairs)

      ;; make sure that this is running clang-format 7 or something. A newer version
      (use-package clang-format
        :commands (clang-format-region
                   clang-format-buffer
                   clang-format)
        :init
        ;; IF there is a .clang-format, then use that to format before saving
        (defun my-clang-format-before-save ()
          (require 'projectile)
          (when (f-exists? (expand-file-name ".clang-format" (projectile-project-root)))
            (add-hook 'before-save-hook 'clang-format-buffer t t)))
        (add-hook 'c++-mode-hook #'my-clang-format-before-save)
        ;; (add-to-list 'aggressive-indent-excluded-modes 'c++-mode)
        :custom
        (clang-format-style-option "file"
                                   "read from .clang-format"))

      (use-package cmake-mode
        :mode ("\\cmakelists.txt\\'" . cmake-mode)
        :config
        (add-hook 'cmake-mode-hook 'hl-todo-mode)
        )

      (use-package cmake-font-lock
        :after cmake-mode
        :demand t)
    #+END_SRC
*** CMake

** TODO Typescript
   #+BEGIN_SRC emacs-lisp
     (use-package typescript-mode
       :mode ("\\.tsx\\'" . typescript-mode)
       )

     (use-package tide
       :after typescript-mode
       :init
       (add-hook 'typescript-mode-hook 'tide-setup)
       :config
       (add-hook 'before-save-hook 'tide-format-before-save)
       )
   #+END_SRC

** TODO Lisp
   NOTE: We want to carefully override this
   https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned
   https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94

   #+BEGIN_SRC emacs-lisp
     (defun my-updated-lisp-indent-function (indent-point state)
       "This function is the normal value of the variable `lisp-indent-function'.
     The function `calculate-lisp-indent' calls this to determine
     if the arguments of a Lisp function call should be indented specially.

      INDENT-POINT is the position at which the line being indented begins.
      Point is located at the point to indent under (for default indentation);
      STATE is the `parse-partial-sexp' state for that position.

      If the current line is in a call to a Lisp function that has a non-nil
      property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
      it specifies how to indent.  The property value can be:

      ,* `defun', meaning indent `defun'-style
      (this is also the case if there is no property and the function
      has a name that begins with \"def\", and three or more arguments);

      ,* an integer N, meaning indent the first N arguments specially
     (like ordinary function arguments), and then indent any further
     arguments like a body;

      ,* a function to call that returns the indentation (or nil).
     `lisp-indent-function' calls this function with the same two arguments
     that it itself received.

     This function returns either the indentation to use, or nil if the
     Lisp function does not specify a special indentation."
       (let ((normal-indent (current-column))
             (orig-point (point)))
         (goto-char (1+ (elt state 1)))
         (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
         (cond
          ;; car of form doesn't seem to be a symbol, or is a keyword
          ((and (elt state 2)
                (or (not (looking-at "\\sw\\|\\s_"))
                    (looking-at ":")))
           (if (not (> (save-excursion (forward-line 1) (point))
                       calculate-lisp-indent-last-sexp))
               (progn (goto-char calculate-lisp-indent-last-sexp)
                      (beginning-of-line)
                      (parse-partial-sexp (point)
                                          calculate-lisp-indent-last-sexp 0 t)))
           ;; Indent under the list or under the first sexp on the same
           ;; line as calculate-lisp-indent-last-sexp.  Note that first
           ;; thing on that line has to be complete sexp since we are
           ;; inside the innermost containing sexp.
           (backward-prefix-chars)
           (current-column))
          ((and (save-excursion
                  (goto-char indent-point)
                  (skip-syntax-forward " ")
                  (not (looking-at ":")))
                (save-excursion
                  (goto-char orig-point)
                  (looking-at ":")))
           (save-excursion
             (goto-char (+ 2 (elt state 1)))
             (current-column)))
          (t
           (let ((function (buffer-substring (point)
                                             (progn (forward-sexp 1) (point))))
                 method)
             (setq method (or (function-get (intern-soft function)
                                            'lisp-indent-function)
                              (get (intern-soft function) 'lisp-indent-hook)))
             (cond ((or (eq method 'defun)
                        (and (null method)
                             (> (length function) 3)
                             (string-match "\\`def" function)))
                    (lisp-indent-defform state indent-point))
                   ((integerp method)
                    (lisp-indent-specform method state
                                          indent-point normal-indent))
                   (method
                    (funcall method indent-point state))))))))

     (advice-add 'lisp-indent-function :override 'my-updated-lisp-indent-function)

     (use-package rainbow-delimiters
       :init
       (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
       )

     (use-package suggest)

     (use-package elmacro)

     (use-package elisp-slime-nav
       :diminish elisp-slime-nav-mode
       :bind
       (:map elisp-slime-nav-mode-map
        ("C-:" . eval-last-sexp))
       :init
       (defun my-elisp-mode ()
         (elisp-slime-nav-mode)
         (turn-on-eldoc-mode))
       (add-hook 'emacs-lisp-mode-hook 'my-elisp-mode)
       )

     (with-eval-after-load 'elisp-mode
       (general-define-key :states 'insert
                           :keymaps 'emacs-lisp-mode-map
                           "RET" 'comment-indent-new-line))
   #+END_SRC

* TODO Shell

  No line numbers in shell emulations, it makes no sense.
  #+BEGIN_SRC emacs-lisp
    (add-hook 'comint-mode-hook #'my-disable-line-numbers)
  #+END_SRC

** Multi-term
   term-mode normally doesn't allow multiple shells, this one does.

   #+BEGIN_SRC emacs-lisp
     (use-package multi-term
       :after (evil)
       :init
       (evil-ex-define-cmd "te[rminal]" 'multi-term)
       ;; I do not understand how this works, and it worries me some.
       ;; (add-hook 'term-mode-hook #'(lambda ()
       ;;                               (evil-local-set-key 'motion (kbd "RET") 'term-send-input)
       ;;                               (evil-local-set-key 'insert (kbd "RET") 'term-send-input)
       ;;                               ))
       ;; :config
       ;; (evil-make-overriding-map term-mode-map)

       ;; I do not understand why this does *not* work and yet the lambda one does,
       ;; and it worries me quite a bit

       ;; (general-define-key
       ;;  :states '(motion insert)
       ;;  :keymaps 'local
       ;;  "RET" 'term-send-input)
       )
   #+END_SRC

** Eshell
   It's passable, though I would expect =shell= itself to be better, in my opinion

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'eshell
       (evil-set-initial-state 'eshell-mode 'insert)
       (add-hook 'eshell-mode-hook #'my-disable-line-numbers)
       (add-hook 'eshell-mode-hook #'/treat-underscore-as-word)
       ;; (defun my-overwrite-evil-ret-in-eshell ()
       ;;   "attempts to make evil-ret in shell modes do things like send input"
       ;;   (message "Attempting to overwrite RET for eshell")
       ;;   ;; (with-eval-after-load 'evil-config
       ;;   ;;   (define-))
       ;;   (evil-local-set-key 'insert
       ;;                       (kbd "RET") 'eshell-send-input)
       ;;   (evil-local-set-key 'normal
       ;;                       (kbd "RET") 'eshell-send-input)
       ;;   (evil-local-set-key 'motion
       ;;                       (kbd "RET") 'eshell-send-input)
       ;;   )
       ;; (add-hook 'eshell-mode-hook 'my-overwrite-evil-ret-in-eshell)
       ;; (defun my-evil-shell-hook ()
       ;;   "Whenever we enter insert mode we go to the end of line"
       ;;   )
       ;; (add-hook 'evil-insert-state-entry-hook 'evil-goto-line)
       )
   #+END_SRC

** Powershell
   #+BEGIN_SRC emacs-lisp
     (use-package powershell)
   #+END_SRC

* Diff
  #+BEGIN_SRC emacs-lisp
    (use-package evil-ediff
      :after (evil)
      :demand t)
  #+END_SRC

* LaTeX

** TODO Auctex

   #+BEGIN_SRC emacs-lisp

     (use-package auctex)

   #+END_SRC

** Latex Textobjects
   I appear to have stolen this from somewhere, probably because the original
   package isn't being maintained or something

   | Key | Description                          |
   |-----+--------------------------------------|
   | =$= | Inline math ($$)                     |
   | =\= | Display math (=\[ \]=)               |
   | =m= | TeX macros (\foo{})                  |
   | =E= | Tex environments (\begin{}...\end{}) |

   #+BEGIN_SRC emacs-lisp

     (use-package evil-latex-textobjects
       :load-path "local-packages/"
       :demand t
       :general
       (:keymaps 'evil-latex-textobjects-inner-map
        "e" nil
        "E" 'evil-latex-textobjects-inner-env)
       (:keymaps 'evil-latex-textobjects-outer-map
        "e" nil
        "E" 'evil-latex-textobjects-an-env)
       :config
       (add-hook 'LaTeX-mode-hook 'turn-on-evil-latex-textobjects-mode))

   #+END_SRC

* TODO Japanese
  The kkc-mode is packaged with emacs, and isn't a package on elpa or anything

  - [ ] Bind a separate keybind instead of using =default-input-method=
  - [ ] Figure out and document =kkc-map=

  #+BEGIN_SRC emacs-lisp
    ;; NOTE: kkc isn't in any package repo so don't use-package this
    (require 'kkc)
    (eval-after-load "kkc"
      (progn
        (setq default-input-method "japanese"
              kkc-show-conversion-list-count 1)
        ;; (define-key kkc-keymap (kbd "SPC")       'kkc-terminate)
        ;; (define-key kkc-keymap (kbd "<tab>")     'kkc-next)
        ;; (define-key kkc-keymap (kbd "<backtab>") 'kkc-prev)
        )
      )
  #+END_SRC

* Finance

** Ledger-mode
   A finance minor-mode that we use

   #+BEGIN_SRC emacs-lisp

     (use-package ledger-mode
       :init
       (setq ledger-clear-whole-transactions 1)
       :config
       (add-to-list 'evil-emacs-state-modes 'ledger-report-mode)
       :mode ("\\.dat\\'"
              "\\.ledger\\'")
       )

   #+END_SRC

*** Evil Configuration
    Evilify ledger-mode

    - Github :: https://github.com/atheriel/evil-ledger


    Adds a transaction textobject bound to =x=

    #+BEGIN_SRC emacs-lisp

      (use-package evil-ledger
        :after (:all evil ledger-mode)
        :demand t
        :config
        (add-hook 'ledger-mode-hook #'evil-ledger-mode))

    #+END_SRC

* TODO Web Browsing

** TODO Emacs Web Wowser
   This is a web browser that lives as an emacs buffer.

   I still need to configure it to be more vimium-like

   #+BEGIN_SRC emacs-lisp
     (use-package eww
       :general
       (:states 'normal
        :prefix my-default-evil-leader-key
        "w w w" 'eww)
       (:keymaps 'eww-mode-map
        :states 'normal
        "f" 'ace-link-eww)

       :config
       ;; https://github.com/GriffinSchneider/emacs-config/blob/master/eww-customizations.el
       (defvar gcs-shr-width 110)

       ;; eww stupidly overrides shr-width before calling shr-insert-document to render a page. So,
       ;; un-override it.
       (defadvice shr-insert-document (around force-shr-width activate)
         (let ((shr-width (min (1- (window-width)) gcs-shr-width)))
           ad-do-it))

       (defun eww-increase-width ()
         (interactive)
         (make-local-variable 'gcs-shr-width)
         (setq gcs-shr-width  (+ 10 gcs-shr-width))
         (eww-reload))
       (define-key eww-mode-map (read-kbd-macro "+") 'eww-increase-width)

       (defun eww-decrease-width ()
         (interactive)
         (make-local-variable 'gcs-shr-width)
         (setq gcs-shr-width  (- gcs-shr-width 10))
         (eww-reload))
       (define-key eww-mode-map (read-kbd-macro "-") 'eww-decrease-width)

       ;; Use vim kebindings for searching
       (define-key eww-mode-map (read-kbd-macro "/") 'evil-search-forward)
       (define-key eww-mode-map (read-kbd-macro "?") 'evil-search-backward)
       (define-key eww-mode-map (read-kbd-macro "n") 'evil-search-next)
       (define-key eww-mode-map (read-kbd-macro "N") 'evil-search-previous)

       ;; Use vim keybindings for scrolling
       (define-key eww-mode-map (read-kbd-macro "j") 'evil-next-line)
       (define-key eww-mode-map (read-kbd-macro "k") 'evil-previous-line)
       ;; (define-key eww-mode-map (read-kbd-macro "C-j") (lambda () (interactive) (next-line 2) (scroll-up 2)))
       ;; (define-key eww-mode-map (read-kbd-macro "C-k") (lambda () (interactive) (scroll-down 2) (previous-line 2)))
       (define-key eww-mode-map (read-kbd-macro "d") 'evil-scroll-down)
       (define-key eww-mode-map (read-kbd-macro "u") 'evil-scroll-up)

       ;; Use sane keybindings for forward/back
       (evil-define-key 'normal 'eww-mode-map "H" 'eww-back-url)
       (evil-define-key 'normal 'eww-mode-map "L" 'eww-forward-url)

       ;; (defun my-eww-init-hook ()
       ;;    "docstring for foo"
       ;;    (evil-snipe-override-mode -1))
       ;; (add-hook 'eww-mode-hook 'my-eww-init-hook)
       )
   #+END_SRC

* TODO Utility

** Datetime
   These code was written by Kenny Liu a long ass time ago, I don't think it's
   being used at all

   #+BEGIN_SRC emacs-lisp
     ;;;###autoload
     (defvar current-date-time-format "%Y-%m-%dT%H:%M:%S"
       "Format of date to insert with `insert-current-date-time' func.
     See help of `format-time-string' for possible replacements")

     ;;;###autoload
     (defun insert-current-date-time ()
       "Insert the current date and time into current buffer.
     Uses `current-date-time-format' for the formatting the date/time."
       (interactive)
       (insert (format-time-string current-date-time-format (current-time))))
   #+END_SRC

** Encryption
   The file-level kind. Probably not as well integrated as I hoped.

   #+BEGIN_SRC emacs-lisp
     (require 'epa-file)
     (epa-file-enable)
   #+END_SRC

** Restarting Emacs
   This tool allows us to restart emacs from within emacs

   #+BEGIN_SRC emacs-lisp
     (use-package restart-emacs
       :commands restart-emacs)
   #+END_SRC

** Epub viewing

   This doesn't actually work for now. I'll need to figure out how to make it
   work.

   #+BEGIN_SRC emacs-lisp
     (use-package nov
       :mode ("\\.epub\\'" . nov-mode)
       ;; :config
       ;; (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
       )
   #+END_SRC

** Pomodoro
   - Github :: https://github.com/TatriX/pomidor


   #+BEGIN_SRC emacs-lisp

     (use-package pomidor
       :general
       (:states 'normal
        :prefix my-default-evil-leader-key
        "c c" 'pomidor) :config
       (evil-set-initial-state 'pomidor-mode 'emacs)
       :custom
       (pomidor-default-alert 'mode-line))

   #+END_SRC

** PlantUML
   - Github :: https://github.com/skuro/plantuml-mode


   #+BEGIN_SRC emacs-lisp
     (use-package plantuml-mode
       :mode "\\.plantuml\\'"
       :config
       (when (boundp '/plantuml-jar)
         (setq plantuml-jar-path /plantuml-jar))
       (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
       (org-babel-do-load-languages
        'org-babel-load-languages '((plantuml . t)))
       )
   #+END_SRC

* Help

** Help+
   - Emacswiki :: https://www.emacswiki.org/emacs/HelpPlus


   These packages are from emacswiki, and are currently not being maintained.

   They are being stored and loaded locally, since they are not on melpa or any
   package manager

   #+BEGIN_SRC emacs-lisp
     (use-package help+
       :load-path "local-packages/"
       :demand t)

     (use-package help-macro+
       :load-path "local-packages/"
       :demand t)

     (use-package help-mode+
       :load-path "local-packages/"
       :demand t)

     (use-package help-fns+
       :load-path "local-packages/"
       :demand t)
   #+END_SRC

** Macrostep
   - Github :: https://github.com/joddie/macrostep


   This lets you step through macro invocations.

   #+BEGIN_SRC emacs-lisp

     (use-package macrostep)

   #+END_SRC

** Custom Mappings for =help-mode=

   =ace-link= is needed here.

   #+BEGIN_SRC emacs-lisp

     (general-define-key :states  'normal
                         :keymaps 'help-mode-map
                         "C-t"    'help-go-back
                         "C-]"    'help-follow
                         "f"      'ace-link-help)

   #+END_SRC

** Custom Mappings for =Info-mode=

   =ace-link= is needed here.

   #+BEGIN_SRC emacs-lisp

     (general-define-key :states  'normal
                         :keymaps 'Info-mode-map
                         "[ ["    'Info-prev
                         "] ]"    'Info-next
                         "f"      'ace-link-info
                         "SPC" nil)

   #+END_SRC
