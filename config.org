#+STARTUP: overview

[[https://necromuralist.github.io/posts/org-babel-cheat-sheet/][Org Babel Cheatsheet]]
[[https://org-babel.readthedocs.io/en/latest/eval/][Org Babel Reference Card]]
[[https://github.com/dfeich/org-babel-examples][Org Babel Examples]]

* On Hydras                                                       :hydra:doc:
[[https://github.com/abo-abo/hydra#awesome-docstring][Github source]]

This can be a simple string used to build the final hydra hint.
However, if you start it with a newline, the key-highlighting and
Ruby-style string interpolation becomes enabled.

To highlight a key, just wrap it in underscores (=_=). Note that the key
must belong to one of the heads. The key will be highlighted with the
color that is appropriate to the behavior of the key, i.e. if the key
will make the hydra exit, the color will be blue.

To insert an empty character, use =^=. The only use of this is to have
your code aligned as nicely as the result.

To insert a dynamic Elisp variable, use =%`= followed by the variable.
Each time the variable changes due to a head, the docstring will be
updated. format-style width specifiers can be used.

To insert a dynamic Elisp expression, use e.g. =%(length
(dired-get-marked-files))=. If a head will change the amount of marked
files, for example, it will be appropriately updated.

If the result of the Elisp expression is a string and you don't want
to quote it, use this form: =%s(shell-command-to-string "du -hs")=.

* Figure out Edebug and tracebacks
- [[http://endlessparentheses.com/debugging-emacs-lisp-part-1-earn-your-independence.html][Introduction part 1]]
- [[http://endlessparentheses.com/debugging-elisp-part-2-advanced-topics.html][Introduction part 2]]

** debugger-mode-map
0 .. 9                           digit-argument

TAB                              forward-button
RET                              debug-help-follow
ESC                              Prefix Command
SPC                              next-line
-                                negative-argument
R                                debugger-record-expression
b                                debugger-frame
c                                debugger-continue
d                                debugger-step-through
e                                debugger-eval-expression
h                                describe-mode
j                                debugger-jump
l                                debugger-list-functions
q                                top-level
r                                debugger-return-value
u                                debugger-frame-clear
v                                debugger-toggle-locals
<backtab>                        backward-button
<mouse-2>                        push-button
<normal-state>                   Prefix Command
<remap>                          Prefix Command

<normal-state> SPC              next-line
<normal-state> E                debugger-eval-expression
<normal-state> J                debugger-jump
<normal-state> L                debugger-toggle-locals
<normal-state> R                debugger-record-expression
<normal-state> Z                Prefix Command
<normal-state> c                debugger-continue
<normal-state> d                debugger-step-through
<normal-state> g                Prefix Command
<normal-state> p                debugger-toggle-locals
<normal-state> q                top-level
<normal-state> r                debugger-return-value
<normal-state> u                debugger-frame-clear
<normal-state> x                debugger-eval-expression
<normal-state> <S-tab>          backward-button
<normal-state> <return>         debug-help-follow
<normal-state> <tab>            forward-button

C-M-i                           backward-button

<normal-state> Z Q              evil-quit
<normal-state> Z Z              top-level

<normal-state> g b              debugger-frame
<normal-state> g l              debugger-list-functions

* Define useful constants
#+begin_src emacs-lisp :results output silent
  (when (boundp 'config-local-syncthing-folder)
    (unless (bound-and-true-p my-notes-folder)
      (defconst my-notes-folder (-> config-local-syncthing-folder
                                    (f-join "wiki"))))
    (defconst my-text-raw-folder (-> config-local-syncthing-folder
                                    (f-join "raw")))
    (defconst my-todo-org-file (-> config-local-syncthing-folder
                                    (f-join "todo.org")))
    (defconst my-text-routines-file (-> my-text-raw-folder
                                      (f-join "routines.org")))
    (defun find-user-syncthing-folder ()
      (interactive)
      (dired config-local-syncthing-folder)))
#+end_src

* General Faces
#+begin_src emacs-lisp :results output silent
  (custom-set-faces `(vertical-border ((((background light)) (:foreground ,sol-base3))
                                       (((background dark)) (:foreground ,sol-base03)))))
#+end_src

** Modelines
#+begin_src emacs-lisp :results output silent
  (custom-set-faces `(mode-line ((((background light))
                                  (:underline nil
                                   :overline nil
                                   :box nil
                                   :foreground ,sol-base1
                                   :background ,sol-base3))
                                 (((background dark))
                                  (:underline nil
                                   :overline nil
                                   :box nil
                                   :foreground ,sol-base01
                                   :background ,sol-base03)))))
  (custom-set-faces `(mode-line-active ((((background light))
                                         (:inherit mode-line
                                          :foreground ,sol-base1))
                                        (((background dark))
                                         (:inherit mode-line
                                          :foreground ,sol-base01)))))
  (custom-set-faces `(mode-line-inactive ((((background light))
                                           (:underline nil
                                            :overline nil
                                            :foreground ,sol-base2
                                            :background ,sol-base3
                                            :inherit mode-line))
                                          (((background dark))
                                           (:underline nil
                                            :overline nil
                                            :foreground ,sol-base02
                                            :background ,sol-base03
                                            :inherit mode-line)))))
  (custom-set-faces `(mode-line-highlight ((((background light))
                                            (:box nil :background ,sol-base2))
                                           (((background dark))
                                            (:box nil :background ,sol-base02)))))
  (custom-set-faces `(mode-line-buffer-id ((((background light))
                                            (:bold nil
                                             :foreground ,sol-base1))
                                           (((background dark))
                                            (:bold nil
                                             :foreground ,sol-base01)))))
#+end_src

** Header line
#+begin_src emacs-lisp :results output silent
  ;; (custom-set-faces '(header-line ((t (:inherit header-line :underline nil)))))
  ;; (set-face-underline 'header-line nil)
  (custom-set-faces '(header-line ((t (:inherit default :underline nil)))))
#+end_src

** Help Key binding
#+begin_src emacs-lisp :results output silent
  (custom-set-faces `(help-key-binding ((t (:box nil :background unspecified :foreground ,sol-yellow)))))
#+end_src

** Link
#+begin_src emacs-lisp :results output silent
  (custom-set-faces `(link ((t (:foreground ,sol-yellow :underline nil :bold t)))))
#+end_src
* Themes
** Base16
#+begin_src emacs-lisp :results output silent
  (use-package base16-theme
    ;; :straight (:host github :repo "belak/base16-emacs"
    ;;            :files (:defaults ("build" "build/*")))
    :straight t)
#+end_src
** Solarized
[[https://ethanschoonover.com/solarized/][Website with more descriptions]]

- Refer to docstring for =my-init-solarized-color-variables=.

#+begin_src emacs-lisp :results output silent
  (use-package solarized-theme
    :straight (:host github :repo "bbatsov/solarized-emacs")
    ;; :if (display-graphic-p)
    :custom
    (solarized-use-variable-pitch nil)
    (solarized-distinct-fringe-background nil)
    (solarized-high-contrast-mode-line nil)
    (solarized-use-less-bold t)
    (solarized-use-more-italic nil)
    (solarized-scale-org-headlines nil)
    (solarized-height-minus-1 1.0)
    (solarized-height-plus-1 1.0)
    (solarized-height-plus-2 1.0)
    (solarized-height-plus-3 1.0)
    (solarized-height-plus-4 1.0))
  ;; (defun load-solarized-theme ()
  ;;   (interactive)
  ;;   (if (display-graphic-p)
  ;;       (load-theme 'solarized-dark t)
  ;;     (load-theme 'solarized-gruvbox-dark t))
  ;;   (with-eval-after-load 'prism
  ;;     (prism-set-colors
  ;;      :num 24
  ;;      :colors
  ;;      ;; (list sol-green sol-cyan sol-blue sol-yellow)
  ;;      (list 'font-lock-keyword-face 'font-lock-type-face 'font-lock-variable-name-face)
  ;;      :desaturations
  ;;      (list 10 20 30)
  ;;      :lightens
  ;;      (list 0 -2.5 -5)))
  ;;   (with-eval-after-load 'hl-todo
  ;;     (customize-set-variable 'hl-todo-keyword-faces
  ;;                             '(("TODO"    . "#b58900")
  ;;                               ("DEBUG"   . "#d33682")
  ;;                               ("NOTE"    . "#586e75")
  ;;                               ("FIXME"   . "#cb4b16")))))
#+end_src

** Eva-02
Personal theme that I'm maintaining (really stealing shamelessly from
Solarized)

#+begin_src emacs-lisp :results output silent
  ;; (defun load-eva02-theme ()
  ;;   (interactive)
  ;;   (load-theme 'eva02 t)
  ;;   (with-eval-after-load 'prism
  ;;     (prism-set-colors
  ;;      :num 24
  ;;      :colors
  ;;      ;; (list 'font-lock-keyword-face 'font-lock-type-face 'font-lock-variable-name-face 'font-lock-function-name-face)
  ;;      (list 'font-lock-keyword-face
  ;;            'font-lock-builtin-face
  ;;            'font-lock-variable-name-face)
  ;;      :desaturations
  ;;      (list 10 20 30)
  ;;      :lightens
  ;;      ;; (list 0 -2.5 -5)))
  ;;      (list 0 5 10)))
  ;;   (with-eval-after-load 'hl-todo
  ;;     (customize-set-variable 'hl-todo-keyword-faces
  ;;                             '(("TODO"    . "#ff0000")
  ;;                               ("DEBUG"   . "#ff0000")
  ;;                               ;; ("NOTE"    . "#ff0000")
  ;;                               ("FIXME"   . "#ff0000")))))
#+end_src

** Nano
#+begin_src emacs-lisp :results output silent
    (use-package nano-theme
      :straight (:host github :repo "rougier/nano-theme")
      :commands (nano-light nano-dark nano-setup)
      :custom
      (nano-light-foreground sol-base1)
      (nano-light-background sol-base3)
      (nano-light-highlight sol-base2)
      (nano-light-subtle sol-base1)
      (nano-light-faded sol-base00)
      (nano-light-salient sol-cyan)
      (nano-light-strong sol-green)
      (nano-light-popout sol-blue)
      (nano-light-critical sol-red)

      (nano-dark-foreground sol-base01)
      (nano-dark-background sol-base03)
      (nano-dark-highlight sol-base02)
      (nano-dark-subtle sol-base01)
      (nano-dark-faded sol-base0)
      (nano-dark-salient nano-light-salient)
      (nano-dark-strong nano-light-strong)
      (nano-dark-popout nano-light-popout)
      (nano-dark-critical nano-light-critical))
#+end_src
** Display
#+begin_src emacs-lisp :results output silent
  ;; (when (display-graphic-p)
    ;; (load-solarized-theme))
    ;; (load-theme 'solarized-dark t))
    ;; (progn
    ;;  (load-theme 'solarized-light t)
    ;;  (customize-set-variable 'frame-background-mode 'light)))
  ;; (progn (nano-dark)
    ;;        (desktop-save-mode -1)))
  ;; (load-solarized-theme)
  ;; (load-eva02-theme)
#+end_src

* Quality of Life
** Frame Transparency
#+begin_src emacs-lisp :results output silent
  ;;;###autoload
  (defun my-set-frame-transparency (value)
    "Set the transparency of the frame window to VALUE.
  0=transparent/100=opaque"
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

** Highlight line
#+begin_src emacs-lisp :results output silent
  ;; (when (display-graphic-p)
  ;;  (global-hl-line-mode))
#+end_src

** Default input method
We're sticking to Japanese for now
#+begin_src emacs-lisp :results output silent
  (setq default-input-method "japanese")
#+end_src

** Recent files
#+begin_src emacs-lisp :results output silent
  (use-package recentf
    :ensure nil
    :custom
    (recentf-max-saved-items nil)
    :config
    (recentf-mode)
    (with-eval-after-load 'consult
      (evil-ex-define-cmd "recent" 'consult-recent-file)))
#+end_src

** Display Fill Column Indicator
#+begin_src emacs-lisp :results output silent
  (add-hook 'prog-mode-hook
            #'(lambda ()
               (display-fill-column-indicator-mode 'toggle)))
#+end_src

** Disable GUI Elements
#+begin_src emacs-lisp :results output silent
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (if (boundp 'scroll-bar-mode)
      (scroll-bar-mode -1))
  (window-divider-mode -1)
#+end_src

** Timestamp
Emulate the best feature of notepad

#+begin_src emacs-lisp :results output silent
  (defun --make-iso-8601-timestamp (with-hours)
    (insert (format-time-string (if with-hours "%FT%H%M" "%F"))))
  (general-define-key
   :states '(normal motion insert)
   "<f5>" #'(lambda () (interactive)
             (--make-iso-8601-timestamp nil))
   "S-<f5>" #'(lambda () (interactive)
               (--make-iso-8601-timestamp t)))
  (general-define-key
   :states '(normal)
   "gb" #'(lambda () (interactive)
           (--make-iso-8601-timestamp nil))
   "gB" #'(lambda () (interactive)
           (--make-iso-8601-timestamp t)))
#+end_src

** Do not truncate lines
#+begin_src emacs-lisp :results output silent
  (setq-default truncate-lines t)
#+end_src

** Open a startup file as initial buffer
#+begin_src emacs-lisp :results output silent
  ;; (customize-set-variable 'initial-buffer-choice
  ;;                         (locate-user-emacs-file "config.org"))
#+end_src

** Disable startup screen
#+begin_src emacs-lisp :results output silent
  (setq inhibit-startup-screen t)
#+end_src

** Change "yes or no" to "y or n"
#+begin_src emacs-lisp :results output silent
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Require newlines at the end of all files
#+begin_src emacs-lisp :results output silent
  (setq-default require-final-newline t)
#+end_src

** Disable alert sounds
#+begin_src emacs-lisp :results output silent
  (setq ring-bell-function 'ignore)
#+end_src

** Automatically refresh buffer when underlying file is changed externally
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'global-auto-revert-non-file-buffers t)
  (global-auto-revert-mode)
#+end_src

** Make window subprocess communications faster
#+begin_src emacs-lisp :results output silent
  (if (< emacs-major-version 27)
    (setq w32-pipe-read-delay 0))
#+end_src

** Set default tab width
#+begin_src emacs-lisp :results output silent
  (setq-default tab-width 4)
#+end_src

** Make <TAB> always indent
#+begin_src emacs-lisp :results output silent
  (setq tab-always-indent 'complete)
#+end_src

** Never indent with a TAB character
#+begin_src emacs-lisp :results output silent
  (setq-default indent-tabs-mode nil)
#+end_src

** Strip Whitespace on save
#+begin_src emacs-lisp :results output silent
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** Bind whitespace-mode
#+begin_src emacs-lisp :results output silent
  (general-define-key
   :states 'normal
   :prefix my-default-evil-leader-key
    "." 'whitespace-mode)
#+end_src

** Show trailing whitespace
actually, don't (outside of text modes)
#+begin_src emacs-lisp :results output silent
  (add-hook 'prog-mode-hook
    (customize-set-value 'show-trailing-whitespace t))
#+end_src

** After creating a new frame, immediately focus on that frame.
#+begin_src emacs-lisp :results output silent
  (add-hook 'after-make-frame-functions 'select-frame)
#+end_src

** Sentences should end after a single space, not two
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'sentence-end-double-space nil)
#+end_src

** Underscores should be considered as part of a word
#+begin_src emacs-lisp :results output silent
  (add-hook 'after-change-major-mode-hook #'(lambda () (modify-syntax-entry ?_ "w")))
#+end_src

** Ensure that files being edited are recoverable
#+begin_src emacs-lisp :results output silent
  (setq delete-old-versions t
        backup-by-copying t
        version-control t
        kept-new-versions 20
        kept-old-versions 5
        vc-make-backup-files t)
  (setq savehist-save-minibuffer-history 1
        savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
  (setq history-length t
        history-delete-duplicates t)
  (savehist-mode 1)
#+end_src

** Stretch caret to cover full width of character
http://pragmaticemacs.com/emacs/adaptive-cursor-width/
#+begin_src emacs-lisp :results output silent
  (setq x-stretch-cursor t)
#+end_src

** Display line numbers when editing code
#+begin_src emacs-lisp :results output silent
  (when (>= emacs-major-version 26)
    (add-hook 'prog-mode-hook 'display-line-numbers-mode))
#+end_src

#+begin_src emacs-lisp :results output silent
  (custom-set-faces `(line-number ((((background light)) (:background ,sol-base3 :foreground ,sol-base2))
                                   (((background dark)) (:background ,sol-base03 :foreground ,sol-base02)))))
  (custom-set-faces `(line-number-current-line ((((background light)) (:foreground ,sol-base1))
                                                (((background dark)) (:foreground ,sol-base01))
                                                (t (:inherit line-number)))))
#+end_src

** Show matching parens
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'show-paren-when-point-inside-paren t)
  (customize-set-variable 'show-paren-when-point-in-periphery t)
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+end_src

** Scroll like Vim
#+begin_src emacs-lisp :results output silent
  (setq scroll-step 1
        scroll-margin 1
        scroll-conservatively 9999)
#+end_src

** Activate hs-minor-mode on prog mode
#+begin_src emacs-lisp :results output silent
  (add-hook 'prog-mode-hook 'hs-minor-mode)
#+end_src

** Eval sexp and replace with results
Stolen from https://github.com/bbatsov/crux

#+begin_src emacs-lisp :results output silent
  ;; ;;;###autoload
  (defun --eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (let ((value (eval (elisp--preceding-sexp))))
      (backward-kill-sexp)
      (insert (format "%S" value))))
  (evil-ex-define-cmd "eval" #'--eval-and-replace)

  ;; ;;TODO: it's not working somehow
  ;; ;;;###autoload
  ;; (evil-define-command my-eval-and-replace (beg end _type)
  ;;   "Replace the preceding sexp with its value."
  ;;   (interactive "<v>")
  ;;   (let ((value (eval-region beg end (get-buffer (buffer-name)))))
  ;;     (insert (format "%S" value))))
  ;; (evil-ex-define-cmd "eval" 'eval-and-replace)
#+end_src

** Completion
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'completion-ignore-case t)
  (customize-set-variable 'read-file-name-completion-ignore-case t)
  (customize-set-variable 'read-buffer-completion-ignore-case t)
#+end_src

** Copy file name to keyboard
#+begin_src emacs-lisp :results output silent
  (defun my-kill-path-to-keyboard ()
    "https://stackoverflow.com/questions/2416655/file-path-to-clipboard-in-emacs"
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename))))
#+end_src

#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "ypath" 'my-kill-path-to-keyboard)
#+end_src

** Tags table defaults
#+begin_src emacs-lisp :results output silent
  (setq-default tags-add-tables nil)
#+end_src

** COMMENT If inside {}, [], or (), newline and indent
#+begin_src emacs-lisp :results output silent
  (defun config-block-insert-newline (list)
    "If the point is immediately bounded by {}, (), or [], indent it
    properly, given an alist of (BEFORE . AFTER) characters.
  Example, if the point is within {} like so {|}:
  When newline is pressed, turn it into {
      |
  }
  instead.
  "
    (interactive)
    (loop for (begin . end) in list
          when (and (string= begin (preceding-char))
                    (string= end (following-char)))
            do
            (newline)
            (indent-according-to-mode)
            (forward-line -1)
            (indent-according-to-mode)
            (return-from config-block-insert-newline)))
#+end_src

** Disable native compilation warnings
#+begin_src emacs-lisp :results output silent
  (when (and (featurep 'nativecomp) (native-comp-available-p))
    (customize-set-variable 'comp-async-report-warnings-errors nil))
#+end_src

** Set commands
#+begin_src emacs-lisp :results output silent
  (evil-define-command config-ex-set-arg (cmd)
    (interactive "<a>")
    (cond
     ((string= cmd "wrap") (visual-line-mode 1))
     ((string= cmd "nowrap") (visual-line-mode -1))
     ((string= cmd "fill") (progn (visual-line-mode 1)
                                  (require 'visual-fill-column)
                                  (visual-fill-column-mode 1)))
     ((string= cmd "nofill") (progn (visual-line-mode 0)
                                    (require 'visual-fill-column)
                                    (visual-fill-column-mode -1)))
     ;; This isn't actually how colorcolumn worked in vi
     ;; (read :h colorcolumn)
     ((or (string= cmd "colorcolumn")
          (string= cmd "cc")) (display-fill-column-indicator-mode
                               'toggle))))
  (evil-ex-define-cmd "set" 'config-ex-set-arg)
#+end_src

** Electric Indent
#+begin_src emacs-lisp :results output silent
  (electric-indent-mode)
#+end_src

** Buffer menu mode map config
#+begin_src emacs-lisp :results output silent
  (general-define-key
   :keymaps 'Buffer-menu-mode-map
   :states '(normal motion)
   "C-d" 'evil-scroll-down)
#+end_src

** Don't compact font caches
#+begin_src emacs-lisp :results output silent
  (customize-set-value 'inhibit-compacting-font-caches t)
#+end_src
** COMMENT Prefer dark backgrounds
#+begin_src emacs-lisp :results output silent
  (customize-set-variable 'frame-background-mode 'dark)
  (set-terminal-parameter nil 'background-mode 'dark)
#+end_src

** Fonts
We are preferring these fonts because they look nicer and play nicer
with Chinese/Japanese.

0123456789abcdefghijklmnopqrstuvwxyz [] () :;,. !@#$^&*
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ {} <> "'`  ~-_/|\?

#+begin_src emacs-lisp :results output silent
  (defun --set-fonts ()
    (cond
      ((find-font (font-spec :name "Iosevka")
        (cond
          ((eq system-type 'darwin) (set-frame-font "Iosevka-13" nil t))
          (t (set-frame-font "Iosevka-12" nil t)))))
      ((find-font (font-spec :name "Courier")) (set-frame-font "Courier-10" nil t)))
    (when (find-font (font-spec :name "Iosevka"))
      (custom-set-faces '(fixed-pitch ((t (:family "Iosevka")))))
      (custom-set-faces '(variable-pitch ((t (:family "Iosevka")))))
      (custom-set-faces '(fixed-pitch-serif ((t (:family "Iosevka"))))))
    (when (find-font (font-spec :name "Iosevka Etoile"))
      (custom-set-faces '(variable-pitch ((t (:family "Iosevka Etoile"))))))
    (when (find-font (font-spec :name "Iosevka Aile"))
      (custom-set-faces '(fixed-pitch-serif ((t (:family "Iosevka Aile")))))))

  (if (daemonp)
      (add-hook 'server-after-make-frame-hook #'--set-fonts)
    (--set-fonts))
#+end_src

TODO:
- [ ] Update variable-pitch to use iosevka-aile
- [ ] Update fixed-pitch and fixed-pitch-serif

** Emacs bookmarks
Save bookmarks immediately.
#+begin_src emacs-lisp :results output silent
  (setq bookmark-save-flag 1)
#+end_src

Further helper functions to add bookmarks:
#+begin_src emacs-lisp :results output silent
  ;;;###autoload
  (defun config-define-bookmark (name path &optional overwrite annotation)
    "Programmatically creates and stores bookmarks into the bookmark file.
  We do this here because as of 2019-04-01T16:13:14+0800 we have no idea
  if there is an existing interface to do this. If one is found this
  will be marked obsolete and we'll move to that instead.

  The bookmark list format is found at `bookmark-alist'.

  NAME - Name of the bookmark.
  PATH - filepath of the bookmark.
  OVERWRITE - if true, overwrite an existing bookmark of the same name
  if one currently exists.
  ANNOTATION - Optional annotation of the bookmark.

  If PATH does not point to anywhere valid, this function is a no-op and
  no bookmark will be created."
    (require 'bookmark)
    (when (file-exists-p path)
      (let* ((annot (if annotation annotation ""))
             (alist `((filename . ,path)
                      (front-context-string . "")
                      (rear-context-string . "")
                      (position . 0)
                      (annotation . ,annot))))
         (bookmark-store name alist overwrite))))
#+end_src

#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'consult
    (my-evil-define-split-vsplit-cmd
     "mm"
     #'(lambda ()
         (interactive)
         (require 'consult)
         (call-interactively 'consult-bookmark))))

  (evil-ex-define-cmd
   "Tmm"
   #'(lambda ()
       (interactive)
       (let* ((bookmark (--completing-read "Bookmark: " bookmark-alist
                                           :require-match t))
              (filepath (a-get-in bookmark-alist `(,bookmark filename))))
         (if (>= emacs-major-version 27)
             (let ((tab-bar-new-tab-choice filepath))
               (tab-bar-new-tab))
           (my-evil-new-tab filepath)))))
#+end_src

*** Bookmark Face
#+begin_src emacs-lisp :results output silent
  (custom-set-faces '(bookmark-face ((t (:inherit sol-subtle)))))
#+end_src

*** Save Config, Init, and Local as bookmarks
#+begin_src emacs-lisp :results output silent
  (config-define-bookmark "init" user-init-file)
  (config-define-bookmark "config" user-config-file)
  (config-define-bookmark "local" user-local-file)
#+end_src

** Doctor mode
#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "doc[tor]" 'doctor)
#+end_src

** Tab bar mode                                                          :27:
This only works if emacs version is 27 or above (there's already some
evil integration), refer to Eyebrowse for Emacs version <27 tab handling
#+begin_src emacs-lisp :results output silent
  (use-package tab-bar
    :ensure nil
    :straight nil
    :if (>= emacs-major-version 27)
    :custom-face
    (tab-bar ((t (:inherit minibuffer-prompt :underline nil))))
    (tab-bar-tab ((t (:inherit success :foreground nil :background nil))))
    (tab-bar-tab-inactive ((t (:inherit default :foreground nil :background nil))))
    :custom
    (tab-bar-close-last-tab-choice 'delete-frame)
    (tab-bar-new-tab-choice t)
    (tab-bar-close-button-show nil)
    (tab-bar-new-button-show nil)
    (tab-bar-close-tab-select 'left)
    (tab-bar-new-button nil)
    (tab-bar-new-tab-to 'right)
    :config
    (tab-bar-mode)
    (evil-ex-define-cmd "gt" 'tab-bar-switch-to-next-tab)
    (evil-ex-define-cmd "gT" 'tab-bar-switch-to-prev-tab)
    (evil-define-command my-tab-bar-tab-edit (file)
      (interactive "<f>")
      (let ((tab-bar-new-tab-choice (if file file "*scratch*")))
        (tab-bar-new-tab)))
    (evil-ex-define-cmd "tabn[ew]" 'my-tab-bar-tab-edit)
    (evil-ex-define-cmd "tabe[dit]" 'tab-bar-new-tab)
    ;;TODO: currently has issue where :q on a tab kills emacs
    (evil-ex-define-cmd "tabc[lose]" 'tab-bar-close-tab)
    (evil-ex-define-cmd "tabr[ename]" 'tab-bar-rename-tab)
    (evil-ex-define-cmd "tabs" 'tab-bar-select-tab-by-name)
    (evil-ex-define-cmd "tt" 'tab-bar-select-tab-by-name)
    (defun --tab-bar-tab-name-fn ()
      (require 'project)
      (let ((buffer-name (-> (minibuffer-selected-window)
                             (window-buffer)
                             (buffer-name))))
        (if-let ((project-info (project-current)))
            (format "%s(%s)" buffer-name (project-root project-info))
          (format "%s" buffer-name))))
    ;; (customize-set-value 'tab-bar-tab-name-function #'--tab-bar-tab-name-fn)
    (customize-set-value 'tab-bar-tab-name-function #'tab-bar-tab-name-truncated)

    (define-advice delete-frame (:around (oldfun &rest _old_args)
                                         --tab-bar-delete-tab-or-emacs)
      (interactive)
      (let* ((tabs (find-if (lambda (elem) (eq 'tabs (car elem)))
                            (frame-parameters)))
             (num-tabs (length (cdr tabs))))
        (if (eq num-tabs 1)
            (call-interactively oldfun)
          (tab-bar-close-tab)))))
#+end_src

** TODO Tab line mode
Tab line is like tab bar but for windows

** Desktop mode
#+begin_src emacs-lisp :results output silent
  ;;(desktop-save-mode)
#+end_src

** Open Email command
#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "inbox"
                      #'(lambda ()
                          (interactive)
                          ;;TODO: Find out a way to always open the same
                          ;;tab so I don't have to constantly relog in.
                          (browse-url "https://beta.protonmail.com")))
#+end_src

** EDiff qol
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'ediff
    (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

** Function to find all parent modes
I wrote this for =fci-mode= restarting then I figured I could just check
for the existence of =fci-mode= instead of finding through all the modes
for the specific hook.
#+begin_src emacs-lisp :results output silent
  (defun my-find-major-mode-parents (mode)
    "Recursively composes a list of all parent modes for a given
  mode."
    (when mode
      (cons mode
            (my-find-major-mode-parents (get-mode-local-parent mode)))))
#+end_src

** Add :repl for ielm
#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "repl" 'ielm)
#+end_src

** Set fill column
#+begin_src emacs-lisp :results output silent
  (customize-set-value 'fill-column 80)
#+end_src

** Move Auto-Save files into directory
#+begin_src emacs-lisp :results output silent
  (let ((dir (f-join no-littering-etc-directory "auto-save/")))
    (unless (f-exists-p dir)
      (f-mkdir dir))
    (add-to-list 'auto-save-file-name-transforms
                `(".*" ,dir t)))
#+end_src

** Enable saving bufferplaces
#+begin_src emacs-lisp :results output silent
  (save-place-mode 1)
#+end_src

** Disable dialog boxes
#+begin_src emacs-lisp :results output silent
  (customize-set-value 'use-dialog-box nil)
#+end_src

** Pixel scroll precision (for mouse scrolling)
#+begin_src emacs-lisp :results output silent
  (when (boundp 'pixel-scroll-precision-mode)
    (pixel-scroll-precision-mode))
#+end_src

** Hotkeys for =vc-annotate-mode=
#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "gl" 'vc-annotate)
#+end_src

** Detailed Completions
#+begin_src emacs-lisp :results output silent
  (customize-set-value 'completions-detailed t)
#+end_src

** Resize frames pixelwise
#+begin_src emacs-lisp :results output silent
  (setq frame-resize-pixelwise t)
#+end_src

* Apropos Configuration
#+begin_src emacs-lisp :results output silent
  (use-package apropos
    :ensure nil
    :straight nil
    :custom
    (apropos-do-all t)
    :init
    (evil-define-command my-apropos (pattern)
      (interactive "<a>")
      (apropos pattern))
    (evil-ex-define-cmd "h[elp]" 'my-apropos))
#+end_src

* Which Key
#+begin_src emacs-lisp :results output silent
  (use-package which-key
    :straight (:host github :repo "justbur/emacs-which-key")
    :demand t
    :custom
    (which-key-use-C-h-commands nil)
    (which-key-is-verbose t)
    (which-key-popup-type 'side-window)
    (which-key-side-window-max-width 0.33)
    (which-key-max-display-columns nil)
    (which-key-show-docstrings t)
    (which-key-side-window-location 'bottom)
    ;; :general
    ;; (:states 'normal
    ;;  "C-h M-k" 'which-key-show-keymap
    ;;  "C-h M-m" 'which-key-show-full-major-mode)
    :config
    (which-key-mode))
#+end_src

* Avy
** Ace Window
#+begin_src emacs-lisp :results output silent
  (use-package ace-window
    :straight t
    :general
    (evil-window-map
     "g p" 'ace-window
     "g x" 'ace-swap-window)
    :custom
    (aw-keys '(?a ?s ?d ?f ?g))
    :custom-face
    (aw-background-face ((((background light)) (:background ,sol-base3 :foreground ,sol-base2))
                         (((background dark)) (:background ,sol-base03 :foreground ,sol-base02)))))
#+end_src

** Ace Link
#+begin_src emacs-lisp :results output silent
  (use-package ace-link
    :straight (:host github :repo "abo-abo/ace-link")
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "f" 'ace-link)
    :commands (ace-link
               ace-link-eww))
#+end_src

* Smartparens

TODO: Make it so that if the point is inside {} or something similar,
pressing RET autoformats it, instead of doing nothing as it does right now

#+begin_src emacs-lisp :results output silent
  (use-package smartparens
    :straight (:host github :repo "Fuco1/smartparens")
    :defer 2
    :diminish smartparens-mode
    :commands (sp-local-pair
               smartparens-global-mode)
    :hook
    ;; TODO: make this not just hooked on prog-mode
    (prog-mode-hook . (lambda () (interactive)
                        (require 'smartparens-config) ;; load some default configurations
                        (require 'smartparens)))
    :custom-face
    (sp-pair-overlay-face ((t (:inherit default :underline nil))))
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "." 'smartparens-mode)
    :custom
    (sp-cancel-autoskip-on-backward-movement
     nil
     "We want to maintain the chomp-like behavior of electric-pair")
    (sp-autoskip-closing-pair
     'always
     "Maintain chomp-like behavior of electric-pair")
    :config
    (smartparens-global-mode)
    ;; (smartparens-global-strict-mode)
    ;; (show-smartparens-global-mode)
    ;; define some helper functions
    (defun my-add-newline-and-indent-braces (_opening_delimiter
                                             _actions
                                             _context)
      "adds that cool vim indent thing we always wanted, Refer to WHEN
    segment of `sp-pair' documentation on what each parameter does"
      (newline)
      (indent-according-to-mode)
      (forward-line -1)
      (indent-according-to-mode))
    ;; update the global definitions with some indenting
    ;; I think that the nil is the flag that controls property inheritance
    ;;note: for some reason tab isn't recognised. might be yasnippet intefering.
    ;;learn to use ret for now
    (sp-pair "{" nil :post-handlers '((my-add-newline-and-indent-braces "RET")))
    (sp-pair "[" nil :post-handlers '((my-add-newline-and-indent-braces "RET")))
    (sp-pair "(" nil :post-handlers '((my-add-newline-and-indent-braces "RET"))))
#+end_src

* Evil
** Alignment
#+begin_src emacs-lisp :results output silent
  (use-package evil-lion
    :straight (:host github :repo "edkolev/evil-lion")
    :after (evil)
    :general
    (:keymaps '(normal visual)
     "gl"     'evil-lion-left
     "gL"     'evil-lion-right))
#+end_src

** Evil Expat
Adds the following ex commands:

| :reverse           | reverse visually selected lines                                |
| :remove            | remove current file and its buffer                             |
| :rename NEW-PATH   | rename or move current file and its buffer                     |
| :colorscheme THEME | change emacs color theme                                       |
| :diff-orig         | get a diff of unsaved changes, like vim's common :DiffOrig     |
| :gdiff             | BRANCH git-diff current file, requires magit and vdiff-magit   |
| :gblame            | git-blame current file, requires magit                         |
| :gremove           | git remove current file, requires magit                        |
| :tyank             | copy range into tmux paste buffer, requires running under tmux |
| :tput              | paste from tmux paste nuffer, requires running under tmux      |

#+begin_src emacs-lisp :results output silent
  (use-package evil-expat
    :straight (:host github :repo "edkolev/evil-expat"))
#+end_src

** Matchit
#+begin_src emacs-lisp :results output silent
  (use-package evil-matchit
    :straight (:host github :repo "redguardtoo/evil-matchit")
    :after evil
    :config
    (global-evil-matchit-mode))
#+end_src

** Visualstar
Allows for * and # commands. which originally only worked on WORDs,
to work on a visual selection too

#+begin_src emacs-lisp :results output silent
  (use-package evil-visualstar
    :straight (:host github :repo "bling/evil-visualstar")
    :general
    (:keymaps 'visual
     "*" 'evil-visualstar/begin-search-forward
     "#" 'evil-visualstar/begin-search-backward))
#+end_src

** Input method Convenience toggle
https://www.emacswiki.org/emacs/Evil#toc24

#+begin_src emacs-lisp :results output silent
  (defun my-evil-toggle-input-method ()
    (interactive)
    (toggle-input-method))
    ;; (let ((is-insert-state (string= evil-state "insert")))
    ;;   (cond
    ;;    ((and (not current-input-method) (not is-insert-state)) (evil-insert-state))
    ;;    ((and current-input-method is-insert-state) (evil-normal-state))
    ;;    (t nil))
    ;;   (toggle-input-method)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (general-define-key
   :keymaps 'global
   "C-\\" 'my-evil-toggle-input-method)
#+end_src

** TODO Interactive Codes
Look at =evil-interactive-alist=, which seems to contain all the
interactive codes provided.

** Text Objects
*** Latex Textobjects
I appear to have stolen this from somewhere, probably because the original
package isn't being maintained or something

| Key | Description                          |
|-----+--------------------------------------|
| =$= | Inline math ($$)                     |
| =\= | Display math (=\[ \]=)               |
| =m= | TeX macros (\foo{})                  |
| =E= | Tex environments (\begin{}...\end{}) |

#+begin_src emacs-lisp :results output silent
  (use-package evil-latex-textobjects
    :straight nil
    :load-path "local-packages/"
    :commands (turn-on-evil-latex-textobjects-mode)
    :general
    (:keymaps 'evil-latex-textobjects-inner-map
     "e" nil
     "E" 'evil-latex-textobjects-inner-env)
    (:keymaps 'evil-latex-textobjects-outer-map
     "e" nil
     "E" 'evil-latex-textobjects-an-env)
    :hook (LaTeX-mode-hook . turn-on-evil-latex-textobjects-mode))
#+end_src

*** [#A] Surround text objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-surround
    :straight (:host github :repo "emacs-evil/evil-surround")
    :after (evil)
    :config
    (global-evil-surround-mode))
#+end_src

**** evil-embrace
This currently implicitly imports =embrace=

By default =embrace= adds backticks (=`=) and function wrapping support.

Edit =embrace-semantics-units-alist= and =embrace-add-pair=.

Probably keep this just for the backticks.

#+begin_src emacs-lisp :results output silent
  (use-package evil-embrace
    :straight t
    :custom
    (evil-embrace-show-help-p
     nil
     "Otherwise it shows a which-key like interface (that I'm not so hot on)")
    :config
    (evil-embrace-enable-evil-surround-integration))
#+end_src

*** [#A] Argument text objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-args
    :straight (:host github :repo "wcsmith/evil-args")
    :after (evil)
    :general
    (evil-inner-text-objects-map
     "a" 'evil-inner-arg)
    (evil-outer-text-objects-map
     "a" 'evil-outer-arg)
    :config
    ;; these variables don't exist until evil-arg loads
    (push "<" evil-args-openers)
    (push ">" evil-args-closers))
#+end_src

*** Comment using text objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-commentary
    :straight (:host github :repo "linktohack/evil-commentary")
    :after (evil)
    :config
    (evil-commentary-mode))
#+end_src

*** Comment Text Objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-nerd-commenter
    :straight (:host github :repo "redguardtoo/evil-nerd-commenter")
    :after (evil)
    :general
    (evil-inner-text-objects-map
     "c" 'evilnc-inner-comment)
    (evil-outer-text-objects-map
     "c" 'evilnc-outer-commenter))
#+end_src

(Compatibility with evil-matchit)
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'evil-matchit
    (with-eval-after-load 'evil-nerd-commenter
      (evilmi-load-plugin-rules '(mhtml-mode) '(template simple html))))
#+end_src

*** [#B] Indent text objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-indent-plus
    :straight (:host github :repo "TheBB/evil-indent-plus")
    :general
    (evil-inner-text-objects-map
     "i" 'evil-indent-plus-i-indent
     "I" 'evil-indent-plus-a-indent)
    (evil-outer-text-objects-map
     "i" 'evil-indent-plus-i-indent-up
     "I" 'evil-indent-plus-a-indent-up))
#+end_src

*** Line Text Objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-textobj-line
    :straight (:host github :repo "syohex/evil-textobj-line")
    :after evil)
#+end_src

*** [K]olumns
#+begin_src emacs-lisp :results output silent
  (use-package evil-textobj-column
    :straight (:host github :repo "noctuid/evil-textobj-column")
    :general
    (evil-outer-text-objects-map
     "k" 'evil-textobj-column-word
     "K" 'evil-textobj-column-WORD))
#+end_src

*** XML Attributes
#+begin_src emacs-lisp :results output silent
  (use-package exato
    :straight t
    :after evil)
#+end_src

** TODO Asyncrun
Just append =&= to the end of your command, emacs apparently just does
the right thing.

* Emacsql
#+begin_src emacs-lisp :results output silent
  (use-package emacsql
    :straight t)
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package emacsql-sqlite
    :disabled t
    :straight t)
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package emacsql-psql
    :disabled t
    :straight t)
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package emacsql-sqlite3
    :disabled t
    :straight t)
#+end_src

These two modules share the same repository
#+begin_src emacs-lisp :results output silent
  (use-package emacsql-sqlite-builtin
    :disabled t
    :if (<= emacs-major-version 29)
    :straight (:host github :repo "emacscollective/emacsql-sqlite-builtin"))
  ;; (use-package emacsql-sqlite-module
  ;;   :if (and (<= emacs-major-version 29) (not (eq system-type 'windows-nt)))
  ;;   :straight (:host github :repo "emacscollective/emacsql-sqlite-builtin"))
#+end_src

* Org Mode
** Org Id
#+begin_src emacs-lisp :results output silent
  (use-package org-id
    :ensure nil
    :straight nil
    :defer t
    :custom
    (org-id-ts-format "%s")
    (org-id-method 'ts))
#+end_src

** Evil Org Bindings
Full keybindings:
- https://github.com/Somelauw/evil-org-mode/blob/master/doc/keythemes.org


Important bindings:

| <M-S-return> | Insert checkbox item |

Interesting Text Objects:

| key     | function                          | examples                         |
|---------+-----------------------------------+----------------------------------|
| ae / ie | evil-org-an/inner-object          | link, markup, table cell         |
| aE / iE | evil-org-an/inner-element         | paragraph, code block, table row |
| ar / ir | evil-org-an/inner-greater-element | item list, table                 |
| aR / iR | evil-org-an/inner-subtree         | subtree starting with a header   |


#+begin_src emacs-lisp :results output silent
  (use-package evil-org
    :straight (:host github :repo "Somelauw/evil-org-mode")
    :preface
    (fset 'evil-redirect-digit-argument 'ignore)
    :hook ((org-mode-hook . evil-org-mode))
    :custom
    (evil-org-retain-visual-state-on-shift
     t "Let us chain < and > calls")
    (evil-org-use-additional-insert
     t "Add things like M-j to insert")
    (evil-org-special-o/O
     '(table-row) "Do not let o/O affect list items, throws me off")
    (org-special-ctrl-a/e
     t "Pretend leading stars on headlines don't exist when using A/I")
    :general
    (evil-org-mode-map
     :states 'normal
     "g f" 'evil-org-open-links)
    :config
    (when (boundp 'evil-digit-bound-motions)
      (add-to-list 'evil-digit-bound-motions 'evil-org-beginning-of-line))
    (evil-define-key 'motion 'evil-org-mode
        (kbd "0") 'evil-org-beginning-of-line)

    (evil-org-set-key-theme '(textobjects
                              ;; insert ;; replaces c-t and c-d
                              navigation
                              additional
                              shift
                              return
                              operators
                              ;; todo
                              ;; heading
                              calendar)))
#+end_src

** Org Capture Bindings
#+begin_src emacs-lisp :results output silent
  (use-package org-capture
    :ensure nil ;; because org-capture is from org
    :straight nil
    :after (org)
    :defer 20
    :commands (org-capture
               org-capture-templates)
    :general
    (org-capture-mode-map
     [remap evil-save-and-close]          'org-capture-finalize
     [remap evil-save-modified-and-close] 'org-capture-finalize
     [remap evil-quit]                    'org-capture-kill)
    :hook ((org-capture-mode-hook . evil-insert-state)
           (org-capture-after-finalize-hook . org-align-all-tags))
    :custom
    (org-capture-bookmark nil)
    :init
    (defun --org-capture-completing-read ()
      "Select capture template, stolen from
     https://github.com/raxod502/selectrum/wiki/Useful-Commands#user-content-org-capture-template"
      (interactive)
      (require 'org-capture)
      (let (prefixes)
        (alet (mapcan (lambda (x)
                        (let ((x-keys (car x)))
                          ;; Remove prefixed keys until we get one that matches the current item.
                          (while (and prefixes
                                      (let ((p1-keys (caar prefixes)))
                                        (or
                                         (<= (length x-keys) (length p1-keys))
                                         (not (string-prefix-p p1-keys x-keys)))))
                            (pop prefixes))
                          (if (> (length x) 2)
                              (let ((desc (mapconcat #'cadr (reverse (cons x prefixes)) " | ")))
                                (list (format "%-5s %s" x-keys desc)))
                            (push x prefixes)
                            nil)))
                      (-> org-capture-templates
                          (org-capture-upgrade-templates)
                          (org-contextualize-keys org-capture-templates-contexts)))
          (funcall #'org-capture nil (car (split-string (--completing-read "Capture template: " it
                                                                           :require-match t)))))))

    (evil-ex-define-cmd "cc" '--org-capture-completing-read)
    :config
    (defun --select-org-agenda-file ()
      (require 'org-agenda)
      (let ((targets
             (->> org-agenda-files
                  (-map-when
                   #'f-directory-p
                   #'(lambda (dir)
                       (f-files dir
                        (lambda (file)
                          (string-equal (f-ext file) "org")))))
                  (-flatten))))
        (if (eq 1 (safe-length targets))
            (car targets)
          (--completing-read "Capture target: " targets
                             :require-match t))))

    (defun --select-project-todo-file ()
      (require 'org-agenda)
      (require 'project)
      (if-let* ((project (project-current))
                (root (project-root project))
                (todo-file (f-join root "todo.org")))
          (progn
            (unless (f-file-p todo-file)
              (f-touch todo-file))
            todo-file)
        (error "Not in a project directory (%s)" default-directory))))

    ;; (setq org-capture-templates
    ;;       (doct-add-to
    ;;        org-capture-templates
    ;;        '(("Diary"
    ;;           :keys "diary"
    ;;           :empty-lines 1
    ;;           :file --local-diary-file
    ;;           :children
    ;;           (("today"
    ;;             :keys "today"
    ;;             :datetree t)))
    ;;          ("Clock"
    ;;           :keys "clock"
    ;;           :empty-lines 1
    ;;           :clock t
    ;;           :clock-resume t
    ;;           :children
    ;;           (("Item"
    ;;             :keys "item"
    ;;             :type item
    ;;             :template "%?")
    ;;            (:group "Entries"
    ;;             :type entry
    ;;             :template "* %{todo-state} %? %^g"
    ;;             :children
    ;;             (("To Do"
    ;;               :keys "todo"
    ;;               :todo-state "TODO")
    ;;              ("Note"
    ;;               :keys "note"
    ;;               :todo-state nil)
    ;;              ("Deferred"
    ;;               :keys "wait"
    ;;               :todo-state "WAIT")
    ;;              ("Done"
    ;;               :keys "done"
    ;;               :todo-state "DONE")))))
    ;;          ("Project"
    ;;           :keys "project"
    ;;           :type entry
    ;;           :file --select-project-todo-file
    ;;           :empty-lines 1
    ;;           :template
    ;;           ("* %{todo-state} %^{DESCRIPTION} %^g"
    ;;            ":PROPERTIES:"
    ;;            ":CREATED: %t" ;; org has no special property for creation timestamps
    ;;            ":END:"
    ;;            "=%(magit-get-current-branch)="
    ;;            ;; "[[%F][%(f-relative (or (org-capture-get :original-file t) (org-capture-get :original-file)) (project-root (project-current)))]]"
    ;;            "%a"
    ;;            "%?")
    ;;           :children
    ;;           (("To Do"
    ;;             :keys "todo"
    ;;             :todo-state "TODO"
    ;;             :immediate-finish t)
    ;;            ("To Do (Detailed)"
    ;;             :keys "detail"
    ;;             :todo-state "TODO")
    ;;            ("To Do (Generic)"
    ;;             :keys "generic"
    ;;             :todo-state "TODO"
    ;;             :template
    ;;             ("* %{todo-state} %^{DESCRIPTION}"
    ;;              "%t"
    ;;              "=%(magit-get-current-branch)="
    ;;              "%?"))
    ;;            ("Done"
    ;;             :keys "done"
    ;;             :todo-state "DONE")
    ;;            ("Deferred"
    ;;             :keys "wait"
    ;;             :todo-state "WAIT")))
    ;;          (:group "Default"
    ;;           :type entry
    ;;           :file --select-org-agenda-file
    ;;           :empty-lines 1
    ;;           :template
    ;;           ("* %{todo-state} %^{DESCRIPTION} %^g"
    ;;            ":PROPERTIES:"
    ;;            ":CREATED: %t" ;; org has no special property for creation timestamps
    ;;            ":END:"
    ;;            ":LOGBOOK:"
    ;;            ":END:"
    ;;            "%?")
    ;;           :children
    ;;           (("To Do"
    ;;             :keys "todo"
    ;;             :todo-state "TODO")
    ;;            ("Done"
    ;;             :keys "done"
    ;;             :todo-state "DONE")
    ;;            ("Deferred"
    ;;             :keys "wait"
    ;;             :todo-state "WAIT")))))))
#+end_src

** Org Agenda
For some reason we can't do this in the scratch buffer
#+begin_src emacs-lisp :results output silent
  (use-package org-agenda
    :ensure nil
    :straight nil
    :commands (org-todo-list
               org-agenda-list
               org-agenda-file-to-front
               org-agenda)
    :general
    (:states 'motion
     "|" 'org-agenda)
    (:keymaps 'org-agenda-keymap
     :states '(normal motion)
     "g r" 'org-agenda-redo
     "g t" nil
     "g T" nil
     "g l" 'org-agenda-log-mode
     "g x" 'org-open-at-point-global
     "ESC" 'evil-motion-state
     ;; Seems to be an unhandled case by evil-org
     "RET" 'org-agenda-switch-to
     [remap evil-write] 'org-save-all-org-buffers
     [remap evil-save-modified-and-close] #'(lambda ()
                                              (interactive)
                                              (org-save-all-org-buffers)
                                              (org-agenda-quit)))
    :custom
    (org-agenda-custom-commands '(("A" "TODOs and Agenda items"
                                   ((alltodo "")
                                    (agenda "")))))
    (org-agenda-start-with-log-mode nil "Use `g l' instead")
    (org-agenda-log-mode-items '(closed clock state))
    (org-agenda-span 'month)
    (org-agenda-window-setup 'current-window)
    (org-agenda-skip-unavailable-files t)
    (org-agenda-time-leading-zero t)
    (org-agenda-prefix-format '((agenda . " %i %-12:c%?-12t%s %?b")
                                (todo . " %i %-12:c%?-12b")
                                (tags . " %i %-12:c")
                                (search . " %i %-12:c")))
    (org-agenda-breadcrumbs-separator "/")
    :custom-face
    (org-agenda-done ((t (:inherit org-agenda-done :strike-through t))))
    (org-agenda-date-today ((t (:inherit org-agenda-date :overline t :bold t :inverse t))))
    :hook
    (org-agenda-after-show-hook . org-narrow-to-subtree)
    :init
    (cl-defun --run-with-local-idle-timer (secs repeat function &rest args)
      "Like `run-with-idle-timer', but always runs in the `current-buffer'.
     Cancels itself, if this buffer was killed.
     Stolen from https://emacs.stackexchange.com/a/13275"
     (let* (;; Chicken and egg problem.
            (fns (make-symbol "local-idle-timer"))
            (timer (apply 'run-with-idle-timer secs repeat fns args))
            (fn `(lambda (&rest args)
                   (if (not (buffer-live-p ,(current-buffer)))
                       (cancel-timer ,timer)
                     (with-current-buffer ,(current-buffer)
                      (apply (function ,function) args))))))
       (fset fns fn)
       fn))
    :config
    (require 'evil-org-agenda)
    (customize-set-value 'org-agenda-start-day "-1d"
                         "For some reason this isn't being recognized
                         and loaded in `:custom`")
    ;;(evil-org-agenda-set-keys)
    (with-eval-after-load 'tab-bar
      (general-define-key
       :keymaps 'org-agenda-mode-map
       :states '(motion)
       "g t" 'tab-bar-switch-to-next-tab
       "g T" 'tab-bar-switch-to-prev-tab))

    (with-eval-after-load 'salv
      (add-hook 'org-mode-hook #'(lambda ()
                                   (when (org-agenda-file-p (buffer-file-name))
                                    (salv-mode)))))

    (define-advice org-agenda-capture (:override () --consult-org-agenda-capture)
      "Overrides `org-agenda-add' with a more consult-like interface"
      (interactive)
      (call-interactively '--org-capture-completing-read))

    (my-evil-define-split-vsplit-cmd "aa" #'org-agenda)
    (my-evil-define-split-vsplit-cmd "todo" #'org-todo-list)
    (my-evil-define-split-vsplit-cmd "agenda" #'(lambda () (interactive) (org-agenda nil "A")))
    (evil-ex-define-cmd "Tag[enda]"
                        #'(lambda () (interactive)
                            ;; TODO: unify this implementation with my-new-cmd-tab
                            (if (>= emacs-major-version 27)
                                (tab-bar-new-tab)
                              (require 'eyebrowse)
                              (my-new-evil-tab nil))
                            (funcall-interactively #'(lambda () (interactive (org-agenda nil "A"))))))
    ;; override `org-agenda-diary-entry' to use `org-roam'
    (general-define-key
     :keymaps 'org-agenda-mode-map
     :states '(motion)
     "i" #'(lambda () (interactive)
             (require 'org-roam)
             (--org-roam-dailies-today))))
#+end_src

*** Super agenda
https://github.com/alphapapa/org-super-agenda

#+begin_src emacs-lisp :results output silent
  (use-package org-super-agenda
    :straight t
    :commands org-super-agenda-mode
    :hook (org-agenda-mode-hook . org-super-agenda-mode)
    :general
    (org-super-agenda-mode-map
     "g t" nil
     "g T" nil)
    :custom
    (org-super-agenda-groups
     '((:auto-todo t)))
     ;; '((:name "Blockers"
     ;;    :todo "WAIT")
     ;;   (:name "To Do"
     ;;    :todo "TODO")))
       ;; (:name "Personal Work"
       ;;  :tag "personal"
       ;;  :and (:not (:habit t)))
       ;; (:name "Habits"
       ;;  :habit t)))
    ;; (:name "Unscheduled Work"
    ;;  :not (:scheduled t))))
    :config
    ;; don't let org-super-agenda override evil bindings
    ;; https://github.com/codygman/doom-emacs-literate-config/commit/bcd6ee115db58d12a05ff4aa9ba60f96d87b81ba
    (setq org-super-agenda-header-map (make-sparse-keymap)))
#+end_src

** Org Src
Don't bind to C-c C-c because it might impact the src block's
language's mappings.

#+begin_src emacs-lisp :results output silent
  (use-package org-src
    :ensure nil
    :straight nil
    :init
    (defun my-evil-org-src-save-exit ()
      (interactive)
      (org-edit-src-save)
      (org-edit-src-exit))
    :general
    (org-src-mode-map
     [remap evil-write] 'org-edit-src-save
     ;; doesn't seem to be working, the saving part at least
     [remap evil-save-and-close] #'my-evil-org-src-save-exit
     ;; doesn't seem to be working, the saving part at least
     [remap evil-save-modified-and-close] #'my-evil-org-src-save-exit
     [remap evil-quit] 'org-edit-src-abort))
#+end_src

** Export as epub
Needs a working =zip= exe.

#+begin_src emacs-lisp :results output silent
  (use-package ox-epub
    :straight (:host github :repo "ofosos/ox-epub")
    :commands org-epub-export-to-epub)
#+end_src

** Screenshot from system clipboard
[[http://www.sastibe.de/2018/11/take-screenshots-straight-into-org-files-in-emacs-on-win10/][Source]], modified to allow the user to select a directory.

#+begin_src emacs-lisp :results output silent
  (defun my-org-paste-clipboard-screenshot (&optional dir)
    "Take a screenshot into a time stamped unique-named file in the
       same directory as the org-buffer and insert a link to this file."
    (interactive (list (read-directory-name "" "" "images")))
    (unless (equal system-type 'windows-nt)
      (user-error "Implementation currently only works on windows, this is %s"
                  system-type))
    (let ((filename (concat
                     (make-temp-name
                      (concat (file-name-as-directory dir)
                              (-> (buffer-file-name)
                                file-name-nondirectory
                                file-name-sans-extension)
                              "_"
                              (format-time-string "%Y-%m-%dT%H%M%S")))
                     ".png")))
      (unless (file-directory-p dir)
        (make-directory dir))
      (shell-command (concat "powershell -command \"Add-Type -AssemblyName System.Windows.Forms;if ($([System.Windows.Forms.Clipboard]::ContainsImage())) {$image = [System.Windows.Forms.Clipboard]::GetImage();[System.Drawing.Bitmap]$image.Save('"
                             filename
                             "',[System.Drawing.Imaging.ImageFormat]::Png); Write-Output 'clipboard content saved as file'} else {Write-Output 'clipboard does not contain image data'}\""))
      (insert (concat "[[file:" (file-relative-name filename) "]]"))
      (message "Image saved as %s" filename)
      (org-display-inline-images)
      filename))
#+end_src

#+begin_src emacs-lisp :results output
  (general-define-key
   :keymaps 'org-mode-map
   :states '(normal)
   :prefix my-default-evil-leader-key
   "o p" 'my-org-paste-clipboard-screenshot)
#+end_src

** Ob-async
#+begin_src emacs-lisp :results output silent
  (use-package ob-async
    :straight t
    :after org)
#+end_src

** Ob-http
#+begin_src emacs-lisp :results output silent
  (use-package ob-http
    :straight t
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     (add-to-list 'org-babel-load-languages '(http . t))))
#+end_src

** Org Roam
- [ ] Figure out how to jigger =org-roam-=capture-= to use
  =completing-read= and family, since the current way of selecting a
  candidate is fairly (very) primitive.


#+begin_src emacs-lisp :results output silent
  (use-package md-roam
    :straight (:host github :repo "nobiot/md-roam")
    :disabled t
    :custom
    (org-roam-file-extensions '("org" "md"))
    (md-roam-file-extension "md")
    :config
    (md-roam-mode 1))
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package org-roam
    :disabled t
    :straight (:host github :repo "org-roam/org-roam"
               :files (:defaults "extensions/*"))
    :disabled t
    :preface
    (customize-set-value 'org-roam-database-connector
                         (if (>= emacs-major-version 29) 'sqlite-builtin 'sqlite3))
    :after (md-roam) ;; md-roam needs to be loaded before `org-roam-db-autosync-mode' is activated
    :custom
    (org-roam-dailies-directory "day/")
    (org-roam-complete-everywhere t)
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "n a"   #'org-roam-alias-add
     "n A"   #'org-roam-alias-remove
     "n f"   #'org-roam-ref-add
     "n F"   #'org-roam-ref-remove
     "n T"   #'org-roam-tag-remove
     "n b"   #'org-roam-buffer-toggle
     "n c c" #'--org-roam-capture-completing-read
     "n i"   #'org-roam-node-insert
     "n c d" #'org-roam-dailies-capture-date
     "n c j" #'org-roam-dailies-capture-today
     "n c n" #'org-roam-dailies-capture-tomorrow
     "n c p" #'org-roam-dailies-capture-yesterday
     "n n"   #'org-roam-node-find
     "n o"   #'org-id-get-create
     "n r"   #'org-roam-refile
     "n s"   #'(lambda () (interactive)
                 (condition-case nil
                     (org-roam-db-sync)
                   (error
                    (condition-case nil
                        (org-roam-db-sync))))
                 (org-roam-update-org-id-locations))
     "n t"   #'org-roam-tag-add)
    :init
    (when (bound-and-true-p --org-roam-repository-list)
      (customize-set-variable 'org-roam-directory
                              (car --org-roam-repository-list)))

    (defun my-buffer-in-org-roam-dir-p ()
      (interactive)
      (let ((path (buffer-file-name (current-buffer))))
        (and path (f-ancestor-of? org-roam-directory path))))

    (defun --on-selecting-org-roam-directory (org-roam-func dir)
      ;; it's insufficient to temporarily update org-roam-directory, as
      ;; we don't want every `org-roam' function to ask for the
      ;; directory. Updating the default state should prevent surprises
      ;; in this case.
      ;;
      ;; This might obiviate the need for the `.dir-locals.el'
      (setq org-roam-directory dir)
      (setq org-roam-db-location (f-join dir "org-roam.db"))
      ;; create dailies directory if it doesn't exist
      (let ((dailies-dir (f-join org-roam-directory
                                 org-roam-dailies-directory)))
        (unless (f-exists-p dailies-dir)
          (make-directory dailies-dir t)))
      ;; (org-roam-db-sync) ;; might be too eager
      (funcall org-roam-func))

    (defun --with-selected-org-roam-directory (org-roam-func)
      (interactive)
      (require 'org-roam)
      (let ((repos (or --org-roam-repository-list `(,org-roam-directory))))
        (if (eq 1 (safe-length repos))
            (--on-selecting-org-roam-directory org-roam-func (car repos))
          (let ((repo (--completing-read "repo: " repos
                                         :require-match t)))
            (--on-selecting-org-roam-directory org-roam-func repo)))))

    (defun --org-roam-find-index-file ()
      (interactive)
      (--with-selected-org-roam-directory
       #'(lambda ()
           (find-file (f-join org-roam-directory "index.org"))
           (org-roam-db-sync))))

    (defun --org-roam-node-find ()
      (interactive)
      (--with-selected-org-roam-directory #'org-roam-node-find))

    (defun --org-roam-capture ()
      (interactive)
      (--with-selected-org-roam-directory #'org-roam-capture))

    (defun --org-roam-dailies-yesterday ()
      (interactive)
      (--with-selected-org-roam-directory #'(lambda () (org-roam-dailies-goto-yesterday 1))))

    (defun --org-roam-dailies-today ()
      (interactive)
      (--with-selected-org-roam-directory #'org-roam-dailies-goto-today))

    (defun --org-roam-dailies-tomorrow ()
      (interactive)
      (--with-selected-org-roam-directory #'(lambda () (org-roam-dailies-goto-tomorrow 1))))

    (my-evil-define-split-vsplit-cmd "ii" #'--org-roam-find-index-file)

    (my-evil-define-split-vsplit-cmd "jj" #'--org-roam-dailies-today)
    (defun --org-roam-node-dailies-today-new-tab ()
      (interactive)
      (require 'org-roam)
      (if (>= emacs-major-version 27)
          (tab-bar-new-tab)
        (my-evil-new-tab filepath))
      (call-interactively 'org-roam-dailies-goto-today))
    (evil-ex-define-cmd "Tjj" #'--org-roam-node-dailies-today-new-tab)

    (my-evil-define-split-vsplit-cmd "nn" #'--org-roam-node-find)
    (defun --org-roam-node-find-new-tab ()
      (interactive)
      (require 'org-roam)
      (let* ((filepath (-> (org-roam-node-read)
                           (org-roam-node-file))))
        (if (>= emacs-major-version 27)
            (let ((tab-bar-new-tab-choice filepath))
              (tab-bar-new-tab))
          (my-evil-new-tab filepath))))
    (evil-ex-define-cmd "Tnn" #'--org-roam-node-find-new-tab)

    (evil-ex-define-cmd "index"     #'--org-roam-find-index-file)
    (evil-ex-define-cmd "nc"        #'--org-roam-capture-completing-read)
    (evil-ex-define-cmd "yesterday" #'--org-roam-dailies-yesterday)
    (evil-ex-define-cmd "ytd"       #'--org-roam-dailies-yesterday)
    (evil-ex-define-cmd "jp"        #'--org-roam-dailies-yesterday)
    (evil-ex-define-cmd "to[day]"   #'--org-roam-dailies-today)
    (evil-ex-define-cmd "tomorrow"  #'--org-roam-dailies-tomorrow)
    (evil-ex-define-cmd "tmr"       #'--org-roam-dailies-tomorrow)
    (evil-ex-define-cmd "jn"        #'--org-roam-dailies-tomorrow)

    (defun --org-roam-capture-completing-read ()
      "Same as `--org-capture-completing-read' but adjusted for `org-roam-capture' instead."
      (interactive)
      (require 'org-roam)
      (let (prefixes)
        (alet (mapcan (lambda (x)
                        (let ((x-keys (car x)))
                          ;; Remove prefixed keys until we get one that matches the current item.
                          (while (and prefixes
                                      (let ((p1-keys (caar prefixes)))
                                        (or
                                          (<= (length x-keys) (length p1-keys))
                                          (not (string-prefix-p p1-keys x-keys)))))
                            (pop prefixes))
                          (if (> (length x) 2)
                              (let ((desc (mapconcat #'cadr (reverse (cons x prefixes)) " | ")))
                                (list (format "%-5s %s" x-keys desc)))
                            (push x prefixes)
                            nil)))
                      (-> org-roam-capture-templates
                          (org-capture-upgrade-templates)
                          (org-contextualize-keys org-capture-templates-contexts)))
          (funcall #'org-roam-capture nil (car (split-string (--completing-read "Capture template: " it
                                                                                :require-match t)))))))
    :config
    (require 'org-roam-dailies)
    (add-to-list 'display-buffer-alist
                 '("\\*org-roam\\*" . (display-buffer-same-window . nil)))
    (org-roam-db-autosync-mode)

    ;; Can't do this because the top of the file contains some cookies
    ;; and I don't know hot to strip them yet
    ;;
    ;; (let ((org-roam-doct-file (expand-file-name
    ;;                            "local-packages/doct-org-roam.el"
    ;;                            user-emacs-directory)))
    ;;   (unless (f-exists-p org-roam-doct-file)
    ;;     (with-current-buffer
    ;;       (url-retrieve-synchronously
    ;;        "https://gist.github.com/vherrmann/f9b21eeea7d7c9123dc400a30599d50d/raw/1ccb6d44484858225e9f7dfdfb54dc7a40441637/doct-org-roam.el"
    ;;        'silent 'inhibit-cookies)
    ;;       (append-to-file (point-min)
    ;;                       (point-max)
    ;;                       org-roam-doct-file))))

    ;; (use-package doct-org-roam
    ;;   :straight nil
    ;;   :ensure nil
    ;;   :load-path "local-packages/"
    ;;   :commands doct-org-roam)

    (define-advice org-roam-node-slug (:filter-return (str))
      (replace-regexp-in-string "_" "-" str))

    (let ((default-slug "${slug}.org")
          (default-head "#+title: ${title}\n#+filetags: %^G\n\n")
          (default-diary-slug "%<%Y-%m-%d>.org")
          (default-diary-head "#+filetags: :diary:%^G\n\n"))
      (customize-set-value
       'org-roam-capture-templates
       (list `("d" "default" plain "%?"
               :target (file+head ,default-slug ,default-head)
               :empty-lines 1
               :unnarrowed t)
             `("a" "append" entry "* %?"
               :target (file+head ,default-slug ,default-head)
               :empty-lines 1
               :unnarrowed t)
             ;; Datetree creation seems powerful but also not really
             ;; what we want.
             ;; `("t" "timestamp" entry "* %<%H:%M> %?"
             ;;   :target (file+datetree ,default-slug day)
             ;;   :empty-lines 1
             ;;   :time-prompt t
             ;;   :unnarrowed t)
             `("r" "raw" entry "* %?"
               :target (file+head+olp
                        ,default-slug ,default-head
                        ("raw"))
               :empty-lines 1
               :unnarrowed t)))

      (customize-set-value
       'org-roam-dailies-capture-templates
       (list `("d" "default" plain "%?"
               :target (file+head
                        ,default-diary-slug ,default-diary-head)
               :empty-lines 1
               :unnarrowed t)
             `("a" "append" entry "* %?"
               :target (file+head
                        ,default-diary-slug ,default-diary-head)
               :empty-lines 1
               :unnarrowed t)
             `("r" "raw" entry "* %?"
               :target (file+head+olp
                        ,default-diary-slug ,default-diary-head
                        ("raw"))
               :empty-lines 1
               :unnarrowed t)))))
#+end_src

*** Nroam
org roam mode hook only activates once, not per roam file as we wanted.

#+begin_src emacs-lisp :results output silent
  (use-package nroam
    :disabled t
    :straight (:host github :repo "nicolaspetton/nroam")
    :after org-roam
    :general
    (:states 'normal
      :prefix my-default-evil-leader-key
      "n r" #'my-toggle-nroam-mode-maybe)
    :commands nroam-mode
    ;; this interferes with org-roam-capture of all kinds
    ;; :hook (org-mode-hook . my-enable-nroam-mode-maybe)
    :init
    (defun my-toggle-nroam-mode-maybe ()
      "Enables nroam only if it is found to be inside an org-roam directory"
      (interactive)
      (require 'nroam)
      (if nroam-mode
          (nroam-mode -1)
        (when (my-buffer-in-org-roam-dir-p)
            (nroam-mode)))))
#+end_src

*** Consult Org-roam
Who knows how useful this will be.
#+begin_src emacs-lisp :results output silent
  (use-package consult-org-roam
    :after org-roam
    :disabled t
    :straight (:host github :repo "jgru/consult-org-roam"))
#+end_src

** Org Latex Fragment Toggle
#+begin_src emacs-lisp :results output silent
  (use-package org-fragtog
    :straight (:host github :repo "io12/org-fragtog")
    :hook (org-mode-hook . org-fragtog-mode))
#+end_src

** Org Habit
In emacs 28 there's an issue with it not updated to using 3 arguments
for =define-obsolete-function-alias= (really dumb thing, but there it
is)

#+begin_src emacs-lisp :results output silent
  (use-package org-habit
    :disabled t
    :straight nil
    :ensure nil
    :after org
    :custom
    (org-habit-graph-column 70))
#+end_src

** Org Clock
#+begin_src emacs-lisp :results output silent
  (use-package org-clock
    :straight nil
    :ensure nil
    :custom
    (org-clock-clocked-in-display 'both)
    (org-clock-persist 'history)
    (org-clock-mode-line-total 'current)
    (org-clock-out-remove-zero-time-clocks t)
    (org-clock-history-length 35)
    :general
    (:states '(normal)
     :prefix my-default-evil-leader-key
     "c c" 'my-org-clocking
     "c f" 'my-org-goto-clock)
    :init
    (defun my-org-goto-clock ()
      (interactive)
      (require 'org-clock)
      (org-clock-goto (not (org-clocking-p))))
    (evil-define-command my-org-clocking (&optional bang)
      "Note that adding a ! means you mark the current task as the
    default."
      (interactive "<!>")
      (require 'org-clock)
      (cond
       ((org-clocking-p) (org-clock-out))
       ((and (eq major-mode 'org-mode) (org-at-heading-p))
        (org-clock-in))
       ((string-equal (buffer-name) "*Org Agenda*")
        (org-agenda-clock-in))
       (t (org-clock-in '(4))))
      (when (or bang (not (marker-position org-clock-default-task)))
        (org-clock-mark-default-task)))
    (evil-ex-define-cmd "clock" #'my-org-clocking)
    (evil-ex-define-cmd "clocking" #'my-org-goto-clock)
    :config
    (org-clock-persistence-insinuate)
    (org-clock-load))

  ;; :config
  ;; (defun my-org-clock-get-clock-string ()
  ;;   "Form a clock-string, that will be shown in the mode line.
  ;; If an effort estimate was defined for the current item, use
  ;; 01:30/01:50 format (clocked/estimated).
  ;; If not, show simply the clocked time like 01:50.

  ;; We modify this such that if the customization
  ;; `org-clock-mode-line-total' is `current', the effort estimate gets
  ;; \"eaten\" by the total clocked time (so subsequent clock-in's will
                                          ; see the effort reduce)."
  ;;   (let ((clocked-time (org-clock-get-clocked-time)))
  ;;     (if org-clock-effort
  ;;         (let* ((effort-in-minutes
  ;;                 (if (eq org-clock-mode-line-total 'current)
  ;;                     (-> (org-duration-to-minutes org-clock-effort)
  ;;                         (- clocked-time))
  ;;                   (org-duration-to-minutes org-clock-effort)))
  ;;                (work-done-str
  ;;                 (propertize (org-duration-from-minutes clocked-time)
  ;;                             'face
  ;;                             (if (and org-clock-task-overrun
  ;;                                      (not org-clock-task-overrun-text))
  ;;                                 'org-mode-line-clock-overrun
  ;;                               'org-mode-line-clock)))
  ;;                (effort-str (org-duration-from-minutes
  ;;                             effort-in-minutes)))
  ;;           (format (propertize " [%s/%s] (%s)" 'face 'org-mode-line-clock)
  ;;                   work-done-str effort-str org-clock-heading))
  ;;       (format (propertize " [%s] (%s)" 'face 'org-mode-line-clock)
  ;;               (org-duration-from-minutes clocked-time)
  ;;               org-clock-heading))))
  ;; (advice-add 'org-clock-get-clock-string
  ;;             :override 'my-org-clock-get-clock-string))
#+end_src

** Org Appear
#+begin_src emacs-lisp :results output silent
  (use-package org-appear
    :straight (:host github :repo "awth13/org-appear")
    :commands (org-appear-mode)
    :hook (org-mode-hook . org-appear-mode))
#+end_src

** Org Sticky Header
#+begin_src emacs-lisp :results output silent
  (use-package org-sticky-header
    :disabled t
    :straight (:host github :repo "alphapapa/org-sticky-header")
    :hook (org-mode-hook . org-sticky-header-mode))
#+end_src

** Org Crypt
#+begin_src emacs-lisp :results output silent
  (use-package org-crypt
    :straight nil
    :ensure nil
    :custom
    (org-crypt-key nil))
#+end_src

** Valign
#+begin_src emacs-lisp :results output silent
  (use-package valign
    :straight t
    :hook (org-mode-hook . valign-mode))
#+end_src

** Org Query
[[https://github.com/alphapapa/org-ql#queries][Query Syntax Reference]]

#+begin_src emacs-lisp :results output silent
  (use-package org-ql
    :straight t
    :commands
    (org-ql-search
     org-ql-view
     org-ql-view-sidebar
     org-ql-view-recent-items
     org-ql-sparse-tree))
#+end_src

Use the following query to find all todo items that are overdue

#+begin_src emacs-lisp :results output silent
;; (org-ql-search (org-agenda-files) '(and (todo) (scheduled :to -1)))
#+end_src

** Org Transclude
- [ ] Fix the =org-transclusion-*= faces.


#+begin_src emacs-lisp :results output silent
  (use-package org-transclusion
    :straight (:host github :repo "nobiot/org-transclusion")
    :hook (org-mode-hook . org-transclusion-mode)
    :config
    (with-eval-after-load 'org-roam
      ;; Propagate backlinks if header is transcluded.
      ;; https://github.com/nobiot/org-transclusion/issues/136
      (customize-set-value 'org-roam-db-extra-links-exclude-keys
                           (cl-remove-if (lambda (kv)
                                           (string-equal (cadr kv) "transclude"))
                                         org-roam-db-extra-links-exclude-keys))))
#+end_src

** Org Modern
#+begin_src emacs-lisp :results output silent
  (use-package org-modern
    :straight (:host github :repo "minad/org-modern")
    :hook ((org-mode-hook . org-modern-mode))
           ;; (org-agenda-finalize-hook . org-modern-agenda))
    :custom
    (org-modern-tag nil) ;; tags are not aligning correctly in agenda, maybe it'll get fixed
    :custom-face
    (org-modern-done ((t (:inherit (sol-subtle default)))))
    (org-modern-tag ((((background light)) (:foreground
                                            ,sol-base00
                                            :inherit (secondary-selection org-modern-label)))
                     (((background dark)) (:foreground
                                           ,sol-base0
                                           :inherit (secondary-selection org-modern-label))))))
#+end_src

* hl-todo
#+begin_src emacs-lisp :results output silent
  (use-package hl-todo
    :diminish t
    :straight (:host github :repo "tarsius/hl-todo")
    :commands (hl-todo-mode)
    :hook ((prog-mode-hook  . hl-todo-mode)
           (yaml-mode-hook  . hl-todo-mode))
    :custom
    (hl-todo-keyword-faces '(("TODO"  . "#b58900")
                             ("DEBUG" . "#d33682")
                             ("NOTE"  . "#586e75")
                             ("FIXME" . "#cb4b16")))
    :general
    ;; (:states 'normal
    ;;  :prefix my-default-evil-leader-key
    ;;  "t t" 'my-helm-swoop-hl-todo)
    (:keymaps 'evil-normal-state-map
     "[ h"  'hl-todo-previous
     "] h"  'hl-todo-next))
  ;; :init
  ;;TODO: Make this search for regexes
  ;; (defun my-helm-swoop-hl-todo () (interactive)
  ;;        (require 'helm-swoop)
  ;;        (helm-swoop :$query hl-todo-regexp :$multiline 4)))
  ;; Stolen from https://github.com/emacs-helm/helm/wiki/Developing. Convenient!
  ;; Not used because we don't incrementally search for todos
  ;; (defun my-helm-hl-todo-items ()
  ;;   "Show `hl-todo'-keyword items in buffer."
  ;;   (interactive)
  ;;   (hl-todo--setup)
  ;;   (helm :sources (helm-build-in-buffer-source "hl-todo items"
  ;;                    :data (current-buffer)
  ;;                    :candidate-transformer (lambda (candidates)
  ;;                                             (cl-loop for c in candidates
  ;;                                                      when (string-match hl-todo--regexp c)
  ;;                                                      collect c))
  ;;                    :get-line #'buffer-substring)
  ;;         :buffer "*helm hl-todo*"))
#+end_src

* Edit-Indirect
#+begin_src emacs-lisp :results output silent
  (use-package edit-indirect
    :straight t)
#+end_src

* Markdown                                                            :major:
#+begin_src emacs-lisp :results output silent
  (use-package markdown-mode
    :straight (:host github :repo "jrblevin/markdown-mode")
    :mode ("\\.md\\'" . markdown-mode)
    :commands (markdown-mode)
    :init
    (with-eval-after-load 'org-table
      (defun orgtbl-to-gfm (table params)
        "Convert the Orgtbl mode TABLE to GitHub Flavored Markdown."
        (let* ((alignment (mapconcat (lambda (x) (if x "|--:" "|---")))
                          org-table-last-alignment ""))
          (params2
           (list)
           :splice t
           :hline (concat alignment "|")
           :lstart "| " :lend " |" :sep " | ")
          (orgtbl-to-generic table (org-combine-plists params2 params)))))
    (with-eval-after-load 'org-src
      (cl-pushnew '("md" . gfm) org-src-lang-modes)))
#+end_src

** Evil-markdown
#+begin_src emacs-lisp :results output silent
  (use-package evil-markdown
    :after (:and evil markdown-mode)
    :straight (:host github :repo "Somelauw/evil-markdown")
    :commands (evil-markdown-mode)
    :hook (markdown-mode-hook . evil-markdown-mode))
#+end_src

* Git
*** Magit github
#+begin_src emacs-lisp :results output silent
  (use-package forge
    :disabled t
    :straight t
    ;; this needs sqlite, which for some reason windows is anal about
    :if (not (eq 'windows-nt system-type))
    :after magit)
#+end_src

*** Magit Delta
Requires installation of [[https://github.com/dandavison/delta][Delta]].

#+begin_src emacs-lisp :results output silent
  (use-package magit-delta
    :if (executable-find "delta")
    :hook (magit-mode-hook . magit-delta-mode))
#+end_src

** Browse-at-remote
#+begin_src emacs-lisp :results output silent
  (use-package browse-at-remote
    :straight t
    :commands (browse-at-remote))
#+end_src

** Git modes
#+begin_src emacs-lisp :results output silent
  (use-package git-modes
    :straight t)
#+end_src

** Blamer
#+begin_src emacs-lisp :results output silent
  (use-package blamer
    :straight (:host github :repo "Artawower/blamer.el")
    :custom
    (blamer-commit-formatter ": %s")
    (blamer-min-offset 5)
    (blamer-idle-time 1)
    :custom-face
    (blamer-face ((t :inherit sol-subtle)))
    :hook
    (prog-mode-hook . blamer-mode))
#+end_src

* vdiff
#+begin_src emacs-lisp :results output silent
  (use-package vdiff
    :straight (:host github :repo "justbur/emacs-vdiff")
    :commands vdiff-hydra/body
    :init
    (evil-define-command ex-vdiff-cli (cmd)
      (interactive "<a>")
      (cond
       (t (vdiff-current-file))))
    (evil-ex-define-cmd "vdiff" 'ex-vdiff-cli))
#+end_src

** vdiff for magit
#+begin_src emacs-lisp :results output silent
  (use-package vdiff-magit
    :straight (:host github :repo "justbur/emacs-vdiff-magit")
    :after magit
    :disabled t
    :general
    (magit-mode-map
     "e" 'vdiff-magit-dwim
     "E" 'vdiff-magit)
    :init
    (with-eval-after-load 'magit
      (transient-suffix-put 'magit-dispatch "e" :description "vdiff (dwim)")
      (transient-suffix-put 'magit-dispatch "e" :command 'vdiff-magit-dwim)
      (transient-suffix-put 'magit-dispatch "E" :description "vdiff")
      (transient-suffix-put 'magit-dispatch "E" :command 'vdiff-magit)))
#+end_src

* Diff-hl
#+begin_src emacs-lisp :results output silent
  (use-package diff-hl
    :straight (:host github :repo "dgutov/diff-hl")
    :disabled t
    :defer 10
    :config
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
    (global-diff-hl-mode))
#+end_src

* Eyebrowse
TODO: some way to better, more dynamically name the tabs

#+begin_src emacs-lisp :results output silent
  (use-package eyebrowse
    ;; emacs 27 provides a tab-bar-mode to basically do this
    :if (not (>= emacs-major-version 27))
    :straight (:host github :repo "wasamasa/eyebrowse")
    :commands (eyebrowse-switch-to-window-config
               eyebrowse-create-window-config
               eyebrowse-close-window-config
               eyebrowse-next-window-config
               eyebrowse-prev-window-config)
    :general
    (:states 'motion
     "gt" 'eyebrowse-next-window-config
     "gT" 'eyebrowse-prev-window-config)
    :custom
    (eyebrowse-wrap-around t)
    (eyebrowse-new-workspace t)
    (eyebrowse-keymap-prefix "")
    :init
    (evil-ex-define-cmd "gT" 'eyebrowse-prev-window-config)
    (evil-ex-define-cmd "gt" 'eyebrowse-next-window-config)
    (evil-define-command my-new-evil-tab (arg)
      "Note that :h :tabe in vim indicates that it's file only, not
  buffer.
  If the argument is a file, name the tab with the file. otherwise name
  the tab as the argument. If nothing is passed name the tab to the
  buffer."
      (interactive "<a>")
      (require 'eyebrowse)
      (let ((eyebrowse-new-workspace (if (and arg
                                              (file-exists-p arg))
                                         (lambda () (find-file arg))
                                       eyebrowse-new-workspace)))
        (eyebrowse-create-window-config))
      (my-rename-eyebrowse-tab (cond ((null arg) (buffer-name))
                                     ((file-exists-p arg)
                                      (file-name-nondirectory arg))
                                     (t arg))))
    (evil-ex-define-cmd "tabn[ew]"   'my-new-evil-tab)
    (evil-ex-define-cmd "tabe[dit]"  'my-new-evil-tab)
    (evil-ex-define-cmd "tabc[lose]" 'eyebrowse-close-window-config)
    (evil-ex-define-cmd "tabs"       'eyebrowse-switch-to-window-config)
    :config
    (evil-define-command my-rename-eyebrowse-tab (name)
      (interactive "<a>")
      (require 'eyebrowse)
      (eyebrowse-rename-window-config
       (frame-parameter nil 'eyebrowse-current-slot)
       name))
    (evil-ex-define-cmd "trename" 'my-rename-eyebrowse-tab)
    (evil-ex-define-cmd "tr" 'my-rename-eyebrowse-tab)
    (evil-ex-define-cmd "tabrename" 'my-rename-eyebrowse-tab)
    (defun my-eyebrowse-delete-window-config-or-frame (oldfun &rest _old_args)
      "Checks if there are other \"tabs\" when closing a frame.
  If there is, close the tab, otherwise, delete the frame"
      (require 'eyebrowse)
      (interactive)
      (let* ((configs (frame-parameter nil 'eyebrowse-window-configs))
             (slots (mapcar 'car configs))
             (size (length slots)))
        (if (eq 1 size)
            (call-interactively oldfun)
          (eyebrowse-close-window-config))))
    (advice-add 'delete-frame :around 'my-eyebrowse-delete-window-config-or-frame)
    (eyebrowse-mode)
    ;; (eyebrowse-setup-evil-keys)
    (my-rename-eyebrowse-tab (buffer-name)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'eyebrowse
    (customize-set-variable
     'mode-line-format
     (list "%e" mode-line-front-space mode-line-mule-info
           mode-line-client mode-line-modified mode-line-auto-compile
           mode-line-remote mode-line-frame-identification
           mode-line-buffer-identification " " mode-line-position
           evil-mode-line-tag mode-line-misc-info '(vc-mode vc-mode) " "
           mode-line-modes mode-line-end-spaces)))
#+end_src

* Text
** Aggressive Fill Paragraph
#+begin_src emacs-lisp :results output silent
  (use-package aggressive-fill-paragraph
    :straight (:host github :repo "davidshepherd7/aggressive-fill-paragraph-mode")
    :commands (aggressive-fill-paragraph-mode)
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "g w" 'aggressive-fill-paragraph-mode)
    :hook ((org-mode-hook . aggressive-fill-paragraph-mode)
           (markdown-mode-hook . aggressive-fill-paragraph-mode)))
#+end_src

** Aggressive Indent
#+begin_src emacs-lisp :results output silent
  (use-package aggressive-indent
    :straight (:host github :repo "malabarba/aggressive-indent-mode")
    :commands (aggressive-indent-mode)
    :custom
    (aggressive-indent-comments-too t)
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "=" 'aggressive-indent-mode))
#+end_src

** Yasnippet
#+begin_src emacs-lisp :results output silent
  (use-package yasnippet
    :defer 20
    :straight (:host github :repo "joaotavora/yasnippet")
    :commands (yas-minor-mode
               yas-expand-snippet)
    :hook
    ((prog-mode-hook . yas-minor-mode)
     (org-mode-hook . yas-minor-mode))
    :general
    (yas-keymap
     "C-j" 'yas-next-field-or-maybe-expand
     "C-k" 'yas-prev-field)
    (:states '(normal visual)
     :prefix my-default-evil-leader-key
     "s s" 'yas-insert-snippet
     "s n" 'yas-new-snippet
     "s f" 'yas-visit-snippet-file)
    (snippet-mode-map
     [remap evil-save-and-close]          'yas-load-snippet-buffer-and-close
     [remap evil-save-modified-and-close] 'yas-load-snippet-buffer-and-close
     [remap evil-quit]                    'kill-this-buffer)
    :custom
    (yas-snippet-dirs (list (file-name-as-directory
                             (locate-user-emacs-file "snippets"))))
    (yas-indent-line 'auto)
    (yas-also-auto-indent-first-line t)
    :init
    (evil-define-command ex-snippet (cmd)
      (interactive "<a>")
      (require 'yasnippet)
      (cond
       ((string= cmd "reload") (yas-reload-all))
       ((string= cmd "edit") (yas-visit-snippet-file))
       ((string= cmd "new") (yas-new-snippet))
       (t (yas-insert-snippet))))
    (evil-ex-define-cmd "sn[ippets]" 'ex-snippet)
    :config
    (defun yas-with-comment (str)
      ;; TODO: note that this is a hack; the proper way should be
      ;; something as written in the comment box. That said, the
      ;; "proper" way is also not working.

      ;; (with-temp-buffer
      ;;   (format "%s" str)
      ;; this might explain why this function seems to bug out sometimes.
      ;;   (comment-normalize-vars)
      ;;   (comment-region (point-min) (point-max))
      ;;   (buffer-string)))
      (let ((comment-start (cond ((eq major-mode 'emacs-lisp-mode) ";; ")
                                 ((eq major-mode 'terraform-mode) "# ")
                                 (t comment-start))))
       (format "%s%s%s" comment-start str comment-end)))
    (yas-global-mode))
#+end_src

*** Auto-yasnippet
#+begin_src emacs-lisp :results output silent
  (use-package auto-yasnippet
    :straight (:host github :repo "abo-abo/auto-yasnippet")
    :commands (aya-create
               aya-expand)
    :custom
    (aya-case-fold t "smartcasing"))
#+end_src

* Lisp
** Parinfer
#+begin_src emacs-lisp :results output silent
  (use-package parinfer
    ;; :straight (:host github :repo "DogLooksGood/parinfer-mode")
    :straight t
    :commands (parinfer-mode)
    :general
    (parinfer-mode-map
     "\"" nil) ;; let smartparens do its thing
    (:states 'motion
     "g p" 'parinfer-toggle-mode)
    :custom
    (parinfer-auto-switch-indent-mode
     t "We prefer indent mode")
    (parinfer-auto-switch-indent-mode-when-closing
     t)
    :init
    (progn (setq parinfer-extensions
                 '(defaults       ; should be included.
                    pretty-parens  ; different paren styles for different modes.
                    evil           ; if you use evil.
                    ;; smart-tab      ; c-b & c-f jump positions and smart shift with tab & s-tab.
                    smart-yank))))   ; yank behavior depend on mode.
#+end_src

** Parinfer Rust Mode
#+begin_src emacs-lisp :results output silent
  (use-package parinfer-rust-mode
    :straight t
    :if (not (eq 'windows-nt system-type))
    :commands (parinfer-rust-mode)
    :general
    (:states 'motion
     "g p" 'parinfer-rust-toggle-paren-mode)
    :custom
    (parinfer-rust-auto-download t))
#+end_src

** my-maybe-init-parinfer
#+begin_src emacs-lisp :results output silent
  (defun my-maybe-init-parinfer ()
    (if (and (not (eq 'windows-nt system-type))
             (bound-and-true-p parinfer-rust-mode))
        (parinfer-rust-mode)
      (parinfer-mode)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (add-hook 'emacs-lisp-mode-hook #'my-maybe-init-parinfer)
  (add-hook 'racket-mode-hook #'my-maybe-init-parinfer)
  (add-hook 'clojure-mode-hook #'my-maybe-init-parinfer)
  (add-hook 'hy-mode-hook #'my-maybe-init-parinfer)
#+end_src

** Rainbow Delimiter Mode
Consider deprecating this now we're trying out prism

#+begin_src emacs-lisp :results output silent
  (use-package rainbow-delimiters
    :straight (:host github :repo "Fanael/rainbow-delimiters")
    :commands (rainbow-delimiters-mode-enable)
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     ")" 'rainbow-delimiters-mode
     "(" 'rainbow-delimiters-mode)
    :custom (rainbow-delimiters-max-face-count 3)
    :hook (prog-mode-hook . rainbow-delimiters-mode-enable))
#+end_src

** Rainbow Identifiers Mode
It looks fairly jarring to be very honest.

#+begin_src emacs-lisp :results output silent
  (use-package rainbow-identifiers
    :straight (:host github :repo "Fanael/rainbow-identifiers")
    :commands (rainbow-identifiers-mode))
#+end_src

** Rainbow Blocks
Refer to prism

#+begin_src emacs-lisp :results output silent
  (use-package rainbow-blocks
    :straight (:host github :repo "istib/rainbow-blocks")
    :disabled t
    :commands (rainbow-blocks-mode
               rainbow-blocks-mode-enable))
#+end_src

** Prism mode
Much like rainbow blocks mode, but better.
#+begin_src emacs-lisp :results output silent
  (use-package prism
    :straight (:host github :repo "alphapapa/prism.el")
    :commands (prism-mode
               prism-whitespace-mode)
    :hook
    ((racket-mode-hook . prism-mode)
     (clojure-mode-hook . prism-mode)
     (json-mode-hook . prism-mode)
     (emacs-lisp-mode-hook . prism-mode)
     (hy-mode-hook . prism-mode))
    :preface
    (use-package anaphora
      :straight (:host github :repo "rolandwalker/anaphora")))
#+end_src

* Elisp                                                               :major:
package is known as elisp-mode but it reads as emacs-lisp

#+begin_src emacs-lisp :results output silent
  (use-package elisp-mode
    :straight nil
    :hook ((emacs-lisp-mode-hook . update-evil-shift-width)))
           ;; (emacs-lisp-mode-hook . (lambda () (setq-local comment-begin ";; "))))) ;; not working for some reason
           ;; (emacs-lisp-mode-hook . (lambda ()
           ;;                      (mapc (lambda (pair) (push pair
           ;;                                            prettify-symbols-alist
           ;;                            '(("nil"      . #x2205)
           ;;                              ("not"      . #xac)
           ;;                              ("<="       . #x2264)
           ;;                              (">="       . #x2265)
           ;;                              ;; ("defun" . #x0192)
           ;;                              ("or"       . #x2228)
           ;;                              ("and"      . #x2227))))
#+end_src

** Update Lisp indent calculation function
NOTE: We want to carefully override this
https://old.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/

+https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned+
+https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94+

#+begin_src emacs-lisp :results output silent
  (with-eval-after-load "lisp-mode"
    (defun lisp-indent-function (indent-point state)
       "This function is the normal value of the variable `lisp-indent-function'.
  The function `calculate-lisp-indent' calls this to determine
  if the arguments of a Lisp function call should be indented specially.
  INDENT-POINT is the position at which the line being indented begins.
  Point is located at the point to indent under (for default indentation);
  STATE is the `parse-partial-sexp' state for that position.
  If the current line is in a call to a Lisp function that has a non-nil
  property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
  it specifies how to indent.  The property value can be:
  ,* `defun', meaning indent `defun'-style
    \(this is also the case if there is no property and the function
    has a name that begins with \"def\", and three or more arguments);
  ,* an integer N, meaning indent the first N arguments specially
    (like ordinary function arguments), and then indent any further
    arguments like a body;
  ,* a function to call that returns the indentation (or nil).
    `lisp-indent-function' calls this function with the same two arguments
    that it itself received.
  This function returns either the indentation to use, or nil if the
  Lisp function does not specify a special indentation."
       (let ((normal-indent (current-column))
             (orig-point (point)))
         (goto-char (1+ (elt state 1)))
         (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
         (cond
          ;; car of form doesn't seem to be a symbol, or is a keyword
          ((and (elt state 2)
                (or (not (looking-at "\\sw\\|\\s_"))
                    (looking-at ":")))
           (if (not (> (save-excursion (forward-line 1) (point))
                       calculate-lisp-indent-last-sexp))
               (progn (goto-char calculate-lisp-indent-last-sexp)
                      (beginning-of-line)
                      (parse-partial-sexp (point)
                                          calculate-lisp-indent-last-sexp 0 t)))
           ;; Indent under the list or under the first sexp on the same
           ;; line as calculate-lisp-indent-last-sexp.  Note that first
           ;; thing on that line has to be complete sexp since we are
           ;; inside the innermost containing sexp.
           (backward-prefix-chars)
           (current-column))
          ((and (save-excursion
                  (goto-char indent-point)
                  (skip-syntax-forward " ")
                  (not (looking-at ":")))
                (save-excursion
                  (goto-char orig-point)
                  (looking-at ":")))
           (save-excursion
             (goto-char (+ 2 (elt state 1)))
             (current-column)))
          (t
           (let ((function (buffer-substring (point)
                                             (progn (forward-sexp 1) (point))))
                 method)
             (setq method (or (function-get (intern-soft function)
                                            'lisp-indent-function)
                              (get (intern-soft function) 'lisp-indent-hook)))
             (cond ((or (eq method 'defun)
                        (and (null method)
                             (> (length function) 3)
                             (string-match "\\`def" function)))
                    (lisp-indent-defform state indent-point))
                   ((integerp method)
                    (lisp-indent-specform method state
                                          indent-point normal-indent))
                   (method
                    (funcall method indent-point state)))))))))
#+end_src

** Elmacro
#+begin_src emacs-lisp :results output silent
  (use-package elmacro
    :straight (:host github :repo "Silex/elmacro")
    :commands (elmacro-show-last-macro
               elmacro-show-last-commands
               elmacro-clear-recorded-commands)
    :config
    (elmacro-mode))
#+end_src

* Racket
#+begin_src emacs-lisp :results output silent
  (use-package racket-mode
    :straight (:host github :repo "greghendershott/racket-mode")
    :commands (racket-mode)
    :mode "\\.rkt\\'"
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("rkt" . racket) org-src-lang-modes)))
#+end_src

* AES Encryption

#+begin_src emacs-lisp :results output silent
  (use-package aes
    :defer nil
    :straight (:host github :repo "Sauermann/emacs-aes")
    :commands (aes-toggle-encryption ;; this makes it auto encrypt/decrypt
               aes-insert-password
               aes-remove-encryption-hook
               aes-is-encrypted
               aes-enable-auto-decryption
               aes-encrypt-buffer-or-string
               aes-decrypt-buffer-or-string)
    ;; :hook (change-major-mode-hook . (lambda ()
    ;;                                   (when (aes-is-encrypted)
    ;;                                     (auto-save-mode -1)
    ;;                                     (aes-toggle-encryption))))
    :init
    ;; TODO: figure out how to do this for the whole buffer using
    ;; `org-element-*' functions
    (defun --toggle-encrypt-org-roam-subtree ()
      "Encrypt the content of the org subtree with the org ID of the
  document. Aborts if one is not found. There is probably a better way
  to do encrypt the text, perhaps automatically on hook, but this should
  serve for now."
      (interactive)
      (-let* (((beg subtree-end _) (evil-org-inner-subtree))
              ;; TODO: is there an existing function for this?
              (end (save-excursion
                     (goto-char subtree-end)
                     (+ subtree-end (skip-chars-backward " \t\n"))))
              (password (org-id-get (point-min)))
              (text (progn
                      (save-excursion
                        (goto-char beg)
                        (outline-show-subtree))
                      (buffer-substring beg end)))
              (is-encrypted (with-temp-buffer
                              (insert text)
                              (aes-is-encrypted))))
        (unless password
          (user-error "Can't get file's ID."))
        (let ((result (if is-encrypted
                          (aes-decrypt-buffer-or-string text password)
                        (aes-encrypt-buffer-or-string text password))))
          (replace-region-contents beg end (lambda () result)))))

    (evil-define-command ex-encrypt-buffer ()
      (interactive)
      (if (aes-is-encrypted)
          (aes-decrypt-current-buffer)
        (aes-encrypt-current-buffer)))
    (evil-ex-define-cmd "X" 'ex-encrypt-buffer)
    (add-to-list 'auto-mode-alist '("\\.enc\\'"
                                    #'(lambda ()
                                        (when (aes-is-encrypted)
                                          (aes-toggle-encryption))) t)))
#+end_src

** Encrypt operator
#+begin_src emacs-lisp :results output silent
  (evil-define-operator evil-encrypt-aes (beg end)
    "Attempt to encrypt or decrypt a range using
  `aes-encrypt-buffer-or-string' and `aes-decrypt-buffer-or-string'"
    (require 'aes)
    (let ((buf (current-buffer)))
      (with-temp-buffer
        ;; Copy region into a temporary buffer so we can encrypt/decrypt
        (insert-buffer-substring buf beg end)
        ;; Discard newline so the aes functions can check if it's
        ;; encrypted. We might want to just skip the newlines instead of
        ;; discarding them in the future, so that a-textobjects can also
        ;; work instead of just i-textobjects
        (flush-lines "^$" (point-min) (point-max))
        (if (aes-is-encrypted)
            (aes-decrypt-buffer-or-string (current-buffer))
          (aes-encrypt-buffer-or-string (current-buffer)))
        ;; Copy result back into original buffer
        (let ((temp-buf (current-buffer)))
          (with-current-buffer buf
            ;; Delete original text before copying
            (delete-region beg end)
            (insert-buffer-substring temp-buf))))))
#+end_src

#+begin_src emacs-lisp :results output silent
  (general-define-key
    :keymaps 'normal
    "g X" 'evil-encrypt-aes)
#+end_src

* Clojure                                                             :major:
clojurescript-mode derives from clojure-mode

[[https://clojure.org/api/cheatsheet][Cheatsheet]]

#+begin_src emacs-lisp :results output silent
  (use-package clojure-mode
    :straight (:host github :repo "clojure-emacs/clojure-mode")
    :commands (clojure-mode
               clojurescript-mode)
    :hook ((clojure-mode-hook . update-evil-shift-width)
           (clojure-mode-hook . show-paren-mode))
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("edn" . clojure) org-src-lang-modes)
      (cl-pushnew '("clj" . clojure) org-src-lang-modes)
      (cl-pushnew '("cljs" . clojurescript) org-src-lang-modes)))
#+end_src

** CIDER
When using straight, we first encounter =cider-test.el= not found, and
then later on =package sesman not found in recipe repositories=

Sesman is not found normally by cider, so we had to manually clone it

This is actually fairly expensive to load
#+begin_src emacs-lisp :results output silent
  (use-package sesman
    :straight (:host github :repo "vspinu/sesman")
    :defer t)
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package cider
    :commands (cider-jack-in
               cider-connect)
    :straight (:host github :repo "clojure-emacs/cider"
               :files (:defaults "cider-test.el")))
#+end_src

We were unable to launch a shadow-cljs nREPL directly, but we are able
to successfully connect (using =cider-connect-cljs=) into a repl we
ran using ~shadow-cljs watch app~. Do note that the socket REPL and
nREPL server runs on different ports, and neither were the ones
recommended by the cider completion engine.

We should look at customizing cider someday.

* Rust                                                                :major:
#+begin_src emacs-lisp :results output silent
  (use-package rust-mode
    :straight (:host github :repo "rust-lang/rust-mode")
    :mode
    ("\\.rs\\'" . rust-mode)
    :custom
    (rust-format-on-save nil "something is causing formatted windows to close on mac")
    (rust-format-show-buffer nil
                             "Stop polluting my workspace with orphaned
                             windows thanks")
    :general
    (:states 'insert
     :keymaps 'rust-mode-map
     "RET" 'comment-indent-new-line)
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("rust" . rust) org-src-lang-modes)))
#+end_src

** Cargo
Requires rust-mode and markdown-mode
#+begin_src emacs-lisp :results output silent
  (use-package cargo
    :straight (:host github :repo "kwrooijen/cargo.el")
    :diminish cargo-minor-mode
    :commands cargo-minor-mode
    :hook (rust-mode-hook . cargo-minor-mode))
    ;; :init
    ;; (evil-define-command my-cargo-wrapper (arg)
    ;;   (interactive "<a>")
    ;;   (cond
    ;;    ()))
    ;; (evil-ex-define-cmd "cargo" 'my-cargo-wrapper))
#+end_src

** Cargo-Mode
#+begin_src emacs-lisp :results output silent
  (use-package cargo-mode
    :straight (:host github :repo "ayrat555/cargo-mode")
    :commands
    (cargo-mode-execute-task
     cargo-mode-test
     cargo-mode-last-command
     cargo-mode-build
     cargo-mode-test-current-buffer
     cargo-mode-test-current-test))
#+end_src

* Dired
- Make it more like netrw


[[https://gist.github.com/t-mart/610795fcf7998559ea80][Netrw map]]

#+begin_src emacs-lisp :results output silent
#+end_src

#+begin_src emacs-lisp :results output silent
  ;; TODO: update `dired-collapse--create-ov' to not hardcode the shadow
  ;; face. This should be a PR
  (use-package dired-hacks
    :ensure nil
    :after dired
    :straight (:host github :repo "Fuco1/dired-hacks")
    :custom-face
    (dired-subtree-depth-1-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    (dired-subtree-depth-2-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    (dired-subtree-depth-3-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    (dired-subtree-depth-4-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    (dired-subtree-depth-5-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    (dired-subtree-depth-6-face ((((background light)) (:background ,sol-base2))
                                 (((background dark)) (:background, sol-base02))))
    ;; :general
    ;; (dired-mode-map
    ;;  :states 'normal
    ;;   "TAB" 'dired-subtree-toggle
    ;;   "z a" 'dired-subtree-toggle
    ;;   "z o" 'dired-subtree-insert
    ;;   "z c" 'dired-subtree-remove)
    :hook ((dired-mode-hook . dired-collapse-mode)
           (dired-mode-hook . dired-filter-mode)))
#+end_src

note: use :Ex instead like Vim does
# #+begin_src emacs-lisp :results output silent
#   (general-define-key :keymaps 'normal
#     "-" 'open-dired-window)
# #+end_src

** Dired+
#+begin_src emacs-lisp :results output silent
  ;; (unless (el-get-package-is-installed 'dired+)
  ;;   (el-get-emacswiki-build-local-recipes)
  ;;   (el-get-install 'dired+))
  ;; (use-package dired+
  ;;   :ensure nil
  ;;   :straight nil
  ;;   :after dired
  ;;   :custom-face
  ;;   (diredp-dir-heading ((t (:inherit font-lock-warning-face :bold t))))
  ;;   (diredp-dir-name ((t (:inherit font-lock-string-face :bold t))))
  ;;   (diredp-file-name ((t (:inherit font-lock-function-name-face))))
  ;;   (diredp-file-suffix ((t (:inherit font-lock-type-face))))
  ;;   (diredp-ignored-file-name ((t (:inherit 'font-lock-comment-face))))
  ;;   (diredp-flag-mark ((t (:inherit font-lock-keyword-face)))))
#+end_src

** w32-browser
#+begin_src emacs-lisp :results output silent
  ;; (unless (el-get-package-is-installed 'w32-browser)
  ;;   (el-get-emacswiki-build-local-recipes)
  ;;   (el-get-install 'w32-browser))
  ;; (use-package w32-browser
  ;;   :ensure nil
  ;;   :straight nil
  ;;   :after dired)
#+end_src

* Help
#+begin_src emacs-lisp :results output silent
  ;; (general-define-key
  ;;  :keymaps 'help-mode-map
  ;;  :states 'normal
  ;;  "f" 'ace-link-help
  ;;  "F" 'ace-link-help)
#+end_src

* Help+
- Emacswiki :: https://www.emacswiki.org/emacs/HelpPlus


These packages are from emacswiki, and are currently not being maintained.

They are being stored and loaded locally, since they are not on melpa or any
package manager

#+begin_src emacs-lisp :results output silent
  (use-package help+
    :disabled t
    :defer 7
    :straight nil
    :load-path "local-packages/")
  (use-package help-macro+
    :defer 7
    :disabled t
    :straight nil
    :load-path "local-packages/")
  (use-package help-mode+
    :defer 7
    :disabled t
    :straight nil
    :load-path "local-packages/")
  (use-package help-fns+
    :defer 7
    :disabled t
    :straight nil
    :commands (describe-keymap
               describe-buffer
               describe-command
               describe-option
               describe-key-briefly
               describe-option-of-type
               describe-copying
               find-function-on-key)
    :load-path "local-packages/")
#+end_src

* Dumb Jump
#+begin_src emacs-lisp :results output silent
  (use-package dumb-jump
    :straight (:host github :repo "jacktasia/dumb-jump")
    :commands
    (dumb-jump-xref-activate)
    :hook
    (xref-backend-functions . dumb-jump-xref-activate))
#+end_src

* JSON                                                                :major:
#+begin_src emacs-lisp :results output silent
  (use-package json-mode
    :straight (:host github :repo "joshwnj/json-mode")
    :mode "\\.json\\'"
    :commands (json-mode)
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("json" . json) org-src-lang-modes)))
#+end_src

** Json Snatcher
#+begin_src emacs-lisp :results output silent
  (use-package json-snatcher
    :straight t
    :commands (jsons-print-path))
#+end_src

* YAML
https://github.com/zkry/yaml.el/tree/9ebddb55238d746dc5a5d46db04c9f360c140b99
#+begin_src emacs-lisp :results output silent
  (use-package yaml
    :straight t
    :commands (yaml-parse-string))
#+end_src

* Wgrep
Being able to mass-edit using search results seem interesting
http://blog.binchen.org/posts/use-wgrep-and-evil-to-replace-text-efficiently.html

In the =ag= buffer call =C-c C-p= to launch wgrep.

#+begin_src emacs-lisp :results output silent
  (use-package wgrep
    :straight (:host github :repo "mhayashi1120/Emacs-wgrep")
    :commands (wgrep-change-to-wgrep-mode)
    :custom (wgrep-auto-save-buffer t))
#+end_src

* Ripgrep (rg)
:PROPERTIES:
:DEPENDENCIES: wgrep
:END:

*rg* buffer bindings

| Key | Description                              |
|-----+------------------------------------------|
| c   | Toggle case insensitive setting          |
| d   | Change directory                         |
| f   | Change file pattern                      |
| g   | Rerun search                             |
| i   | Toggle --no-ignore flag                  |
| l   | List search buffers in a separate buffer |
| r   | Edit search string as regexp             |
| s   | Save search result to unique name        |
| S   | Save search result, prompt for name      |
| t   | Edit search string as literal            |
| w   | Switch to wgrep mode                     |
| C-f | Navigate forward in search history       |
| C-b | Navigate backward in search history      |

*use =everything= to search with no filters. =all= searches with all
filters*.

#+begin_src emacs-lisp :results output silent
  (use-package rg
    :straight (:host github :repo "dajva/rg.el")
    :commands (rg
               rg-project
               rg-dwim
               rg-literal
               rg-define-search
               rg-menu)
    :custom
    (rg-ignore-case 'smart)
    (rg-keymap-prefix "")
    (rg-default-alias-fallback "everything")
    (rg-buffer-name #'(lambda () (format "*rg<%s>*" (buffer-name))))
    :general
    (rg-mode-map
     :states '(motion normal)
     "gg" 'evil-goto-first-line)
    (grep-mode-map
     :states '(motion normal)
      "n" 'evil-ex-search-next
      "N" 'evil-ex-search-previous)
    (:states '(normal motion visual)
     "C-+" 'rg-menu)
    :init
    ;; (evil-define-command config-rg-explicit (arg)
    ;;   (interactive "<a>") ;TODO: Figure out how to programmatically generate a files list, which we need in addition to a query
    ;;   (cond
    ;;    ;; ((and arg (projectile-project-p)) (rg-project arg))
    ;;    ((and (not arg) (projectile-project-p)) (call-interactively 'rg-project))
    ;;    ;; (arg (rg arg))
    ;;    (t (call-interactively 'rg))))
    (evil-ex-define-cmd "rg" 'rg-menu)
    ;; (evil-ex-define-cmd "prg" 'rg-project)
    :config
    (rg-enable-menu)
    (rg-define-search search-everything-in-project
      "Uses the everything filter for project searches"
      :files "everything"
      :dir project
      :menu ("Custom" "e" "Unfiltered Project"))
    (with-eval-after-load 'hl-todo
      (rg-define-search search-hl-todo-keywords
        "Uses the everything filter for project searches"
        :query (-> (mapcar 'car hl-todo-keyword-faces)
                   (string-join "|"))
        :format regexp
        :files "everything" ;; make this "all" maybe?
        :dir project
        :menu ("Custom" "hl" "`hl-todo' Keywords"))
      (evil-ex-define-cmd "hl-todo" 'search-hl-todo-keywords)))
#+end_src
* C++
** Indentation of 4
#+begin_src emacs-lisp :results output silent
  (setq-default c-basic-offset 4)
#+end_src

** Default to K&R style
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'cc-mode
    (cl-dolist (mode '(c-mode c++-mode))
      (add-to-list 'c-default-style `(,mode . "k&r"))))
#+end_src

** Newline in comments should insert an indented comment
#+begin_src emacs-lisp :results output silent
  (general-define-key :states 'insert
                      :keymaps 'c-mode-base-map
                      "C-<return>" 'comment-indent-new-line)
#+end_src

** Treat .h files as cpp files
#+begin_src emacs-lisp :results output silent
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+end_src

** Treat .hpp files as cpp files
#+begin_src emacs-lisp :results output silent
  (add-to-list 'auto-mode-alist '("\\.hpp\\'" . c++-mode))
#+end_src

** cpp-specific ligatures
We do not support =&&= (and hence also =||=) because of conflicts with
r-value references.
#+begin_src emacs-lisp :results output silent
  (add-hook 'c-mode-common-hook
            #'(lambda ()
                (mapc (lambda (pair) (push pair prettify-symbols-alist))
                      '(("!=" . #x2260)
                        ("!" . #xac)
                        ;; ("==" . #x2a75) ;; Not supported by Iosevka
                        ;; ("->" . #x27f6) ;; Not supported by Iosevka
                        ("->" . #x2192) ;; 1-char width version
                        ("<=" . #x2264)
                        (">=" . #x2265)))))
                        ;; ("&&" . #x2227)
                        ;; ("||" . #x2228)))))
#+end_src

** Clang Format
#+begin_src emacs-lisp :results output silent
  (use-package clang-format
    :straight (:host github :repo "emacsmirror/clang-format")
    :commands (clang-format-region
               clang-format-buffer
               clang-format)
    :general
    (c++-mode-map
     :states '(normal)
      "C-c C-f" 'my-evil-clang-format)
    (java-mode-map
     :states '(normal)
      "C-c C-f" 'my-evil-clang-format)
    :init
    (evil-define-operator my-evil-clang-format (beg end)
      (require 'clang-format)
      (clang-format beg end))
    (defun toggle-clang-format-on-save ()
      "Toggle clang-format-buffer on a per-buffer level."
      (interactive)
      (unless (boundp 'toggle-clang-format-on-save)
        (setq-local toggle-clang-format-on-save nil))
      (if (not toggle-clang-format-on-save)
          (progn (add-hook 'before-save-hook 'clang-format-buffer t t)
                 (setq-local toggle-clang-format-on-save t)
                 (message "toggle-clang-format-on-save t"))
        (remove-hook 'before-save-hook 'clang-format-buffer t)
        (setq-local toggle-clang-format-on-save nil)
        (message "toggle-clang-format-on-save nil")))
    :custom
    (clang-format-style-option "file"
                               "read from .clang-format"))
#+end_src

*** Clang-Format+
#+begin_src emacs-lisp :results output silent
  (use-package clang-format+
    :after clang-format
    :straight t)
#+end_src

* Disable autoformatting modes when drawing things
You can consider =artist-mode= a featurewise superset of =picture-mode=.

#+begin_src emacs-lisp :results output silent
  (add-hook 'artist-mode-hook #'(lambda () (aggressive-fill-paragraph-mode -1)))
#+end_src

* Org source block handling for Artist-mode
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'org-src
    (cl-pushnew '("artist" . artist) org-src-lang-modes))
#+end_src

* Ledger                                                              :major:
#+begin_src emacs-lisp :results output silent
  (use-package ledger-mode
    :disabled t
    :mode "\\.ledger\\'"
    :straight (:host github :repo "ledger/ledger-mode"
               :files (:defaults "ledger-test.el"))
    :init
      (with-eval-after-load 'org-src
        (cl-pushnew '("ledger" . ledger) org-src-lang-modes)))
#+end_src

** Evil-ledger
#+begin_src emacs-lisp :results output silent
  (use-package evil-ledger
    :disabled t
    :straight (:host github :repo "atheriel/evil-ledger")
    :after (ledger-mode))
#+end_src

* Beancount
It's a minor mode, much like how magit's commit mode is a minor mode
#+begin_src emacs-lisp :results output silent
  (use-package beancount
    :straight (:host github :repo "beancount/beancount-mode")
    :mode (("\\.beancount\\'" . beancount-mode)
           ("\\.ledger\\'" . beancount-mode))
    :init
    (defun my-beancount-insert-date ()
      "Does the same thing as `beancount-insert-date', but uses
  `org-read-date' for more ergonomic date generation."
      (interactive)
      (unless (bolp) (newline)) ;; `beancount-insert-date' does this
      (insert (org-read-date) " "))
    ;; TODO: Add more from
    ;; `https://beancount.github.io/docs/beancount_language_syntax.html`
    (when (bound-and-true-p --default-ledger-file)
      (with-eval-after-load 'org-capture
        (setq org-capture-templates
              (doct-add-to
               org-capture-templates
               '(("Beancount"
                  :keys "bean"
                  ;; :contexts (:in-mode "beancount-mode")
                  :type plain
                  :file --default-ledger-file
                  :unnarrowed t ;; critical for completion to function
                  :empty-lines-before 1
                  :children
                  (("Today"
                    :keys "today"
                    :children
                    (("Open new account"
                      :keys "open"
                      :template
                      ("%<%Y-%m-%d> open %? %^{CURRENCY}"))
                     ("Transaction"
                      :keys "tx"
                      :template
                      ("%<%Y-%m-%d> * \"%^{VENDOR}\" \"%^{PURCHASE}\""
                       "  %?"))))
                   ("On Date"
                    :keys "date"
                    :date (lambda () (org-read-date))
                    :children
                    (("Open new account"
                      :keys "open"
                      :template
                      ("%{date} open %? %^{CURRENCY}"))
                     ("Transaction"
                      :keys "tx"
                      :template
                      ("%{date} * \"%^{VENDOR}\" \"%^{PURCHASE}\""
                       "  %?")))))))))))
    (my-evil-define-split-vsplit-cmd
     "ledger"
     #'(lambda () (interactive)
         (find-file --default-ledger-file)))
    :general
    (beancount-mode-map
     "M-RET" #'my-beancount-insert-date)
    :hook
    (beancount-mode-hook . outline-minor-mode)
    :config
    (with-eval-after-load 'org-src
      (cl-pushnew '("beancount" . beancount) org-src-lang-modes)))
    ;; :general
    ;; (beancount-mode-map
    ;;  :states '(normal motion insert)
    ;;  "<f5>" #'(lambda () (interactive)
    ;;            (insert (format-time-string "%Y-%m-%d"))))
    ;; causing fontification errors
    ;; :hook ((org-mode-hook . beancount-mode)))
#+end_src

* Hledger                                                             :major:
#+begin_src emacs-lisp :results output silent
  (use-package hledger-mode
    :disabled t
    :straight (:host github :repo "narendraj9/hledger-mode")
    :mode "\\.ledger\\'")
#+end_src

* Abbreviations
#+begin_src emacs-lisp :results output silent
  (use-package abbrev
    :ensure nil
    :straight nil
    :delight (abbrev-mode nil "abbrev")
    :custom
    (abbrev-file-name (locate-user-emacs-file "abbrevs.el"))
    (save-abbrevs 'silently)
    (only-global-abbrevs t)
    :general
    (edit-abbrevs-mode-map
     [remap evil-save] 'abbrev-edit-save-buffer)
    (:states '(normal visual)
     :prefix my-default-evil-leader-key
     "a a" 'inverse-add-global-abbrev)
    :init
    ;; This makes it active globally
    (setq-default abbrev-mode t)
    (evil-define-command my-inverse-add-global-abbrev (beg end _type)
      "Generates an abbrev for the given visual selection."
      (interactive "<v>")
      (require 'abbrev)
      ;; nil if there is no visual region; the number of words in the
      ;; region otherwise
      ;; (add-global-abbrev
      ;;  (if (and beg end)
      ;;      (-> (buffer-substring-no-properties beg end)
      ;;          (split-string)
      ;;          (length))
      ;;    1))))
      ;; (evil-define-command ex-abbreviation (arg)
      ;;   "Attempts to replicate the :abbreviate function in vim.
      ;; :ab - Shows you the abbreviation tables
      ;; :ab A B [C D E] - Expands \"A\" to \"B C D E\". At least 2 arguments
      ;; must be given, otherwise it's a no-op."
      ;;   (interactive "<a>")
      ;;   ;; TODO: figure out what happens if we want the expansion to have
      ;;   ;; variable space length. We currently don't care, because odds are
      ;;   ;; we want our expansion to look like good english anyway.
      ;;   (if (not arg)
      ;;       (edit-abbrevs)
      ;;     (let* ((arguments (split-string arg))
      ;;            (size (safe-length arguments)))
      ;;       (cond
      ;;        ((= size 1) nil) ;; no op, as far as I can tell
      ;;        (t (let ((expansion (mapconcat 'identity (cdr arguments) " ")))
      ;;             (define-global-abbrev (car arguments) expansion)))))))
      ;; (evil-ex-define-cmd "ab[breviate]" 'ex-abbreviation))
      ;; (if (and beg end)
      ;;     (let ((current-prefix-arg 0))
      ;;       (call-interactively 'add-global-abbrev))
      ;;   (call-interactively 'inverse-add-global-abbrev))
      (let* ((name (if (region-active-p)
                      (buffer-substring-no-properties beg end)
                      (thing-at-point 'word)))
             (exp (read-string (format "abbrev for \"%s\": " name))))
        (define-abbrev global-abbrev-table (downcase name) exp))))
#+end_src



* Writeroom
#+begin_src emacs-lisp :results output silent
  (use-package writeroom-mode
    :straight (:host github :repo "joostkremers/writeroom-mode")
    :commands (writeroom-mode)
    :custom
    (writeroom-mode-line t)
    (writeroom-bottom-divider-width 0)
    (writeroom-maximize-window nil)
    (writeroom-fullscreen-effect 'maximized)
    (writeroom-width 80)
    (writeroom-restore-window-config nil)
    ;; :general
    ;; (:states 'normal
    ;;  "g z" 'writeroom-mode)
    :init
    (evil-ex-define-cmd "writeroom" 'writeroom-mode))
    ;; :hook
    ;; ((writeroom-mode-hook . (lambda () (require 'focus)
    ;;                      (if writeroom-mode
    ;;                          (progn (focus-init)
    ;;                                 (when display-line-numbers-mode
    ;;                                   (display-line-numbers-mode -1)))
    ;;                        (focus-terminate)
    ;;                        (unless display-line-numbers-mode
    ;;                          (display-line-numbers-mode)))))))
#+end_src

* Helpful
#+begin_src emacs-lisp :results output silent
  (use-package helpful
    :straight (:host github :repo "Wilfred/helpful")
    :general
    ("C-h k"   'helpful-key
     "C-h f"   'helpful-callable
     "C-h v"   'helpful-variable
     "C-h o"   'helpful-symbol
     "C-h RET" 'helpful-at-point
     "C-h M-k" '--helpful-keymap)
    :init
    (defun --helpful-keymap ()
      (interactive)
      (require 'helpful)
      (let ((sym (--completing-read "Keymap: " obarray
                                    :predicate #'(lambda (sym)
                                                   (and (boundp sym)
                                                        (keymapp (symbol-value sym))))
                                    :require-match t)))
        (-> sym (intern) (helpful-symbol))))
    :config
    (require 'link-hint)
    (general-define-key
     :keymaps 'helpful-mode-map
     :states 'normal
     "f" 'link-hint-open-link
     "y f" 'link-hint-copy-link))
    ;; (helpful-mode-map
    ;;  :states 'normal
    ;;  "f" 'ace-link-help
    ;;  "F" 'ace-link-help))
#+end_src

* Elisp demos

#+begin_src emacs-lisp :results output silent
  (use-package elisp-demos
    :after (helpful)
    :straight (:host github :repo "xuchunyang/elisp-demos"
               :files (:defaults "elisp-demos.org"))
    :config
    (with-eval-after-load 'helpful
      (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
    (advice-add 'describe-function-1 :after #'elisp-demos-advice-describe-function-1))
#+end_src

* Make shell open in same window
- Related Spacemacs Issue ::
  https://github.com/syl20bnr/spacemacs/issues/6820
- Make shell mode update working directory ::
  [[https://emacs.stackexchange.com/questions/5589/automatically-update-default-directory-when-pwd-changes-in-shell-mode-and-term-m][stackoverflow]]


Let's try just creating the shell on the side instead of overtaking
the thing, because that's what vim does.

#+begin_src emacs-lisp :results output silent
  (use-package shell
    :ensure nil
    :straight nil
    :commands shell
    :custom
    ;; Make cursor always move to end when entering insert mode in
    ;; comint modes
    (comint-scroll-to-bottom-on-input t)
    (comint-prompt-read-only t)
    :init
    (defun my-buffer-specific-shell ()
      (interactive)
      (let ((name (format "*shell<%s>*" (buffer-name))))
        (shell name)))
    (evil-ex-define-cmd "sh[ell]" #'(lambda () (interactive)
                                     (my-buffer-specific-shell)))
    (evil-ex-define-cmd "Sshell" #'(lambda () (interactive)
                                    (evil-window-split)
                                    (my-buffer-specific-shell)))
    (evil-ex-define-cmd "Vshell" #'(lambda () (interactive)
                                    (evil-window-vsplit)
                                    (my-buffer-specific-shell)))
    (add-to-list 'display-buffer-alist '("\\*shell\\*" . (display-buffer-same-window . nil)))
    :hook
    ((shell-mode-hook . (lambda ()
                          (shell-dirtrack-mode 0)
                          (set-variable 'dirtrack-list '("^.*[^ ]+:\\(.*\\)>" 1 nil))
                          (dirtrack-mode 1)))))
#+end_src

** Org-babel Shell
#+begin_src emacs-lisp :results output silent
  (org-babel-do-load-languages 'org-babel-load-languages '((shell . t)))
#+end_src

* Groovy mode                                                         :major:
#+begin_src emacs-lisp :results output silent
  (use-package groovy-mode
    :straight (:host github :repo "Groovy-Emacs-Modes/groovy-emacs-modes")
    :mode (("\\.groovy\\'" . groovy-mode)
           ("\\Jenkinsfile\\'" . groovy-mode))
    :hook ((groovy-mode-hook . (lambda () (setq-local comment-start "// "))))
    :init
    (with-eval-after-load 'org-src
        (cl-pushnew '("groovy" . groovy) org-src-lang-modes)))
#+end_src

* Hy Mode                                                             :major:
#+begin_src emacs-lisp :results output silent
  (use-package hy-mode
    :straight (:host github :repo "hylang/hy-mode")
    :mode "\\.hy\\'"
    :general
    (hy-mode-map
     :states 'insert
     "RET" 'comment-indent-new-line)
    :hook ((hy-mode-hook . update-evil-shift-width)
           (hy-mode-hook . show-paren-mode))
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("hy" . hy) org-src-lang-modes)))
#+end_src

** ob-hy
#+begin_src emacs-lisp :results output silent
  (use-package ob-hy
    :straight (:host github :repo "brantou/ob-hy")
    :after org-src)
#+end_src

* so-long-mode / vlf-mode
#+begin_src emacs-lisp :results output silent
  (if (>= emacs-major-version 27)
      (global-so-long-mode)
    (use-package vlf
      :disabled t ;; merged into vlf, try built-in so-long instead
      :straight (:host github :repo "m00natic/vlfi")
      :custom (vlf-application 'dont-ask)
      :config (require 'vlf-setup)))
#+end_src

* Yankpad
#+begin_src emacs-lisp :results output silent
  (use-package yankpad
    :disabled t
    :straight (:host github :repo "Kungsgeten/yankpad")
    :commands (yankpad-expand
               yankpad-edit
               yankpad-reload)
    :init
    (add-to-list 'hippie-expand-try-functions-list #'yankpad-expand)
    :custom
    (yankpad-file (locate-user-emacs-file "snippets.org")))
#+end_src

* Smart tab
#+begin_src emacs-lisp :results output silent
  (use-package smart-tab
    :disabled t
    :straight (:host github :repo "genehack/smart-tab")
    :custom
    (smart-tab-using-hippie-expand t)
    :config
    (global-smart-tab-mode))
#+end_src

* Batch/CMD
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'org-src
    (cl-pushnew '("cmd" . bat) org-src-lang-modes)
    (cl-pushnew '("batch" . bat) org-src-lang-modes))
#+end_src

* Python
#+begin_src emacs-lisp :results output silent
  (org-babel-do-load-languages 'org-babel-load-languages
                               (add-to-list 'org-babel-load-languages '(python . t)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (setq-default python-indent-offset 4)

  (general-define-key
   :keymaps 'python-mode-map
   :states 'insert
   "RET" 'comment-indent-new-line)
#+end_src

** Virtual Environment
#+begin_src emacs-lisp :results output silent
  (use-package pyvenv
    :straight (:host github :repo "jorgenschaefer/pyvenv")
    :commands (pyvenv-activate
               pyvenv-workon))
#+end_src

* Powershell
#+begin_src emacs-lisp :results output silent
  (use-package powershell.el
    :straight (:host github :repo "jschaf/powershell.el")
    :commands (powershell-mode powershell)
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("powershell" . powershell) org-src-lang-modes)
      (cl-pushnew '("ps" . powershell) org-src-lang-modes))
    :config
    (defun org-babel-execute:powershell (body _params)
      (let ((explicit-shell-file-name powershell-location-of-exe))
        (shell-command-to-string body))))
#+end_src

* Access todo.org from evil command
#+begin_src emacs-lisp :results output silent
  ;; (evil-define-command my-todo (&optional arg)
  ;;   (interactive "<!>")
  ;;   (when (boundp 'my-todo-org-file)
  ;;     (if arg
  ;;         (org-capture nil "todo")
  ;;       (find-file my-todo-org-file))))
#+end_src

#+begin_src emacs-lisp :results output silent
  ;; (when (boundp 'my-todo-org-file)
  ;;   (my-evil-define-split-vsplit-cmd "todo" #'(lambda () (find-file my-todo-org-file)))
  ;;   ;; (evil-ex-define-cmd "todo" 'my-todo)
  ;;   ;; (evil-ex-define-cmd "Stodo" #'(lambda () (interactive)
  ;;   ;;                                (call-interactively 'evil-window-split)
  ;;   ;;                                (find-file my-todo-org-file)))
  ;;   ;; (evil-ex-define-cmd "Vtodo" #'(lambda () (interactive)
  ;;   ;;                                (call-interactively 'evil-window-vsplit)
  ;;   ;;                                (find-file my-todo-org-file)))
  ;;   (evil-ex-define-cmd "Ttodo" #'(lambda () (interactive)
  ;;                                  (my-new-cmd-tab my-todo-org-file))))
#+end_src

#+begin_src emacs-lisp :results output silent
  ;; (when (boundp 'my-notes-org-file)
  ;;   (my-evil-define-split-vsplit-cmd "note[s]" #'(lambda () (find-file my-notes-org-file)))
  ;;   ;; (evil-ex-define-cmd "notes" 'my-notes)
  ;;   ;; (evil-ex-define-cmd "Snotes" #'(lambda () (interactive)
  ;;   ;;                                (call-interactively 'evil-window-split)
  ;;   ;;                                (find-file my-notes-org-file)))
  ;;   ;; (evil-ex-define-cmd "Vnotes" #'(lambda () (interactive)
  ;;   ;;                                (call-interactively 'evil-window-vsplit)
  ;;   ;;                                (find-file my-notes-org-file)))
  ;;   (evil-ex-define-cmd "Tnotes" #'(lambda () (interactive)
  ;;                                   (funcall-interactively
  ;;                                    'my-new-evil-tab my-notes-org-file))))
#+end_src


* Yaml-mode
#+begin_src emacs-lisp :results output silent
  (use-package yaml-mode
    ;; :straight (:host github :repo "yoshiki/yaml-mode")
    :straight t
    :mode ("\\.yml\\'"
           "\\.yaml\\'")
    :hook
    (yaml-mode-hook . prism-whitespace-mode)
    (yaml-mode-hook . display-line-numbers-mode)
    :general
    (yaml-mode-map
     "RET" 'newline-and-indent)
    :commands (yaml-mode)
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("yaml" . yaml) org-src-lang-modes)))
#+end_src

* Journal (Org Journal)
#+begin_src emacs-lisp :results output silent
  (use-package org-journal
    :disabled t ;; we use org-roam now
    :straight (:host github :repo "bastibe/org-journal")
    ;; disabling until https://github.com/bastibe/org-journal/issues/317 is resolved
    :disabled t
    :if (boundp 'config-local-syncthing-folder)
    :commands org-journal-new-entry
    :custom
    (org-journal-time-format "%R ")
    (org-journal-date-format "%F, %A")
    (org-journal-file-type 'daily)
    (org-journal-file-format "%Y-%m-%d.org"
                             "Lets follow the ISO standard")
    :init
    (evil-ex-define-cmd "journal" #'(lambda () (interactive)
                                      (org-journal-new-entry t)))
    (evil-ex-define-cmd "jj" 'org-journal-new-entry)
    (customize-set-variable 'org-journal-dir
                            (f-join config-local-syncthing-folder
                                    "day"))
    :hook
    ((org-journal-after-entry-create-hook . evil-insert-state)
     (org-journal-mode-hook . aggressive-fill-paragraph-mode))
    :config
    (with-eval-after-load 'org-capture
      (defun my-org-journal-find-location ()
        (org-journal-new-entry t)
        (goto-char (point-min)))
      (add-to-list 'org-capture-templates
                   '("jj" "Personal Journal Entry" entry
                     (function my-org-journal-find-location)
                     "* %(format-time-string org-journal-time-format)%?"))))
#+end_src

* Cmake
#+begin_src emacs-lisp :results output silent
  (use-package cmake-mode
    :straight t
    :mode ("\\cmakelists.txt\\'" . cmake-mode)
    ;; :ensure t ;; the package is nested in the greater cmake repo, and
    ;;           ;; not practical to use straight on (yet)
    :hook (cmake-mode-hook . hl-todo-mode))
#+end_src

** Cmake-font-lock
#+begin_src emacs-lisp :results output silent
  (use-package cmake-font-lock
    ;; :straight (:host github :repo "Lindydancer/cmake-font-lock")
    :straight t
    :hook (cmake-mode-hook . cmake-font-lock-activate))
#+end_src

* TOML mode for org-src
#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'org-src
    (cl-pushnew '("toml" . conf-toml) org-src-lang-modes))
#+end_src

* Jira
#+begin_src emacs-lisp :results output silent
  (use-package org-jira
    :defer t
    ;; :straight (:host github :repo "baohaojun/org-jira"))
    :straight t)
#+end_src

* Jupyter Notebook
https://millejoh.github.io/emacs-ipython-notebook/

#+begin_src emacs-lisp :results output silent
  (use-package ein
    :disabled t
    :straight (:host github :repo "millejoh/emacs-ipython-notebook"))
#+end_src

* Focus mode
#+begin_src emacs-lisp :results output silent
  (use-package focus
    ;; :straight (:host github :repo "larstvei/Focus")
    :straight t
    :commands focus-mode
    :init
    (evil-ex-define-cmd "fo[cus]" 'focus-mode))
#+end_src

* Pretty mode
#+begin_src emacs-lisp :results output silent
  (use-package pretty-mode
    ;; :straight (:host github :repo "pretty-mode/pretty-mode")
    :straight t
    :defer t
    :commands (pretty-mode))
    ;; :config
    ;; (global-pretty-mode)
    ;; (global-prettify-symbols-mode))
#+end_src

* Prettify Symbols Mode
Use this instead of pretty mode because it's built in and shouldn't
spaz out as much

#+begin_src emacs-lisp :results output silent
  (global-prettify-symbols-mode)
#+end_src

* Outshine
Doesn't really work out of the box. Interesting idea though, so we're
keeping it until we figure out how to use it properly

#+begin_src emacs-lisp :results output silent
  (use-package outshine
    ;; :straight (:host github :repo "alphapapa/outshine")
    :straight t
    :commands (outshine-mode))
#+end_src

* Org Kanban
This uses a custom org block, so we don't actually have to do anything
more than spell out that block and evaluate it.

#+begin_example
#+BEGIN: kanban :mirrored nil
#+END:
#+end_example

#+begin_src emacs-lisp :results output silent
  (use-package org-kanban
    ;; :straight (:host github :repo "gizmomogwai/org-kanban")
    :straight t
    :defer 10)
#+end_src

* Bookmark+
This is now really expensive, and we need to trim this as much as we
can.

- [ ] Iterate through the list and lazy load the thing instead of
  making it so expensive

#+begin_src emacs-lisp :results output silent
  (use-package bookmark+
    :disabled t
    :preface
    (let ((bookmarkplus-dir (locate-user-emacs-file "local-packages/bookmark-plus/"))
          (emacswiki-base "https://www.emacswiki.org/emacs/download/")
          (bookmark-files '("bookmark+.el" "bookmark+-mac.el" "bookmark+-bmu.el"
                            "bookmark+-key.el" "bookmark+-lit.el" "bookmark+-1.el")))
      (require 'url)
      (add-to-list 'load-path bookmarkplus-dir)
      (make-directory bookmarkplus-dir t)
      (mapcar (lambda (arg)
                (let ((local-file (concat bookmarkplus-dir arg)))
                  (unless (file-exists-p local-file)
                    (url-copy-file (concat emacswiki-base arg) local-file t))))
              bookmark-files)
      (byte-recompile-directory bookmarkplus-dir 0))
    :commands bmkp-bmenu-list)
#+end_src

* Copy as Format
The only reason I'm keeping this and not discarding it is because it's currently
- A monument to my hubris
- Actually a pretty cool attempt at hacking elisp

#+begin_src emacs-lisp :results output silent
  (use-package copy-as-format
    :disabled t
    :straight (:host github :repo "sshaw/copy-as-format")
    :commands (copy-as-format))
   ;;  :init
   ;;  (evil-define-operator as-format (beg end &optional format-specifier)
   ;;    :repeat nil
   ;;    :move-point nil
   ;;    (interactive "<r>")
   ;;    (let ((temp-buffer (generate-new-buffer "copy-as-format-temp")))
   ;;      (copy-to-buffer temp-buffer beg end)
   ;;      (with-current-buffer temp-buffer
   ;;        (mark-whole-buffer)
   ;;        (copy-as-format))))
   ;; (evil-ex-define-cmd "copy-as-format" 'as-format))
#+end_src

* Studlify operator
#+begin_src emacs-lisp :results output silent
  (evil-define-operator evil-studlify (beg end)
    (studlify-region beg end))
#+end_src

#+begin_src emacs-lisp :results output silent
  (general-define-key :keymaps '(normal visual)
    "g S" 'evil-studlify)
#+end_src

Or evil-spongebob if you want to think of it that way.

* Go Mode                                                             :major:
#+begin_src emacs-lisp :results output silent
  (use-package go-mode
    ;; :straight (:host github :repo "dominikh/go-mode.el")
    :straight t
    :mode ("\\.go\\'" . go-mode)
    :hook
    (go-mode-hook . gofmt-before-save)
    :general
    (:keymaps 'go-mode-map
     :state 'normal
     "C-c C-f C-f" 'gofmt))
#+end_src

* Elfeed
#+begin_src emacs-lisp :results output silent
  (defconst user-rss-feed-file
    (locate-user-emacs-file "feeds.org")
    "Points to config.org")

  (defun find-user-rss-feed-file ()
    "Edit `user-rss-feed-file' without opening a new window."
    (interactive)
    (find-file user-rss-feed-file))

  (evil-ex-define-cmd "feed[s]" 'find-user-rss-feed-file)
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package elfeed
    :disabled t ;; for now
    :straight (:host github :repo "skeeto/elfeed")
    :if (f-exists? user-rss-feed-file)
    :commands (elfeed)
    :custom
    (elfeed-search-title-max-width
     80
     "Update the max width of the title")
    (elfeed-search-filter
     "@1-day-ago +unread +interesting "
     "The trailing space is so that adding additional tags to filter
     won't be painful.")
    (elfeed-search-date-format
     (list "%F %R" 16 :left)
     "Make the timestamps more useful")
    :general
    (elfeed-show-mode-map
     :states '(normal motion)
     "g O" (lambda ()
             (interactive)
             (let ((browse-url-browser-function 'eww-browse-url))
               (elfeed-show-visit t)))
     "f" 'link-hint-open-link
     "y" 'link-hint-copy-link
     "SPC"   nil
     "<SPC>" nil)
    (elfeed-search-mode-map
     :states '(normal motion)
     "g x"  'elfeed-search-browse-url ;; "g o" also does this in normal mode
     "g r"  'elfeed-search-fetch-visible
     "SPC"   nil
     "<SPC>" nil)
    ;; :hook (elfeed-show-mode-hook . (lambda () (setq-local truncate-lines nil)))
    :init
    (evil-define-command my-custom-elfeed (cmd)
      (interactive "<a>")
      (cond
       ((string= cmd "feeds") (find-user-rss-feed-file))
       ((string= cmd "feed") (find-user-rss-feed-file))
       ((string= cmd "reload") (reload-rss-feed-file))
       ;; ((string= cmd "log") (switch-to-buffer (elfeed-log-buffer)))
       (t (elfeed))))
    (evil-ex-define-cmd "el[feed]" 'my-custom-elfeed)
    :config
    ;; https://mac.into.sh/elfeed/
    (if (not (boundp 'my-syncthing-default-folder))
        (message "Unable to find `my-syncthing-default-folder',
        defaulting to local elfeed db")
      (customize-set-variable 'elfeed-db-directory
                              (f-join my-syncthing-default-folder "elfeed"))
      (elfeed-db-load)
      ;; TODO: trace if this hook... actually exists
      ;; (add-hook 'elfeed-show-mode-hook #'(lambda () (elfeed-search-update 1)))
      (add-hook 'kill-emacs-hook #'elfeed-db-save-safe)))
#+end_src

** Elfeed org
This is really really slow
#+begin_src emacs-lisp :results output silent
  (use-package elfeed-org
    :disabled t ;; for now
    :straight (:host github :repo "remyhonig/elfeed-org")
    :if (f-exists? user-rss-feed-file)
    :after elfeed
    :commands (elfeed-org
               rmh-elfeed-org-process)
    :custom
    (rmh-elfeed-org-files (list (locate-user-emacs-file "feeds.org")))
    :init
    ;; We do it like this because we need this lazy loaded, but called
    ;; *before* `elfeed' is called
    (with-eval-after-load 'elfeed
      (elfeed-org))
    :init
    (defun reload-rss-feed-file ()
      (interactive)
      (rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id)))
#+end_src

** Elfeed goodies
#+begin_src emacs-lisp :results output silent
  ;; (use-package elfeed-goodies
  ;;   :straight (:host github :repo "algernon/elfeed-goodies")
  ;;   :after elfeed
  ;;   :general
  ;;   (elfeed-show-mode-map
  ;;    :states 'normal
  ;;    "f" 'elfeed-goodies/show-ace-link
  ;;    "F" 'elfeed-goodies/show-ace-link)
  ;;   :custom
  ;;   (elfeed-goodies/entry-pane-position 'bottom))
  ;; ;; :config
  ;; ;; (elfeed-goodies/setup)
  ;; ;; (remove-hook 'elfeed-new-entry-hook #'elfeed-goodies/html-decode-title))
#+end_src

** Elfeed Score
#+begin_src emacs-lisp :results output silent
  (use-package elfeed-score
    :straight t
    :after elfeed
    :config (elfeed-score-enable))
#+end_src

** Elfeed Dashboard
#+begin_src emacs-lisp :results output silent
  (use-package elfeed-dashboard
    :after elfeed
    :straight t)
#+end_src

* Info mode
#+begin_src emacs-lisp :results output silent
  ;; (general-define-key
  ;;  :keymaps 'Info-mode-map
  ;;   "f" 'ace-link-info
  ;;   "F" 'ace-link-info)
  (general-define-key
   :keymaps 'Info-mode-map
   :states 'normal
   "f" 'link-hint-open-link
   "]]" 'Info-next
   "[[" 'Info-prev)
#+end_src

* Eww
#+begin_src emacs-lisp :results output silent
  ;; TODO: fix `eww-form-submit' face
  (use-package eww
    :commands (eww)
    :general
    (:keymaps 'eww-mode-map
     :states '(normal)
     "f" 'ace-link-eww
     "F" 'ace-link-eww
     "g t" nil)
    :init
    (evil-define-command --eww-ex-command (beg end _type)
      (interactive "<v>")
      (require 'eww)
      (if-let ((url (buffer-substring beg end)))
          (eww url)
        (eww)))
    (evil-ex-define-cmd "eww" '--eww-ex-command)
    :config
    (unless (display-graphic-p)
      (customize-set-variable 'browse-url-browser-function 'eww-browse-url)))
#+end_src
* Hl Block Mode
Wait a bit for the code to mature.

#+begin_src emacs-lisp :results output silent
  (use-package hl-block-mode
    :disabled t
    :straight (:host github :repo "ideasman42/emacs-hl-block-mode"))
#+end_src

* Alert
with =org-pomodoro= playing sounds now (pleasant ones), using the fringe
now becomes too noisy.

#+begin_src emacs-lisp :results output silent
  (use-package alert
    ;; :straight (:host github :repo "jwiegley/alert" :flavor melpa)
    :straight t
    :commands alert)
  ;; :custom
  ;; (alert-default-style 'fringe))
#+end_src

** Windows Alert Toast
#+begin_src emacs-lisp :results output silent
  (use-package alert-toast
    :straight (:host github :repo "gkowzan/alert-toast")
    :if (eq system-type 'windows-nt)
    :after alert)
#+end_src

* Sound-wav
=sound-wav= is used for =org-pomodoro=.

#+begin_src emacs-lisp :results output silent
  (use-package sound-wav
    ;; :straight (:host github :repo "syohex/emacs-sound-wav")
    :straight t
    :commands sound-wav-play)
#+end_src

* ctags
#+begin_src emacs-lisp :results output silent
  (use-package ctags-update
    :straight (:host github :repo "jixiuf/ctags-update")
    :disabled t
    :hook
    (prog-mode-hook . turn-on-ctags-auto-update-mode)
    :commands (ctags-global-update-mode
               ctags-update
               turn-on-ctags-auto-update-mode))
#+end_src

* Seml-mode
#+begin_src emacs-lisp :results output silent
  (use-package seml-mode
    :defer 20
    ;; :straight (:host github :repo "conao3/seml-mode.el"))
    :straight t)
#+end_src

* Annotations
Might be better done as an ex mode command or something.

This is a very finnicky package

#+begin_src emacs-lisp :results output silent
  (use-package annotate
    :disabled t
    ;; :straight (:host github :repo "bastibe/annotate.el")
    :straight t
    :commands (annotate-save-annotations)
    :custom-face
    (annotate-highlight ((t (:box (:line-width -1)))))
    :custom
    (annotate-summary-ask-query nil)
    (annotate-annotation-position-policy :by-length)
    (annotate-use-echo-area nil)
    :hook
    (after-save-hook . annotate-save-annotations)
    :general
    (:states '(normal visual)
     :prefix my-default-evil-leader-key
                                          ;; "r" for "remember"
     "r r" 'annotate-annotate
     "r m" 'annotate-mode
     "r s" 'annotate-show-annotation-summary)
    (:states '(normal)
     "[ r" 'annotate-goto-previous-annotation
     "] r" 'annotate-goto-next-annotation))
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package annot
    :disabled t ;; trying out annotate.el instead
    :straight (:host github :repo "ghoshi/annot"
               :files (:defaults "src/annot.el"))
    :general
    (:keymaps '(normal visual)
     :prefix my-default-evil-leader-key
     "//" 'annot-edit/add
     "/d" 'annot-remove)
    (:keymaps 'normal
     :prefix my-default-evil-leader-key
     "/n" 'annot-goto-next
     "/N" 'annot-goto-previous
     "/c" 'annot-to-comment))
#+end_src

* Company
#+begin_src emacs-lisp :results output silent
  (use-package company-mode
    ;; :straight (:host github :repo "company-mode/company-mode")
    :straight t
    :disabled t
    :commands (company-mode-on
               company-mode)
    :custom
    (company-idle-delay 0)
    (company-tooltip-align-annotations t)
    :general
    (company-active-map
     ;; "RET" 'company-complete-selection
     "C-w" nil) ;; don't override vim controls
    (company-active-map
     :states 'insert
     "RET" 'company-complete-selection)
    ;; :custom
    ;; (company-idle-delay 2)
    :hook
    (prog-mode-hook . company-mode)
    :init
    ;; stolen from https://stackoverflow.com/questions/2087225/about-the-fix-for-the-interference-between-company-mode-and-yasnippet
    (with-eval-after-load 'yasnippet
      (defun --company-yasnippet-or-completion ()
        (interactive)
        (let ((yas-fallback-behavior nil))
          (unless (yas-expand)
            (call-interactively #'company-complete-common))))
      (add-hook 'company-mode-hook
                #'(lambda ()
                    (substitute-key-definition
                     'company-complete-common
                     '--company-yasnippet-or-completion
                     company-active-map)))))
#+end_src

** Company Prescient
#+begin_src emacs-lisp :results output silent
  (use-package company-prescient
    :straight t
    :disabled t
    :after company
    :config
    (company-prescient-mode))
#+end_src
** Company Quickhelp
#+begin_src emacs-lisp :results output silent
  (use-package company-quickhelp
    :straight t
    :disabled t
    :after company-mode
    :config
    (company-quickhelp-mode))
#+end_src

** Statistics
#+begin_src emacs-lisp :results output silent
  (use-package company-statistics
    :straight t
    :disabled t
    :after company-mode
    :config
    (company-statistics-mode))
#+end_src

** Company-math
Doesn't seem to be working?
#+begin_src emacs-lisp :results output silent
  (use-package company-math
    :straight t
    :disabled t
    :after company-mode
    :config
    (add-to-list 'company-backends 'company-math-symbols-latex)
    (add-to-list 'company-backends 'company-math-symbols-unicode)
    (add-to-list 'company-backends 'company-latex-commands))
#+end_src

* Flycheck
#+begin_src emacs-lisp :results output silent
  (use-package flycheck
    :straight (:host github :repo "flycheck/flycheck")
    :custom
    (flycheck-indication-mode 'left-margin)
    :custom-face
    (flycheck-error ((t (:underline (:color ,sol-red :style line)))))
    (flycheck-delimited-error ((t (:inherit flycheck-error))))
    (flycheck-info ((t (:underline (:color ,sol-blue :style line)))))
    (flycheck-warning ((t (:underline (:color ,sol-yellow :style line)))))
    (flycheck-fringe-error ((((background light)) (:background ,sol-base3 :foreground ,sol-red))
                            (((background dark)) (:background ,sol-base03 :foreground ,sol-red))))
    (flycheck-fringe-info ((((background light)) (:background ,sol-base3 :foreground ,sol-blue))
                           (((background dark)) (:background ,sol-base03 :foreground ,sol-blue))))
    (flycheck-fringe-warning ((((background light)) (:background ,sol-base3 :foreground ,sol-yellow))
                              (((background dark)) (:background ,sol-base03 :foreground ,sol-yellow))))
    :hook
    (prog-mode-hook . global-flycheck-mode))
#+end_src

** Flycheck Inline
#+begin_src emacs-lisp :results output silent
  (use-package flycheck-inline
    :straight t
    :disabled t ;; it's annoying on small screens
    :hook
    (flycheck-mode-hook . flycheck-inline-mode))
#+end_src

* Language Server Protocol (LSP)

** eglot
#+begin_src emacs-lisp :results output silent
  (use-package eglot
    :straight (:host github :repo "joaotavora/eglot")
    :commands (eglot eglot-ensure)
    :general
    (eglot-mode-map
     :states '(normal visual)
     "K" nil
     "M-K" 'eldoc-doc-buffer))
    ;; :hook
    ;; ((c-mode-hook . eglot-ensure)
    ;;  (c++-mode-hook . eglot-ensure)))
#+end_src

** lsp-mode
#+begin_src emacs-lisp :results output silent
  (use-package lsp-mode
    :straight t
    :commands (lsp lsp-deferred)
    :custom
    (lsp-headerline-breadcrumb-enable t)
    (lsp-file-watch-threshold 1500)
    (lsp-enable-file-watchers nil)
    :config
    ;; this is necessary since `lsp-command-map' is not autoloadable
    (general-define-key
     :states 'normal
     :prefix my-default-evil-leader-key
     "l" lsp-command-map))
        ;; (lsp-mode-map
        ;;  :states 'normal
        ;;  :prefix my-default-evil-leader-key
        ;;   "l a a" 'lsp-execute-code-action))
#+end_src

Adding emojis into lsp-checked buffers causes it to explode, because
of [[https://github.com/emacs-lsp/lsp-mode/issues/2080]]. The following
snippet is a patch provided in the thread.

#+begin_src emacs-lisp :results output silent
  (with-eval-after-load 'lsp-mode
    (defun lsp--column (&optional lbp)
      "Calculate current COLUMN as defined by the LSP spec. LBP defaults to `line-beginning-position'."
      (/ (- (length (encode-coding-region (or lbp (line-beginning-position))
                                          (point) 'utf-16 t))
            2)
         2))
   (defun lsp--move-to-character (character)
     "Move to CHARACTER abiding by the LSP spec."
     (save-restriction
       (cl-loop
        with lbp = (line-beginning-position)
        initially
        (narrow-to-region lbp (line-end-position))
        (move-to-column character)
        for diff = (- character
                      (lsp--column lbp))
        until (zerop diff)
        do (condition-case eob-err
               (forward-char (/ (if (> diff 0) (1+ diff) (1- diff)) 2))
             (end-of-buffer (cl-return eob-err))))
       (point)))

   (define-advice lsp--line-character-to-point (:override (line character) utf8-hack)
       "Return the point for character CHARACTER on line LINE."
       (or (lsp-virtual-buffer-call :line/character->point line character)
           (let ((inhibit-field-text-motion t))
             (lsp-save-restriction-and-excursion
              (goto-char (point-min))
              (forward-line line)
              (lsp--move-to-character character)))))
   (define-advice lsp--cur-position (:override () utf8-hack)
      "Make a Position object for the current point."
      (or (lsp-virtual-buffer-call :cur-position)
          (lsp-save-restriction-and-excursion
           (list :line (lsp--cur-line)
                 :character (lsp--column))))))
#+end_src

*** Debug Adapter Mode (dap-mode)
#+begin_src emacs-lisp :results output silent
  (use-package dap-mode
    :after lsp-mode
    :straight t
    :commands (dap-debug)
    :hook
    (dap-stopped-hook . (lambda (arg)
                          (call-interactively #'dap-hydra))))
#+end_src

* Code Folding (Origami)
#+begin_src emacs-lisp :results output silent
  (use-package origami
    :straight (:host github :repo "gregsexton/origami.el")
    :after evil
    :defer 2
    :general
    (:states 'normal
     "zm" 'origami-close-all-nodes
     "zr" 'origami-open-all-nodes
     "zc" 'origami-close-node
     "zC" 'origami-close-node-recursively
     "zo" 'origami-open-node
     "zO" 'origami-open-node-recursively
     "za" 'origami-recursively-toggle-node
     "zj" 'origami-forward-fold
     "zk" #'(lambda () (interactive)
              (call-interactively 'origami-previous-fold)
              (call-interactively 'origami-next-fold))
     "[z" 'origami-previous-fold
     "]z" 'origami-next-fold)
    :hook
    (prog-mode-hook . origami-mode)
    :config
    (global-origami-mode))
#+end_src

* Rot13
Note that while the buffer will look rot13 encrypted, the final saved
file will not itself be encrypted.

#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "rot[13]" 'toggle-rot13-mode)
#+end_src

* PlantUML mode
[[http://plantuml.com/index][Reference]]

#+begin_src emacs-lisp :results output silent
  (use-package plantuml-mode
    :straight (:host github :repo "skuro/plantuml-mode")
    :commands (plantuml-mode)
    :custom
    (plantuml-output-type "txt"
                          "Display using glorious text")
    (plantuml-default-exec-mode 'executable)
    :mode "\\.plantuml\\'"
    :init
    (with-eval-after-load 'org-src
      (cl-pushnew '("plantuml" . plantuml) org-src-lang-modes)))
#+end_src

#+begin_src emacs-lisp :results output silent
  (customize-set-value 'org-plantuml-exec-mode 'plantuml)
  (org-babel-do-load-languages 'org-babel-load-languages
                               (add-to-list 'org-babel-load-languages '(plantuml . t)))
#+end_src
* Hex conversion
#+begin_src emacs-lisp :results output silent
  (use-package 0xc
    :straight (:host github :repo "AdamNiederer/0xc")
    :commands (0xc-convert
               0xc-convert-point))
#+end_src

* Edn format
This is closer to the json serialization/deserialization module.

#+begin_src emacs-lisp :results output silent
  (use-package edn
    :straight (:host github :repo "expez/edn.el")
    :commands (edn-read
               edn-print-string))
#+end_src

* Novel reading
#+begin_src emacs-lisp :results output silent
  (use-package nov
    :straight (:host github :repo "wasamasa/nov.el")
    :mode ("\\.epub\\'" . nov-mode))
#+end_src
* Glasses-mode
Converts between camelCase and snake_case visually, without changing
the underlying format
* Hexl-mode

* todotxt
#+begin_src emacs-lisp :results output silent
  (use-package todotxt
    :straight t
    :commands todotxt
    :config
    (add-to-list 'evil-motion-state-modes 'todotxt-mode))
#+end_src

* COMMENT Smerge vimdiff bindings
Not using this because we're going to try ediff
#+begin_src emacs-lisp :results output silent
  (general-define-key
   :states '(normal motion)
   :keymaps 'smerge-mode-map
    "dp" 'smerge-keep-lower
    "do" 'smerge-keep-upper
    "[c" 'smerge-next
    "]c" 'smerge-prev)
#+end_src

* Search Engine Mode
#+begin_src emacs-lisp :results output silent
  (use-package engine-mode
    ;; :straight (:host github :repo "hrs/engine-mode" :branch "main")
    :straight t
    :commands defengine
    :init
    (evil-define-command --ddg-search (beg end _type)
      (interactive "<v>")
      (require 'engine-mode)
      (unless (boundp 'engine/search-duckduckgo)
        (defengine duckduckgo
          "https://duckduckgo.com/?q=%s"))
      (let* ((query-region (when (use-region-p)
                             (buffer-substring beg end)))
             (query-params (when (evil-ex-p)
                             evil-ex-argument))
             (query-args (list query-params query-region))
             (query (if (-none-p 'identity query-args)
                        (read-string "Search: " nil nil
                                     (thing-at-point 'word))
                      (s-join " " query-args))))
        (engine/search-duckduckgo query)))
    (evil-ex-define-cmd "ddg" '--ddg-search)
    :general
    (:states '(normal motion visual)
     "K" '--ddg-search))
#+end_src

* Lorem Ipsum
#+begin_src emacs-lisp :results output silent
  (use-package lorem-ipsum
    :straight t
    :commands
    (lorem-ipsum-insert-paragraphs
     lorem-ipsum-insert-sentences
     lorem-ipsum-insert-list)
    :init
    ;; stolen from
    ;; https://github.com/alphapapa/unpackaged.el#obfuscate-buffer-text-with-lorem-ipsum-words
    ;; and slightly modified to accomodate textobjects
    ;;;###autoload
    (evil-define-command loremify (beg end)
      "Overlay all text in current buffer with \"lorem ipsum\" text.
      When called again, remove overlays.  Useful for taking
      screenshots without revealing buffer contents."
      (interactive "<r>")
      (require 'lorem-ipsum)
      (let* ((min (if beg beg (point-min)))
             (max (if end end (point-max)))
             (ovs (overlays-in min max)))
        (if (cl-loop for ov in ovs
                     thereis (overlay-get ov :lorem-ipsum-overlay))
            ;; Remove overlays.
            (dolist (ov ovs)
              (when (overlay-get ov :lorem-ipsum-overlay)
                (delete-overlay ov)))
          ;; Add overlays.
          (let ((lorem-ipsum-words (--> lorem-ipsum-text
                                        -flatten (apply #'concat it)
                                        (split-string it (rx (or space punct)) 'omit-nulls)))
                (case-fold-search nil))
            (cl-labels ((overlay-match ()
                                       (let* ((beg (match-beginning 0))
                                              (end (match-end 0))
                                              (replacement-word (lorem-word (match-string 0)))
                                              (ov (make-overlay beg end)))
                                         (when replacement-word
                                           (overlay-put ov :lorem-ipsum-overlay t)
                                           (overlay-put ov 'display replacement-word))))
                        (lorem-word (word)
                                    (let* ((length (length word)))
                                      (cl-loop for liw in lorem-ipsum-words
                                               when (= length (length liw))
                                               collect liw into matches
                                               finally return
                                               (when matches
                                                 (apply-case word (downcase (seq-random-elt matches)))))))
                        (apply-case (source target)
                                    (cl-loop for sc across-ref source
                                             for tc across-ref target
                                             when (not (string-match-p (rx lower) (char-to-string sc)))
                                             do (setf tc (string-to-char (upcase (char-to-string tc)))))
                                    target))
              (save-excursion
                (goto-char min)
                (while (re-search-forward (rx (1+ alpha)) max t)
                  (overlay-match)))))))))
#+end_src

* Pomodoro
** Pomidor
#+begin_src emacs-lisp :results output silent
  (use-package pomidor
    :straight (:host github :repo "TatriX/pomidor")
    :commands pomidor
    :general
    (pomidor-mode-map
     :states '(visual normal motion)
      "RET" 'pomidor-stop
      "SPC" 'pomidor-break)
    :custom-face
    (pomidor-break-face ((t (:inherit 'font-lock-function-name-face))))
    :custom
    (pomidor-sound-tick nil)
    (pomidor-sound-tack nil)
    (pomidor-sound-overwork
     (expand-file-name (locate-user-emacs-file "notification1.wav")))
    (pomidor-sound-break-over
     (expand-file-name (locate-user-emacs-file "notification2.wav")))
    :init
    (evil-ex-define-cmd "pomo[doro]" 'pomidor))
#+end_src

** Org pomodoro
:LOGBOOK:
CLOCK: [2019-05-06 Mon 14:02]--[2019-05-06 Mon 14:27] =>  0:25
:END:

=mode-line-misc-info= is where the pomodoro is placed.

It is behind =mode-line-modes= and if we want the pomodoro to be
infront, we need to alter it there

I think we should put =mode-line-format= just behind =evil-mode-line-tag=,
or (vc-mode)

We can use the following to insert =org-pomodoro-mode-line= at
whereever we like on the modeline.

The string seems to be inserted into the modeline once, and then set
to an empty string when not in use (it so appears anyway).

We can override the insertion checks everytime =org-pomodoro-start= is
called, and it should work anywhere.

# #+begin_src emacs-lisp :eval no-export
#   (-insert-at
#     (-find-index (lambda (sym)
#                    (eq sym 'evil-mode-line-tag))
#                  mode-line-format)
#     'org-pomodoro-mode-line mode-line-format)
# #+end_src

#+begin_src emacs-lisp :results output silent
  (use-package org-pomodoro
    :disabled t ;; Not using this
    :straight (:host github :repo "lolownia/org-pomodoro"
               :files (:defaults ("resources/" "resources/*")))
    :commands (org-pomodoro)
    :custom
    (org-pomodoro-manual-break t)
    ;; guild wars 2 has some excellent notification sounds
    ;; For some reason they need an absolute path
    (org-pomodoro-overtime-sound
     (expand-file-name (locate-user-emacs-file "notification1.wav")))
    (org-pomodoro-short-break-sound
     (expand-file-name (locate-user-emacs-file "notification2.wav")))
    (org-pomodoro-long-break-sound
     (expand-file-name (locate-user-emacs-file "notification3.wav")))
    (org-pomodoro-finished-sound nil)
    :init
    (evil-define-command my-pomodoro-start (&optional arg)
      "Starts a pomodoro with the current headline, or the last pomodoro
  if ! is provided."
      (interactive "<!>")
      (let ((prev_clock (when arg '(16))))
        (org-pomodoro prev_clock)))
    (evil-ex-define-cmd "do" 'my-pomodoro-start)
    (evil-ex-define-cmd "done"
                        #'(lambda () (interactive)
                            (require 'org-pomodoro)
                            (cond
                             ((equal org-pomodoro-state :overtime)
                              (org-pomodoro))
                             ((org-pomodoro-active-p)
                              (org-pomodoro-kill)))))
    :config
    (customize-set-variable
     'mode-line-format
     (list "%e" mode-line-front-space mode-line-mule-info
           mode-line-client mode-line-modified mode-line-auto-compile
           mode-line-remote mode-line-frame-identification
           mode-line-buffer-identification " " mode-line-position
           evil-mode-line-tag mode-line-misc-info '(vc-mode vc-mode) " "
           mode-line-modes mode-line-end-spaces)))
  ;; :config
  ;;   (advice-add 'org-pomodoro-start
  ;;               :after
  ;;               #'(lambda (&rest _)
  ;;                   "Attempt to make the modeline come first, instead of
  ;; behind the minor modes"
  ;;                   (when (and global-mode-string
  ;;                              (memq 'org-pomodoro-mode-line
  ;;                                    global-mode-string))
  ;;                     (delq 'org-pomodoro-mode-line global-mode-string)
  ;;                     (setq global-mode-string
  ;;                           (append '(org-pomodoro-mode-line)
  ;;                                   global-mode-string)))))
#+end_src


Note that =customize-set-variable= is like =setq-default=.
* Smooth Scrolling
#+begin_src emacs-lisp :results output silent
  (use-package smooth-scrolling
    :straight (:host github :repo "aspiers/smooth-scrolling")
    :commands smooth-scrolling-mode)
#+end_src

* Link hinting
#+begin_src emacs-lisp :results output silent
  (use-package link-hint
    :straight t
    :commands (link-hint-open-link
               link-hint-copy-link))
#+end_src

* Highlight Indent Guides
#+begin_src emacs-lisp :results output silent
  (use-package highlight-indent-guides
    :straight t
    :commands (highlight-indent-guides-mode)
    :custom
    (highlight-indent-guides-method 'character)
    (highlight-indent-guides-character ?\|)
    :general
    (:states 'normal
     :prefix my-default-evil-leader-key
     "|" 'highlight-indent-guides-mode))
#+end_src

* EditorConfig
#+begin_src emacs-lisp :results output silent
  (use-package editorconfig
    :hook
    (prog-mode-hook . editorconfig-mode))
#+end_src

* Web mode
#+begin_src emacs-lisp :results output silent
  (use-package web-mode
    :straight t
    :mode (("\\.svelte\\'" . web-mode)
           ("\\.vue\\'" . web-mode))
    :custom
    ((web-mode-code-indent-offset 2)
     (web-mode-css-indent-offset 2))
    :commands web-mode)
#+end_src

* C# Mode
#+begin_src emacs-lisp :results output silent
  (use-package csharp-mode
    :straight (:host github :repo "josteink/csharp-mode")
    :commands (csharp-mode)
    :mode "\\.cs\\'")
#+end_src

* Fill Function Argument
#+begin_src emacs-lisp :results output silent
  (use-package fill-function-arguments
    :straight (:host github :repo "davidshepherd7/fill-function-arguments")
    :commands (fill-function-arguments-dwim)
    :custom (fill-function-arguments-indent-after-fill t)
    :general
    (:states 'normal
     "g *" 'fill-function-arguments-dwim))
#+end_src

* Spotify (now Smudge)
#+begin_src emacs-lisp :results output silent
  (use-package smudge
    :straight (:host github :repo "danielfm/smudge")
    :if (and (bound-and-true-p --spotify-oauth2-client-id)
             (bound-and-true-p --spotify-oauth2-client-secret))
    :custom
    (smudge-oauth2-client-id --spotify-oauth2-client-id)
    (smudge-oauth2-client-secret --spotify-oauth2-client-secret)
    :init
    (defhydra hydra-spotify (:hint nil)
      "
  ^Search^                  ^Control^               ^Manage^
  ^^^^^^^^-----------------------------------------------------------------
  _t_: Track               _SPC_: Play/Pause        _+_: Volume up
  _m_: My Playlists        _n_  : Next Track        _-_: Volume down
  _f_: Featured Playlists  _p_  : Previous Track    _x_: Mute
  _u_: User Playlists      _r_  : Repeat            _d_: Device
  ^^                       _s_  : Shuffle           _q_: Quit"
      ("t" smudge-track-search :exit t)
      ("m" smudge-my-playlists :exit t)
      ("f" smudge-featured-playlists :exit t)
      ("u" smudge-user-playlists :exit t)
      ("SPC" smudge-controller-toggle-play :exit nil)
      ("n" smudge-controller-next-track :exit nil)
      ("p" smudge-controller-previous-track :exit nil)
      ("r" smudge-controller-toggle-repeat :exit nil)
      ("s" smudge-controller-toggle-shuffle :exit nil)
      ("+" smudge-controller-volume-up :exit nil)
      ("-" smudge-controller-volume-down :exit nil)
      ("x" smudge-controller-volume-mute-unmute :exit nil)
      ("d" smudge-select-device :exit nil)
      ("q" quit-window "quit" :color blue))
    (evil-ex-define-cmd "mu[sic]" #'hydra-spotify/body))
#+end_src

* Tree Sitter
#+begin_src emacs-lisp :results output silent
  (use-package tree-sitter
    :hook ((tree-sitter-after-on-hook . tree-sitter-hl-mode))
    :custom-face
    (tree-sitter-hl-face:type.builtin ((t (:inherit 'tree-sitter-hl-face:keyword))))
    :config
    (use-package tree-sitter-langs))
#+end_src

** Text objects
#+begin_src emacs-lisp :results output silent
  (use-package evil-textobj-tree-sitter
    :straight (:host github
               :repo "meain/evil-textobj-tree-sitter"
               :files (:defaults "queries"))
    :after tree-sitter
    :general
    (evil-outer-text-objects-map
     "f" (evil-textobj-tree-sitter-get-textobj "function.outer"))
    (evil-inner-text-objects-map
     "f" (evil-textobj-tree-sitter-get-textobj "function.inner")))
#+end_src

* Scratch
Just do the scratch buffer simple and stupidly
#+begin_src emacs-lisp :results output silent
  (setq initial-scratch-message nil
        initial-major-mode 'markdown-mode)
  (my-evil-define-split-vsplit-cmd "sc[ratch]" #'(lambda () (switch-to-buffer "*scratch*")))
  (evil-ex-define-cmd "TScratch" #'(lambda ()
                                     (interactive)
                                     (if (featurep 'tab-bar)
                                      (let ((tab-bar-new-tab-choice "*scratch*"))
                                       (tab-bar-new-tab))
                                      (warn "tab-bar not available"))))
#+end_src

* Compiler Explorer
#+begin_src emacs-lisp :results output silent
  (use-package compiler-explorer
    :straight (:host github :repo "mkcms/compiler-explorer.el")
    :commands (compiler-explorer))
#+end_src

** RMSBolt
#+begin_src emacs-lisp :results output silent
  (use-package rmsbolt
    :straight t
    :commands (rmsbolt))
#+end_src

* Emacs-sourcetrail
#+begin_src emacs-lisp :results output silent
  (use-package emacs-sourcetrail
    :straight (:host github :repo "CoatiSoftware/emacs-sourcetrail")
    :init
    (defun my-sourcetrail-adjust-point ()
      "`sourcetrail-send-location' needs the point to be at the end of
  the symbol being sent. Otherwise it'll somehow link to the file
  instead."
      (interactive)
      (save-excursion
        (end-of-thing 'word)
        (sourcetrail-send-location)))
    :general
    (:states '(normal visual)
     "C-?" 'my-sourcetrail-adjust-point)
    :config
    (sourcetrail-mode))
#+end_src

* Macrostep
#+begin_src emacs-lisp :results output silent
  (use-package macrostep
    :straight t
    :commands (macrostep-expand))
#+end_src

* Buttercup (Emacs Test Framework)
#+begin_src emacs-lisp :results output silent
  (use-package buttercup
    :straight t
    :defer t) ;; uncomment when we actually need this
#+end_src

* Typit
#+begin_src emacs-lisp :results output silent
  (use-package typit
    :straight t
    :commands
    (typit-basic-test
     typit-advanced-test
     typit-test))
#+end_src

* Compilation Mode
#+begin_src emacs-lisp :results output silent
  (use-package compile
    :straight nil
    :ensure nil
    :custom
    (compilation-auto-jump-to-first-error nil)
    (compilation-ask-about-save nil)
    :general
    (compilation-mode-map
     :states 'normal
     "]]" 'compilation-next-error
     "[[" 'compilation-previous-error)
    :init
    (defun my-colorize-completion-buffer ()
      (require 'ansi-color)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region compilation-filter-start (point))))
    :hook
    ((compilation-filter-hook . my-colorize-completion-buffer)
     (compilation-mode-hook . visual-line-mode)))
#+end_src

* Project mode
#+begin_src emacs-lisp :results output silent
  (use-package project
    :ensure nil
    :straight nil
    :init
    (advice-add 'evil-make :before
                #'(lambda (&rest _) (require 'project)))
    :config
    ;; NOTE: no idea why this here is necessary; it gets overwritten otherwise
    (general-define-key
     :keymaps 'project-prefix-map
     "d" 'project-find-dir
     "D" 'project-dired)

    (with-eval-after-load 'magit
      (general-define-key
       :keymaps 'project-prefix-map
       "v" 'magit))

    (with-eval-after-load 'consult
      (general-define-key
       :keymaps 'project-prefix-map
       "b" 'consult-project-buffer
       "C" 'consult-compile-error))

    (with-eval-after-load 'savehist
      (add-to-list 'savehist-additional-variables 'compile-history))

    ;; TODO: Also make `compile-history' project-local
    (defun --compile-command-completing-read ()
      (interactive)
      (require 'dash)
      (require 'project)
      (let ((command (--completing-read "Compile command: "
                                        compile-history
                                        :default-value compile-command))
            (default-directory (or (project-root (project-current)) default-directory)))
        (add-to-history 'compile-history command)
        (compile command)))

    (defun --delete-command-from-compile-history-completing-read ()
      "Finds a compile command and removes it from `compile-history'"
      (interactive)
      (require 'dash)
      (require 'project)
      (let ((command (--completing-read "Compile command: "
                                        compile-history
                                        :default-value compile-command)))
        (setq compile-history (remove command compile-history))))

    (defun --find-project-todo-file ()
      (interactive)
      (require 'project)
      (if-let ((proj-current (project-current))
               (todo (f-join (project-root proj-current) ".todo.md")))
          (find-file-other-window todo)
        (error "No todo.md found in %s" default-directory)))

    (general-define-key
     :keymaps 'project-prefix-map
     "c" #'--compile-command-completing-read
     "t" #'--find-project-todo-file)

    (unless (or (eq system-type 'windows-nt)
                (eq system-type 'ms-dos))
      (general-define-key
       :keymaps 'project-prefix-map
       "s" #'term))

    (defun --project-find-readme ()
      "Finds and lists all the README (eventually documentation) files "
      (interactive)
      (require 'dash)
      (let* ((case-fold-search t) ; ignore cases
             ;; same reasoning as `--compile-command-completing-read'
             (project-dir (project-root (project-current)))
             (readme-list (->> (project-files (project-current))
                               (-keep (lambda (elem)
                                        (when (string-match-p "readme" elem nil)
                                          elem)))
                               (mapcar #'(lambda (file)
                                           (f-relative file
                                            project-dir)))))
             (readme (--completing-read "README: " readme-list
                                        :require-match t)))
        (find-file (f-join project-dir readme))))

    (my-evil-define-split-vsplit-cmd "readme" #'--project-find-readme)

    (with-eval-after-load 'consult
      (defun --consult-ripgrep-with-initial ()
        (interactive)
        (require 'thingatpt)
        (consult-ripgrep nil
                         (cond
                          ((use-region-p) (buffer-substring-no-properties (region-beginning)
                                                                          (region-end)))
                          ((thing-at-point 'symbol)))))

      (general-define-key
       :keymaps 'project-prefix-map
       "g" '--consult-ripgrep-with-initial))

    (with-eval-after-load 'rg
      (general-define-key
       :keymaps 'project-prefix-map
       "G" 'rg-project)))
#+end_src

* Calendar Mode
#+begin_src emacs-lisp :results output silent
  (use-package calendar
    :ensure nil
    :straight nil
    :custom
    (calendar-week-start-day 1 "monday"))
#+end_src

* Hydras
#+begin_src emacs-lisp :results output silent
  (use-package hydra
    :straight t)
#+end_src

* Calibre
#+begin_src emacs-lisp :results output silent
  (use-package calibredb
    :straight t
    :commands (calibredb))
#+end_src

* devdocs
#+begin_src emacs-lisp :results output silent
  (use-package devdocs
    :straight (:host github :repo "blahgeek/emacs-devdocs-browser")
    :commands
    (devdocs-browser-open
     devdocs-browser-open-in
     devdocs-browser-list-docs
     devdocs-browser-update-docs
     devdocs-browser-install-doc
     devdocs-browser-uninstall-doc
     devdocs-browser-upgrade-doc
     devdocs-browser-download-offline-data
     devdocs-browser-remove-offline-data)
    :custom
    (evil-lookup-func #'devdocs-browser-open)
    :init
    (evil-ex-define-cmd "devdocs" 'devdocs-browser-open)
    (evil-ex-define-cmd "docs" 'devdocs-browser-open)
    (evil-ex-define-cmd "kk" 'devdocs-browser-open))
#+end_src

* Evaluation Result Overlay for Emacs Lisp
#+begin_src emacs-lisp :results output silent
  (use-package eros
    :straight t
    :config
    (eros-mode))
#+end_src

* Moonscript
#+begin_src emacs-lisp :results output silent
  (use-package moonscript
    :straight t)
#+end_src

* Decide-mode
#+begin_src emacs-lisp :results output silent
  (use-package decide
    :straight t
    :config
    (decide-mode))
#+end_src

* Fancy-dabbrev
Not sure if this is an actually useful package. I'm not sure if I or
the packages I run use dabbrev at all.

#+begin_src emacs-lisp :results output silent
  (use-package fancy-dabbrev
    :straight t
    :config
    (fancy-dabbrev-mode))
#+end_src

* Topsy
#+begin_src emacs-lisp :results output silent
  (use-package topsy
    :straight (:host github :repo "alphapapa/topsy.el"))
#+end_src

* HCL-mode
#+begin_src emacs-lisp :results output silent
  (use-package hcl-mode
    :straight t)
#+end_src

* Terraform mode
#+begin_src emacs-lisp :results output silent
  (use-package terraform-mode
    :straight t
    :hook (terraform-mode-hook . terraform-format-on-save-mode)
    :config
    (with-eval-after-load 'tree-sitter
      (add-hook 'terraform-mode-hook #'tree-sitter-mode)))
#+end_src

* Docker
https://github.com/Silex/docker.el
#+begin_src emacs-lisp :results output silent
  (use-package docker
    :straight t
    :commands docker
    :init
    (evil-ex-define-cmd "docker" #'docker))
#+end_src

* Dockerfile mode
#+begin_src emacs-lisp :results output silent
  (use-package dockerfile-mode
    :straight t)
#+end_src

* Speed type
#+begin_src emacs-lisp :results output silent
  (use-package speed-type
    :straight t
    :commands speed-type-text)
#+end_src

* Secret mode
#+begin_src emacs-lisp :results output silent
  (use-package secret-mode
    :straight (:host github :repo "bkaestner/secret-mode.el")
    :commands secret-mode)
#+end_src

* Nano Modeline
#+begin_src emacs-lisp :results output silent
  (use-package nano-modeline
    :disabled t
    :straight (:host github :repo "rougier/nano-modeline")
    :custom
    (nano-modeline-position 'bottom "otherwise conflicts with LSP")
    ;; (nano-modeline-position 'top)
    :custom-face
    (nano-modeline-active-status-RO ((t (:foreground ,sol-yellow)))) ;; not working for some reason?
    (nano-modeline-inactive-name ((((background light))
                                   (:foreground ,sol-base1))
                                  (((background dark))
                                   (:foreground ,sol-base01))))
    ;; (nano-modeline-active-status-** ((t (:background ,sol-yellow))))
    :config
    (nano-modeline-mode))
#+end_src

* mmm-mode
#+begin_src emacs-lisp :results output silent
  (use-package mmm-mode
    :straight t
    :custom-face
    (mmm-default-submode-face ((t (:background nil)))))
#+end_src

* Proced
#+begin_src emacs-lisp :results output silent
  (evil-ex-define-cmd "ps" 'proced)
#+end_src

* code-review
#+begin_src emacs-lisp :results output silent
  (use-package code-review
    :straight (:host github :repo "wandersoncferreira/code-review")
    :commands (code-review-start
               code-review-forge-pr-at-point)
    :config
    (add-to-list 'evil-motion-state-modes 'code-review-mode))
#+end_src

* ObjC
#+begin_src emacs-lisp :results output silent
  (add-to-list 'auto-mode-alist '("\\.mm\\'" . objc-mode))
#+end_src

* Typescript
#+begin_src emacs-lisp :results output silent
  (use-package typescript-mode
    :straight t
    :mode "\\.ts\\'"
    :config
    (with-eval-after-load 'tree-sitter
      (add-hook 'typescript-mode-hook 'tree-sitter-hl-mode)))
#+end_src

* Mermaid
#+begin_src emacs-lisp :results output silent
  (use-package mermaid-mode
    :straight t
    :if (and (bound-and-true-p --mermaid-cli-bin)
             (f-exists-p --mermaid-cli-bin))
    :custom
    (mermaid-mmdc-location --mermaid-cli-bin))
#+end_src

** Ob-Mermaid
#+begin_src emacs-lisp :results output silent
  (use-package ob-mermaid
    :after org
    :straight t
    :if (and (bound-and-true-p --mermaid-cli-bin)
             (f-exists-p --mermaid-cli-bin))
    :custom
    (ob-mermaid-cli-path --mermaid-cli-bin))
#+end_src

* Svg Tag Mode
#+begin_src emacs-lisp :results output silent
  (use-package svg-lib
    :straight
    (:host github :repo "rougier/svg-lib"))
#+end_src

#+begin_src emacs-lisp :results output silent
  (use-package svg-tag-mode
    :straight t ;; depends on `svg-lib'
    :after svg-lib)
#+end_src

* Vterm
https://github.com/akermu/emacs-libvterm

#+begin_src emacs-lisp :results output silent
  (use-package vterm
    :disabled t ;; until I figure out what's going on
    :straight t
    :custom
    (vterm-max-scrollback 100000 "maximum allowed without recompilation")
    (vterm-always-compile-module t)
    :config
    (evil-ex-define-cmd "term" #'vterm))
#+end_src

** Multi-Vterm
#+begin_src emacs-lisp :results output silent
  (use-package multi-vterm
    :straight t
    :after vterm
    :commands (multi-vterm)
    :general
    (general-define-key
     :keymaps 'project-prefix-map
     "s" 'multi-vterm-project) ;; overrides `project-shell'
    :init
    (evil-ex-define-cmd "term" #'multi-vterm))
#+end_src

* Term
** Multi-Term
#+begin_src emacs-lisp :results output silent
  (use-package multi-term
    :straight t
    :commands
    (multi-term)
    :init
    (with-eval-after-load 'project
     (general-define-key
      :keymaps 'project-prefix-map
      "s" #'multi-term)))
#+end_src

* Kotlin Mode
#+begin_src emacs-lisp :results output silent
  (use-package kotlin-mode
    :straight t
    :mode ("\\.kt\\'" . kotlin-mode))
#+end_src

* Swift Mode
#+begin_src emacs-lisp :results output silent
  (use-package swift-mode
    :straight t
    :mode ("\\.swift\\'" . swift-mode))
#+end_src
* Per-buffer idle saving
#+begin_src emacs-lisp :results output silent
  (use-package salv
    :straight (:host github :repo "alphapapa/salv.el"))
#+end_src

* Shortdoc
#+begin_src emacs-lisp :results output silent
  (when (fboundp 'shortdoc)
    (evil-ex-define-cmd "cheat[sheet]" 'shortdoc))
#+end_src

* dwim shell command
#+begin_src emacs-lisp :results output silent
  (use-package dwim-shell-command
    :straight (:host github :repo "xenodium/dwim-shell-command"))
#+end_src

* Visual-Fill-Column-Mode
#+begin_src emacs-lisp :results output silent
  (use-package visual-fill-column
    :straight (:branch "main"))
#+end_src

* Env from Shell
#+begin_src emacs-lisp :results output silent
  (use-package exec-path-from-shell
    :straight t
    :config
    (when (daemonp)
      (exec-path-from-shell-initialize)))
#+end_src

* Deft (electric boogaloo)
Lets try that again

#+begin_src emacs-lisp :results output silent
  (use-package deft
    :straight (:branch "master" :repo "jrblevin/deft")
    ;; :commands (deft
    ;;            deft-filter
    ;;            deft-setup) ;; call this if no .deft folder is found
    :custom
    ;; (deft-auto-save-interval 0.0
    ;;   "Disable autosave because of permissions issues causing massive
    ;;   lag")
    ;; enc is just what we call encrypted files. we do this so that
    ;; org-agenda-files won't try to open journal.org
    (deft-extensions '("md") "Set the extensions for deft notes")
    (deft-recursive t "Recursively search so we can organise by folders")
    (deft-time-format "%Y-%m-%d %H%M")
    ;; (deft-ignore-file-regexp "\\(?:^$\\)")
    (deft-ignore-file-regexp "\\(?:\\.#\\)+\\|#")
    (deft-use-filter-string-for-filename t)
    (deft-use-filename-as-title t)
    (deft-default-extension "md" "prefer markdown files for now")
    (deft-current-sort-method 'mtime)
    (deft-filter-only-filenames nil)
    (deft-file-limit 300)
    (deft-file-naming-rules '((nospace . "-")
                              (case-fn . downcase)))
    (deft-directory `,(or --notes-folder deft-directory))
    :general
    (deft-mode-map
      [remap evil-quit] 'quit-window)
    (:keymaps 'deft-mode-map
     :states  '(insert normal motion)
     "C-j"    'forward-button
     "C-k"    'backward-button
     ;; make it more like helm, which defaults to this
     "M-j"    'forward-button
     "M-k"    'backward-button)
    (:keymaps 'deft-mode-map
     :states  'normal
     "o"      'deft-complete
     "O"     #'(lambda () (interactive)
                 (deft-open-file-other-window t))
     "r"      'deft-rename-file
     ;; first emacsy binding in a vim state [2018-03-21 Wed]
     "q"      'quit-window
     "p"      'deft-filter-yank
     "d d"    'deft-delete-file
     "g r"    'deft-refresh
     "-"      'open-dired-window)
    (:keymaps 'deft-mode-map
     :states  'insert
     "C-w"    'deft-filter-decrement-word
     "C-u"    'deft-filter-clear)
    :hook ((deft-mode-hook . deft-filter-clear)
           (deft-mode-hook . evil-insert-state))
    :init
    (my-evil-define-split-vsplit-cmd "nn" 'deft)
    (evil-ex-define-cmd "Tnn" #'(lambda ()
                                  (interactive)
                                  (if (not (featurep 'tab-bar))
                                      (warn "tab-bar not available")
                                    (tab-bar-new-tab)
                                    (call-interactively #'deft))))
    :config
    (define-advice deft (:after (&rest _) enter-insert-state)
      (deft-filter-clear)
      (evil-insert-state)))
#+end_src
